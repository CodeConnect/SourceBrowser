<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.CodeAnalysis</name>
    </assembly>
    <members>
        <member name="M:Microsoft.CodeAnalysis.AbstractLookupSymbolsInfo`1.TryGetAritiesAndUniqueSymbol(System.String,Microsoft.CodeAnalysis.AbstractLookupSymbolsInfo{`0}.IArityEnumerable@,`0@)">
            <summary>
            If <paramref name="uniqueSymbol"/> is set, then <paramref name="arities"/> will be null.
            The only arity in that case will be encoded in the symbol. 
            </summary>
            <param name="name"></param>
            <param name="arities"></param>
            <param name="uniqueSymbol"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CaseInsensitiveComparison">
            <summary>
            Case-insensitive operations (mostly comparison) on unicode strings.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CaseInsensitiveComparison.OneToOneUnicodeComparer">
            <summary>
            This class seeks to perform one-to-one lowercase Unicode case mappings, which should be culture invariant.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.OneToOneUnicodeComparer.ToLower(System.Char)">
            <summary>
            ToLower implements the one-to-one Unicode lowercase mapping
            as descriped in ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt.
            The VB spec states that these mappings are used for case-insensitive
            comparison
            </summary>
            <param name="c"></param>
            <returns>If <paramref name="c"/> is upper case, then this returns its lower case equivalent. Otherwise, <paramref name="c"/> is returned unmodified.</returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CaseInsensitiveComparison.m_Comparer">
            <summary>
            Returns a StringComparer that compares strings according the VB identifier comparison rules.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CaseInsensitiveComparison.Comparer">
            <summary>
            Returns a StringComparer that compares strings according the VB identifier comparison rules.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.Equals(System.String,System.String)">
            <summary>
            Determines if two VB identifiers are equal according to the VB identifier comparison rules.
            </summary>
            <param name="left">First identifier to compare</param>
            <param name="right">Second identifier to compare</param>
            <returns>true if the identifiers should be considered the same.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.EndsWith(System.String,System.String)">
            <summary>
            Determines if the string 'value' end with string 'possibleEnd'.
            </summary>
            <param name="value"></param>
            <param name="possibleEnd"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.Compare(System.String,System.String)">
            <summary>
            Compares two VB identifiers according to the VB identifier comparison rules.
            </summary>
            <param name="left">First identifier to compare</param>
            <param name="right">Second identifier to compare</param>
            <returns>-1 if <paramref name="left"/> &lt; <paramref name="right"/>, 1 if <paramref name="left"/> &gt; <paramref name="right"/>, 0 if they are equal.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.GetHashCode(System.String)">
            <summary>
            Gets a case-insensitive hash code for VB identifiers.
            </summary>
            <param name="value">identifier to get the hash code for</param>
            <returns>The hash code for the given identifier</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.ToLower(System.String)">
            <summary>
            Convert a string to lower case in culture invariant way
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.ToLower(System.Text.StringBuilder)">
            <summary>
            In-place convert string in StringBuilder to lower case in culture invariant way
            </summary>
            <param name="builder"></param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeAnalysisResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.AbsolutePathExpected">
            <summary>
              Looks up a localized string similar to Absolute path expected..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.ArraysWithMoreThanOneDimensionCannotBeSerialized">
            <summary>
              Looks up a localized string similar to Arrays with more than one dimension cannot be serialized..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Assembly">
            <summary>
              Looks up a localized string similar to assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.AssemblyFileNotFound">
            <summary>
              Looks up a localized string similar to Assembly file not found.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.AssemblyMustHaveAtLeastOneModule">
            <summary>
              Looks up a localized string similar to Assembly must have at least one module..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.AssemblySigningNotSupported">
            <summary>
              Looks up a localized string similar to Assembly signing not supported..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.CannotAliasModule">
            <summary>
              Looks up a localized string similar to Can&apos;t alias a module..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.CannotCreateReferenceToModule">
            <summary>
              Looks up a localized string similar to Can&apos;t create a reference to a module..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.CannotCreateReferenceToSubmission">
            <summary>
              Looks up a localized string similar to Can&apos;t create a reference to a submission..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.CannotEmbedInteropTypesFromModule">
            <summary>
              Looks up a localized string similar to Can&apos;t embed interop types from module..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Class1">
            <summary>
              Looks up a localized string similar to class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.CoffResourceInvalidRelocation">
            <summary>
              Looks up a localized string similar to Win32 resources, assumed to be in COFF object format, have one or more invalid relocation header values..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.CoffResourceInvalidSectionSize">
            <summary>
              Looks up a localized string similar to Win32 resources, assumed to be in COFF object format, have an invalid section size..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.CoffResourceInvalidSymbol">
            <summary>
              Looks up a localized string similar to Win32 resources, assumed to be in COFF object format, have one or more invalid symbol values..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.CoffResourceMissingSection">
            <summary>
              Looks up a localized string similar to Win32 resources, assumed to be in COFF object format, are missing one or both of sections &apos;.rsrc$01&apos; and &apos;.rsrc$02&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.CompilationOptionsMustNotHaveErrors">
            <summary>
              Looks up a localized string similar to Compilation options must not have errors..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.CompilerAnalyzerFailure">
            <summary>
              Looks up a localized string similar to Compiler Analyzer Failure.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.CompilerAnalyzerThrows">
            <summary>
              Looks up a localized string similar to The Compiler Analyzer &apos;{0}&apos; threw an exception with message &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Constructor">
            <summary>
              Looks up a localized string similar to constructor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Delegate1">
            <summary>
              Looks up a localized string similar to delegate.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.EmptyOrInvalidFileName">
            <summary>
              Looks up a localized string similar to Empty or invalid file name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.EmptyOrInvalidResourceName">
            <summary>
              Looks up a localized string similar to Empty or invalid resource name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.EndMustNotBeLessThanStart">
            <summary>
              Looks up a localized string similar to &apos;end&apos; must not be less than &apos;start&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Enum1">
            <summary>
              Looks up a localized string similar to enum.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Event1">
            <summary>
              Looks up a localized string similar to event.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.ExpectedNonEmptyPublicKey">
            <summary>
              Looks up a localized string similar to Expected non-empty public key.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.FailedToResolveRuleSetName">
            <summary>
              Looks up a localized string similar to Could not locate the rule set file &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Field">
            <summary>
              Looks up a localized string similar to field.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.FileNotFound">
            <summary>
              Looks up a localized string similar to File not found..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.FileSizeExceedsMaximumAllowed">
            <summary>
              Looks up a localized string similar to File size exceeds maximum allowed size of a valid metadata file..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.GetMetadataMustReturnInstance">
            <summary>
              Looks up a localized string similar to {0}.GetMetadata() must return an instance of {1}..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.IconStreamUnexpectedFormat">
            <summary>
              Looks up a localized string similar to Icon stream is not in the expected format..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InMemoryAssembly">
            <summary>
              Looks up a localized string similar to &lt;in-memory assembly&gt;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InMemoryModule">
            <summary>
              Looks up a localized string similar to &lt;in-memory module&gt;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Interface1">
            <summary>
              Looks up a localized string similar to interface.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidAlias">
            <summary>
              Looks up a localized string similar to Invalid alias..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidAssemblyName">
            <summary>
              Looks up a localized string similar to Invalid assembly name: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidCharactersInAssemblyCultureName">
            <summary>
              Looks up a localized string similar to Invalid characters in assembly culture name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidCharactersInAssemblyName">
            <summary>
              Looks up a localized string similar to Invalid characters in assembly name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidCompilationOptions">
            <summary>
              Looks up a localized string similar to Invalid compilation options -- submission can&apos;t be signed..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidContentType">
            <summary>
              Looks up a localized string similar to Invalid content type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidCultureName">
            <summary>
              Looks up a localized string similar to Invalid culture name: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidModuleName">
            <summary>
              Looks up a localized string similar to Invalid module name specified in metadata module &apos;{0}&apos;: &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidOutputKindForSubmission">
            <summary>
              Looks up a localized string similar to Invalid output kind for submission. DynamicallyLinkedLibrary expected..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidRuleSetInclude">
            <summary>
              Looks up a localized string similar to An error occurred while loading the included rule set file {0} - {1}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidSHA1Hash">
            <summary>
              Looks up a localized string similar to Invalid SHA1 hash..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidSizeOfPublicKeyToken">
            <summary>
              Looks up a localized string similar to Invalid size of public key token..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Method">
            <summary>
              Looks up a localized string similar to method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Module">
            <summary>
              Looks up a localized string similar to module.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.ModuleCopyCannotBeUsedToCreateAssemblyMetadata">
            <summary>
              Looks up a localized string similar to Module copy can&apos;t be used to create an assembly metadata..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.NameCannotBeEmpty">
            <summary>
              Looks up a localized string similar to Name cannot be empty..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.NameCannotStartWithWhitespace">
            <summary>
              Looks up a localized string similar to Name cannot start with whitespace..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.NameContainsInvalidCharacter">
            <summary>
              Looks up a localized string similar to Name contains invalid characters..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.OutputKindNotSupported">
            <summary>
              Looks up a localized string similar to Output kind not supported..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Parameter">
            <summary>
              Looks up a localized string similar to parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.PathReturnedByResolveMetadataFileMustBeAbsolute">
            <summary>
              Looks up a localized string similar to Path returned by {0}.ResolveMetadataFile must be absolute: &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.PathReturnedByResolveStrongNameKeyFileMustBeAbsolute">
            <summary>
              Looks up a localized string similar to Path returned by {0}.ResolveStrongNameKeyFile must be absolute: &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.PEImageDoesntContainManagedMetadata">
            <summary>
              Looks up a localized string similar to PE image doesn&apos;t contain managed metadata..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.PEImageNotAvailable">
            <summary>
              Looks up a localized string similar to PE image not available..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.PreviousSubmissionHasErrors">
            <summary>
              Looks up a localized string similar to Previous submission has errors..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Property">
            <summary>
              Looks up a localized string similar to property, indexer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.ReferenceResolverShouldReturnReadableNonNullStream">
            <summary>
              Looks up a localized string similar to Reference resolver should return readable non-null stream..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.ResourceDataProviderShouldReturnNonNullStream">
            <summary>
              Looks up a localized string similar to Resource data provider should return non-null stream.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.ResourceStreamProviderShouldReturnNonNullStream">
            <summary>
              Looks up a localized string similar to Resource stream provider should return non-null stream..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Return1">
            <summary>
              Looks up a localized string similar to return.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.ReturnTypeCannotBeValuePointerbyRefOrOpen">
            <summary>
              Looks up a localized string similar to Return type can&apos;t be a value type, pointer, by-ref or open generic type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.ReturnTypeCannotBeVoidByRefOrOpen">
            <summary>
              Looks up a localized string similar to Return type can&apos;t be void, by-ref or open generic type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.RuleSetSchemaViolation">
            <summary>
              Looks up a localized string similar to The file does not conform to the rule set schema - {0}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.SizeHasToBePositive">
            <summary>
              Looks up a localized string similar to Size has to be positive..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.SpanDoesNotIncludeEndOfLine">
            <summary>
              Looks up a localized string similar to Then span does not include the end of a line..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.SpanDoesNotIncludeStartOfLine">
            <summary>
              Looks up a localized string similar to The span does not include the start of a line..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.StartMustNotBeNegative">
            <summary>
              Looks up a localized string similar to &apos;start&apos; must not be negative.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.StreamMustSupportReadAndSeek">
            <summary>
              Looks up a localized string similar to Stream must support read and seek operations..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Struct1">
            <summary>
              Looks up a localized string similar to struct.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.TypeMustBeASubclassOfSyntaxAnnotation">
            <summary>
              Looks up a localized string similar to type must be a subclass of SyntaxAnnotation..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.TypeMustBeSameAsHostObjectTypeOfPreviousSubmission">
            <summary>
              Looks up a localized string similar to Type must be same as host object type of previous submission..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.TypeParameter">
            <summary>
              Looks up a localized string similar to type parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Unresolved">
            <summary>
              Looks up a localized string similar to Unresolved: .
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.ValueTooLargeToBeRepresented">
            <summary>
              Looks up a localized string similar to Value too large to be represented as a 30 bit unsigned integer..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.WinRTIdentityCantBeRetargetable">
            <summary>
              Looks up a localized string similar to WindowsRuntime identity can&apos;t be retargetable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.XmlReferencesNotSupported">
            <summary>
              Looks up a localized string similar to References to XML documents are not supported..
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ArrayMethods">
            <summary>
            Constructs and caches already created pseudo-methods.
            Every compiled module is supposed to have one of this, created lazily 
            (multidimensional arrays are not common).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ArrayMethods.GetArrayConstructor(Microsoft.Cci.IArrayTypeReference)">
            <summary>
            Acquires an array constructor for a given array type
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ArrayMethods.GetArrayGet(Microsoft.Cci.IArrayTypeReference)">
            <summary>
            Acquires an element getter method for a given array type
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ArrayMethods.GetArraySet(Microsoft.Cci.IArrayTypeReference)">
            <summary>
            Acquires an element setter method for a given array type
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ArrayMethods.GetArrayAddress(Microsoft.Cci.IArrayTypeReference)">
            <summary>
            Acquires an element referencer method for a given array type
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.ArrayMethods.dict">
            <summary>
            Maps {array type, method kind} tuples to implementing pseudo-methods.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ArrayMethods.GetArrayMethod(Microsoft.Cci.IArrayTypeReference,Microsoft.CodeAnalysis.CodeGen.ArrayMethods.ArrayMethodKind)">
            <summary>
            lazily fetches or creates a new array method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ArrayMethods.ArrayConstructor">
            <summary>
            "newobj ArrayConstructor"  is equivalent of "newarr ElementType" 
            when working with multidimentsional arrays
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ArrayMethods.ArrayGet">
            <summary>
            "call ArrayGet"  is equivalent of "ldelem ElementType" 
            when working with multidimentsional arrays
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ArrayMethods.ArrayAddress">
            <summary>
            "call ArrayAddress"  is equivalent of "ldelema ElementType" 
            when working with multidimentsional arrays
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ArrayMethods.ArraySet">
            <summary>
            "call ArraySet"  is equivalent of "stelem ElementType" 
            when working with multidimentsional arrays
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ArrayMethodParameterInfo">
            <summary>
            Represents a parameter in an array pseudo-method.
            
            NOTE: It appears that that only number of indeces is used for verification, 
            types just have to be Int32.
            Even though actual arguments can be native ints.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ArraySetValueParameterInfo">
            <summary>
            Represents the "value" parameter of the Set pseudo-method.
            
            NOTE: unlike index parameters, type of the value parameter must match 
            the actual element type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ArrayMethod">
            <summary>
            Base of all array methods. They have a lot in common.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.ILBuilder.Reachability.NotReachable">
            <summary>
            Block is not reachable or reachability analysis
            has not been performed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.ILBuilder.Reachability.Reachable">
            <summary>
            Block can be reached either falling through
            from previous block or from branch.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.ILBuilder.Reachability.BlockedByFinally">
            <summary>
            Block is reachable from try or catch but
            finally prevents falling through.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock.IsBranchToLabel">
            <summary>
            Returns true if this block has a branch label
            and is not a "nop" branch.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock.RegularInstructions">
            <summary>
            Instructions that are not branches.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock.HasNoRegularInstructions">
            <summary>
            The block contains only the final branch or nothing at all
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock.AdjustForDelta(System.Int32)">
            <summary>
            Updates position of the current block to account for shorter sizes of previous blocks.
            </summary>
            <param name="delta"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock.ShortenBranches(System.Int32@)">
            <summary>
            If possible, changes the branch code of the current block to the short version and 
            updates the delta correspondingly.
            </summary>
            <param name="delta">Position delta created by previous block size reductions.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock.OptimizeBranches(System.Int32@)">
            <summary>
            replaces branches with more compact code if possible.
            * same branch as in the next     ===> nop
            * branch to the next block       ===> nop
            * branch to ret block            ===> ret
            * cond branch over uncond branch ===> flip condition, skip next block
            * cond branch to equivalent      ===> pop args + nop
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock.AreIdentical(Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock,Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock)">
            <summary>
            Blocks are identical if:
            1) have same regular instructions
            2) lead to unconditional control transfer (no fall through)
            3) branch with the same instruction to the same label
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock.GetReversedBranchOp">
            <summary>
            Returns reversed branch operation for the current block.
            If no reverse opcode can be obtained Nop is returned.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ILBuilder.EmitState">
            <summary>
            Abstract Execution state. 
            If we know something interesting about IL stream we put it here.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.ILBuilder.EmitState.MaxStack">
            <summary>
            Eval stack's high watermark.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.ILBuilder.EmitState.CurStack">
            <summary>
            Current evaluation stack depth.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.EmitState.AdjustStack(System.Int32)">
            <summary>
            Record effects of that currently emitted instruction on the eval stack.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.ILBuilder.allocatedILMarkers">
            <summary> 
            In some cases we have to get a final IL offset during emit phase, for example for
            proper emitting sequence points. The problem is that before the builder is realized we 
            don't know the actual IL offset, but only {block/offset-in-the-block} pair. 
            
            Thus, whenever we need to mark some IL position we allocate a new marker id, store it 
            in allocatedILMarkers and reference this IL marker in the entity requiring the IL offset.
            
            IL markers will be 'materialized' when the builder is realized; the resulting offsets
            will be put into allocatedILMarkers array. Note that only markers from reachable blocks 
            are materialized, the rest will have offset -1.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.Realize">
            <summary>
            Realizes method body.
            No more data can be added to the builder after this call.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.GetAllScopes(System.Boolean)">
            <summary>
            Gets all scopes that contain variables.
            </summary>
            <param name="edgeInclusive">Specifies whether scope spans should be reported as edge inclusive
            (position at "start + length" is IN the scope). VB EE expects that.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.GetIteratorScopes(System.Boolean)">
            <summary>
            Gets all scopes that contain variables.
            </summary>
            <param name="edgeInclusive">Specifies whether scope spans should be reported as edge inclusive
            (position at "start + length" is IN the scope). VB EE expects that.</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.ILBuilder.InstructionsEmitted">
            <summary>
            IL opcodes emitted by this builder.
            This includes branch instructions that end blocks except if they are fall-through NOPs.
            
            This count allows compilers to see if emitting a particular statement/expression 
            actually produced any instructions.
            
            Example: a label will not result in any code so when emitting debugging information 
                     an extra NOP may be needed if we want to decorate the label with sequence point. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.MarkReachableBlocks">
            <summary>
            Marks blocks that are reachable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.MarkReachableFrom(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock},Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock)">
            <summary>
            Marks blocks that are recursively reachable from the given block.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.OptimizeLabels">
            <summary>
            If a label points to a block that does nothing other than passing to block X,
            replaces target label's block with block X.
            </summary>
            
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.DropUnreachableBlocks">
            <summary>
            Drops blocks that are not reachable
            Returns true if any blocks were dropped
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.MarkAllBlocksUnreachable">
            <summary>
            Marks all blocks unreachable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.RewriteSpecialBlocks">
            <summary>
            Rewrite any block marked as BlockedByFinally as an "infinite loop".
            </summary>
            <remarks>
            Matches the code generated by the native compiler in
            ILGENREC::AdjustBlockedLeaveTargets.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.IsSpecialEndHandlerBlock(Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock)">
            <summary>
            Returns true if the block has the signature of the special
            labeled block that follows a complete try/catch or try/finally.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.ComputeOffsetsAndAdjustBranches">
            <summary>
            Returns true if any branches were optimized (that does not include shortening)
            We need this because optimizing a branch may result in unreachable code that needs to be eliminated.
            
            === Example:
            
            x = 1;
            
            if (blah)
            {
                global = 1;
            }
            else
            {
                throw null;
            }
            
            return x;
            
            === rewrites into
            
            push 1;
            
            if (blah)
            {
                global = 1;
                ret; 
            }
            else
            {
                throw null;
            }
            
            // this ret unreachable now! 
            // even worse - empty stack is assumed thus the ret is illegal.
            ret;    
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.DefineSeqPoint(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Define a sequence point with the given syntax tree and span within it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.DefineHiddenSeqPoint">
            <summary>
            Defines a hidden sequence point.
            The effect of this is that debugger will not associate following code 
            with any source (until it sees a lexically following sequence point).
            
            This is used for synthetic code that is reachable through labels.
            
            If such code is not separated from previous sequence point by the means of a hidden sequence point
            It looks as a part of the statement that previous sequence point specifies.
            As a result, when user steps through the code and goes through a jump to such label,
            it will appear as if the jump landed at the beginning of the previous statement.
            
            NOTE: Also inserted as the first statement of a method that would not otherwise have a leading
            sequence point so that step-into will find the method body.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.DefineInitialHiddenSeqPoint">
            <summary>
            Define a hidden sequence point at the first statement of
            the method so that step-into will find the method body.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.SetInitialDebugDocument(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            This is called when starting emitting a method for which there is some source.
            It is done in case the first sequence point is a hidden point.
            Even though hidden points do not have syntax, they need to associate with some document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.MarkFilterConditionEnd">
            <summary>
            Marks the end of filter condition and start of the actual filter handler.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.DefineIteratorLocal(System.Int32)">
            <summary>
            See Microsoft.Cci.ILocalScopeProvider.GetIteratorScopes.  This is called within an
            iterator scope to identify that a field named "&lt;Xyzzy&gt;5__i" is used to represent
            a local variable named Xyzzy.  The "i" is an integer, which is passed to this method
            as the index parameter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.AddLocalToScope(Microsoft.CodeAnalysis.CodeGen.LocalDefinition)">
            <summary>
            Puts local variable into current scope.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.AddLocalConstantToScope(Microsoft.CodeAnalysis.CodeGen.LocalConstantDefinition)">
            <summary>
            Puts local constant into current scope.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.MarkLabel(System.Object)">
            <summary>
            Mark current IL position with a label
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.EmitStringSwitchJumpTable(System.Collections.Generic.KeyValuePair{Microsoft.CodeAnalysis.ConstantValue,System.Object}[],System.Object,Microsoft.CodeAnalysis.CodeGen.LocalDefinition,Microsoft.CodeAnalysis.CodeGen.LocalDefinition,Microsoft.CodeAnalysis.CodeGen.SwitchStringJumpTableEmitter.EmitStringCompareAndBranch,Microsoft.CodeAnalysis.CodeGen.SwitchStringJumpTableEmitter.GetStringHashCode)">
            <summary>
            Primary method for emitting string switch jump table
            </summary>
            <param name="caseLabels">switch case labels</param>
            <param name="fallThroughLabel">fall through label for the jump table</param>
            <param name="key">Local holding the value to switch on.
            This value has already been loaded onto the execution stack.
            </param>
            <param name="keyHash">Local holding the hash value of the key for emitting
            hash table switch. Hash value has already been computed and loaded into keyHash.
            This parameter is null if emitting non hash table switch.
            </param>
            <param name="emitStringCondBranchDelegate">
            Delegate to emit string compare call and conditional branch based on the compare result.
            </param>
            <param name="computeStringHashcodeDelegate">
            Delegate to compute string hash consistent with value of keyHash.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.EmitIntegerSwitchJumpTable(System.Collections.Generic.KeyValuePair{Microsoft.CodeAnalysis.ConstantValue,System.Object}[],System.Object,Microsoft.CodeAnalysis.CodeGen.LocalDefinition,Microsoft.Cci.PrimitiveTypeCode)">
            <summary>
            Primary method for emitting integer switch jump table
            </summary>
            <param name="caseLabels">switch case labels</param>
            <param name="fallThroughLabel">fall through label for the jump table</param>
            <param name="keyLocal">Local holding the value to switch on.
            This value has already been loaded onto the execution stack.
            </param>
            <param name="keyTypeCode">Primitive type code of switch key</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.EmitIntegerSwitchJumpTable(System.Collections.Generic.KeyValuePair{Microsoft.CodeAnalysis.ConstantValue,System.Object}[],System.Object,System.Int32,Microsoft.Cci.PrimitiveTypeCode)">
            <summary>
            Primary method for emitting integer switch jump table
            </summary>
            <param name="caseLabels">switch case labels</param>
            <param name="fallThroughLabel">fall through label for the jump table</param>
            <param name="keyArgumentIndex">Index of the parameter to switch on.
            This value has already been loaded onto the execution stack.
            </param>
            <param name="keyTypeCode">Primitive type code of switch key</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.FinishFilterCondition">
            <summary>
            Finishes filter condition (and starts actual handler portion of the handler).
            Returns the last block of the condition.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.EmitArrayCreation(Microsoft.Cci.IArrayTypeReference,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Generates code that creates an instance of multidimensional array
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.EmitArrayElementLoad(Microsoft.Cci.IArrayTypeReference,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Generates code that loads an element of a multidimensional array
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.EmitArrayElementAddress(Microsoft.Cci.IArrayTypeReference,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Generates code that loads an address of an element of a multidimensional array
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.EmitArrayElementStore(Microsoft.Cci.IArrayTypeReference,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Generates code that stores an element of a multidimensional array
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ILBuilder.LabelInfo">
            <summary>
            Contains information about a label.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.ILBuilder.LabelInfo.targetOfConditionalBranches">
            <summary>
            Sometimes we need to know if a label is targeted by conditional branches.
            For example optimizer can do optimizations of branches into outer try scopes only 
            if they are unconditional (because there are no conditional Leave opcodes)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.LabelInfo.#ctor(System.Int32,System.Boolean)">
            <summary>
            Used when we see a branch, but label is not yet marked.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.LabelInfo.#ctor(Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock,System.Int32,System.Boolean)">
            <summary>
            Used when label is marked to the code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.LocalScopeManager.GetAllScopesWithLocals(System.Boolean)">
            <summary>
            Gets all scopes that contain variables.
            </summary>
            <param name="edgeInclusive">Specifies whether scope spans should be reported as edge inclusive
            (position at "start + length" is IN the scope). VB EE expects that.</param>
            <returns></returns>
            <remarks>
            NOTE that edgeInclusive affects only how results are _reported_. 
            All internal representation is EDGE EXCLUSIVE.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.LocalScopeManager.GetExceptionHandlerRegions">
            <summary>
            Returns an ExceptionHandlerRegion for each exception handler clause
            beneath the root scope. Each ExceptionHandlerRegion indicates the type
            of clause (catch or finally) and the bounds of the try block and clause block.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ILBuilder.ScopeInfo">
            <summary>
            Base class for IL scopes where a scope contains IL blocks and other nested
            scopes. A scope may represent a scope for variable declarations, an exception
            handler clause, or an entire exception handler (multiple clauses).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.ScopeInfo.GetScopesWithLocals(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.Cci.LocalScope},System.Boolean)">
            <summary>
            Recursively calculates the start and end of the given scope.
            Only scopes with locals are actually dumped to the list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.ScopeInfo.GetIteratorScopes(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.Cci.LocalScope},System.Boolean)">
            <summary>
            Recursively calculates the start and end of the given scope.
            Only scopes with locals are actually dumped to the list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.ScopeInfo.FreeBasicBlocks">
            <summary>
            Free any basic blocks owned by this scope or sub-scopes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ILBuilder.LocalScopeInfo">
            <summary>
            Class that collects content of the scope (blocks, nested scopes, variables etc).
            There is one for every opened scope.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ILBuilder.ExceptionHandlerScope">
            <summary>
            A scope for a single try, catch, or finally clause. If the clause
            is a catch clause, ExceptionType will be set.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ILBuilder.ExceptionHandlerContainerScope">
            <summary>
            A scope for an entire exception handler (a try block with either several
            catches or a finally block). Unlike other scopes, this scope contains
            nested scopes only, no IL blocks (although nested ExceptionHandlerScopes
            for the clauses will contain IL blocks).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ILBuilder.ScopeComparer">
            <summary>
            Compares scopes by their start (ascending) and then size (descending).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILOpCodeExtensions.IsControlTransfer(Microsoft.CodeAnalysis.CodeGen.ILOpCode)">
            <summary>
            These opcodes represent control transfer.
            They should not appear inside basic blocks.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILOpCodeExtensions.IsBranchToLabel(Microsoft.CodeAnalysis.CodeGen.ILOpCode)">
            <summary>
            Opcodes that represents a branch to a label.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILOpCodeExtensions.CanFallThrough(Microsoft.CodeAnalysis.CodeGen.ILOpCode)">
            <summary>
            Opcodes that represents a branch to a label.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.LocalConstantDefinition">
            <summary>
            We need a CCI representation for local constants because they are emitted as locals in
            PDB scopes to improve the debugging experience (see LocalScopeProvider.GetConstantsInScope).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.LocalDefinition.#ctor(System.Object,System.String,Microsoft.Cci.ITypeReference,System.Int32,System.Boolean,Microsoft.CodeAnalysis.CodeGen.LocalSlotConstraints,System.Boolean,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.TypedConstant})">
            <summary>
            Creates a new LocalDefinition.
            </summary>
            <param name="identity">Local symbol, used by edit and continue only, null otherwise.</param>
            <param name="name">Name associated with the slot.</param>
            <param name="type">Type associated with the slot.</param>
            <param name="slot">Slot position in the signature.</param>
            <param name="dynamicTransformFlags">Contains the synthesized dynamic attributes of the local</param>
            <param name="isCompilerGenerated">True if the local was not declared in source.</param>
            <param name="constraints">Specifies whether slot type should have pinned modifier and whether slot should have byref constraint.</param>
            <param name="isDynamic">Specifies if the type is Dynamic.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.LocalSlotManager">
            <summary>
            At this level there are two kinds of local variables:
            <list type="bullet">
            <item>
            Locals - have identities by which consuming code refers to them.
                Typical use is a local variable or a compiler generated temp that can be accessed in multiple operations.
                Any object can be used as identity. Reference equality is used.
            </item>
            <item>
            Temps - do not have identity. They are borrowed and returned to the free list.
                Typical use is a scratch temporary or spilling storage.
            </item>
            </list>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.LocalSlotManager.LocalSignature">
            <summary>
            Structure that represents a local signature (as in <a href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf">ECMA-335</a>, Partition I, §8.6.1.3 Local signatures).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.LocalSlotManager.GetLocal(System.Object)">
            <summary>
            Retrieve a local slot by its identity.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.LocalSlotManager.FreeLocal(System.Object)">
            <summary>
            Release a local slot by its identity.
            Slot is not associated with identity after this.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.LocalSlotManager.AllocateSlot(Microsoft.Cci.ITypeReference,Microsoft.CodeAnalysis.CodeGen.LocalSlotConstraints,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.TypedConstant})">
            <summary>
            Gets a local slot.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.LocalSlotManager.FreeSlot(Microsoft.CodeAnalysis.CodeGen.LocalDefinition)">
            <summary>
            Frees a local slot.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.MetadataCreateArray">
            <summary>
            An expression that creates an array instance in metadata. Only for use in custom attributes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.MetadataCreateArray.Microsoft#Cci#IMetadataCreateArray#ElementType">
            <summary>
            The element type of the array.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.MetadataCreateArray.Microsoft#Cci#IMetadataCreateArray#Elements">
            <summary>
            The initial values of the array elements. May be empty.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.MetadataNamedArgument">
            <summary>
            An expression that represents a (name, value) pair and that is typically used in method calls, custom attributes and object initializers.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.MetadataNamedArgument.Microsoft#Cci#IMetadataNamedArgument#ArgumentName">
            <summary>
            The name of the parameter or property or field that corresponds to the argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.MetadataNamedArgument.Microsoft#Cci#IMetadataNamedArgument#ArgumentValue">
            <summary>
            The value of the argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.MetadataNamedArgument.Microsoft#Cci#IMetadataNamedArgument#IsField">
            <summary>
            True if the named argument provides the value of a field.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.MetadataTypeOf">
            <summary>
            An expression that results in a System.Type instance.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.MetadataTypeOf.TypeToGet">
            <summary>
            The type that will be represented by the System.Type instance.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.MethodBody">
            <summary>
            Holds on to the method body data.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.MethodBody.Microsoft#Cci#IMethodBody#NamespaceScopes">
            <summary>
            This is a list of the using directives that were in scope for this method body.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.PermissionSetAttributeWithFileReference">
            <summary>
            This class represents the PermissionSetAttribute specified in source which needs fixup during codegen.
            </summary>
            <remarks>
            PermissionSetAttribute needs fixup when it contains an assignment to the 'File' property as a single named attribute argument.
            Fixup performed is ported from SecurityAttributes::FixUpPermissionSetAttribute at ndp\clr\src\vm\securityattributes.cpp.
            It involves following steps:
            1) Verifying that the specified file name resolves to a valid path: This is done during binding.
            2) Reading the contents of the file into a byte array.
            3) Convert each byte in the file content into two bytes containing hexa-decimal characters (see method <see cref="M:Microsoft.CodeAnalysis.CodeGen.PermissionSetAttributeWithFileReference.ConvertToHex(System.IO.Stream)"/>).
            4) Replacing the 'File = fileName' named argument with 'Hex = hexFileContent' argument, where hexFileContent is the converted output from step 3) above.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.PermissionSetAttributeWithFileReference.GetArguments(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Zero or more positional arguments for the attribute constructor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.PermissionSetAttributeWithFileReference.Constructor(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            A reference to the constructor that will be used to instantiate this custom attribute during execution (if the attribute is inspected via Reflection).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.PermissionSetAttributeWithFileReference.GetNamedArguments(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Zero or more named arguments that specify values for fields and properties of the attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.PermissionSetAttributeWithFileReference.ArgumentCount">
            <summary>
            The number of positional arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.PermissionSetAttributeWithFileReference.NamedArgumentCount">
            <summary>
            The number of named arguments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.PermissionSetAttributeWithFileReference.GetType(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The type of the attribute. For example System.AttributeUsageAttribute.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.PermissionSetFileReadException">
            <summary>
            Exception class to enable generating ERR_PermissionSetAttributeFileReadError while reading the file for PermissionSetAttribute fixup.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.PrivateImplementationDetails">
            <summary>
            TypeDefinition that represents &lt;PrivateImplementationDetails&gt; class.
            The main purpose of this class so far is to contain mapped fields and their types.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.MetadataBlock">
            <summary>
            Represents a block in .data
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ExplicitSizeStruct">
            <summary>
            Simple struct type with explicit size and no members.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.MappedField">
            <summary>
            Definition of a simple field mapped to a metadata block
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.DefaultTypeDef">
            <summary>
            Just a default implementation of a type definition.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.RawSequencePoint">
            <summary>
            Represents a sequence point before translation by #line/ExternalSource directives.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ReferenceDependencyWalker">
            <summary>
            Some features of the compiler (such as anonymous types, pay-as-you-go, NoPIA, ...)
            rely on all referenced symbols to go through translate mechanism. Because by default
            symbol translator does not translate some of indirectly referenced symbols, such as 
            type argument, we have to force translation here
            
            This class provides unified implementation for this functionality.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.SequencePointList">
            <summary>
            Maintains a list of sequence points in a space efficient way. Most of the time sequence points
            occur in the same syntax tree, so optimize for that case. Store a sequence point as an offset, and 
            position in a syntax tree, then translate to CCI format only on demand.
            
            Use a ArrayBuilder{RawSequencePoint} to create.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.SequencePointList.Create(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CodeGen.RawSequencePoint},Microsoft.CodeAnalysis.CodeGen.ILBuilder)">
            <summary>
            Create a SequencePointList with the raw sequence points from an ArrayBuilder.
            A linked list of instances for each syntax tree is created (almost always of length one).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.SequencePointList.GetSequencePoints(Microsoft.CodeAnalysis.CodeGen.DebugDocumentProvider)">
            <summary>
            Get all the sequence points, possibly mapping them using #line/ExternalSource directives, and mapping
            file names to debug documents with the given mapping function.
            </summary>
            <param name="documentProvider">Function that maps file paths to CCI debug documents</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.SequencePointList.OffsetAndSpan">
            <summary>
            Represents the combination of an IL offset and a source text span.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.StringTokenMap">
            <summary>
            Handles storage of strings referenced via tokens in metadata. When items are stored 
            they are uniquely "associated" with fake token, which is basically a sequential number.
            IL gen will use these fake tokens during codegen and later, when actual token values 
            are known the method bodies will be patched.
            To support thse two scenarios we need two maps - Item-->uint, and uint-->Item.  (the second is really just a list).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.SwitchIntegralJumpTableEmitter">
            <summary>
            Class for emitting the switch jump table for switch statements with integral governing type
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.SwitchIntegralJumpTableEmitter.keyLocal">
            <summary>
            Switch key for the jump table
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.SwitchIntegralJumpTableEmitter.keyTypeCode">
            <summary>
            Primitive type of the switch key
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.SwitchIntegralJumpTableEmitter.fallThroughLabel">
            <summary>
            Fall through label for the jump table
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.SwitchIntegralJumpTableEmitter.sortedCaseLabels">
            <summary>
            Integral case labels sorted and indexed by their ConstantValue
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.SwitchIntegralJumpTableEmitter.SwitchBucket.TryMergeWith(Microsoft.CodeAnalysis.CodeGen.SwitchIntegralJumpTableEmitter.SwitchBucket)">
            <summary>
            Try to merge with the nextBucket.
            If merge results in a better bucket than two original ones, merge and return true.
            Else don't merge and return false.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.SwitchStringJumpTableEmitter.key">
            <summary>
            Switch key for the jump table
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.SwitchStringJumpTableEmitter.caseLabels">
            <summary>
            Switch case labels
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.SwitchStringJumpTableEmitter.fallThroughLabel">
            <summary>
            Fall through label for the jump table
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.SwitchStringJumpTableEmitter.EmitStringCompareAndBranch">
            <summary>
            Delegate to emit string compare call and conditional branch based on the compare result.
            </summary>
            <param name="key">Key to compare</param>
            <param name="stringConstant">Case constant to compare the key against</param>
            <param name="targetLabel">Target label to branch to if key = stringConstant</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.SwitchStringJumpTableEmitter.GetStringHashCode">
            <summary>
            Delegate to compute string hash code.
            This piece is language-specific because VB treats "" and null as equal while C# does not.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.SwitchStringJumpTableEmitter.emitStringCondBranchDelegate">
            <summary>
            Delegate to emit string compare call
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.SwitchStringJumpTableEmitter.computeStringHashcodeDelegate">
            <summary>
            Delegate to emit string hash
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.SwitchStringJumpTableEmitter.keyHash">
            <summary>
            Local storing the key hash value, used for emitting hash table based string switch.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.TokenMap`1">
            <summary>
            Handles storage of items referenced via tokens in metadata (strings or Symbols).
            When items are stored they are uniquely "associated" with fake token, which is basically 
            a sequential number.
            IL gen will use these fake tokens during codegen and later, when actual token values are known
            the method bodies will be patched.
            To support thse two scenarios we need two maps - Item-->uint, and uint-->Item.  (the second is really just a list).
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ArrayBuilder`1.ArrayBuilderEnumerator">
            <summary>
            struct enumerator used in foreach.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ArrayBuilder`1.ToImmutable">
            <summary>
            Realizes the array.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ArrayBuilder`1.ToImmutableOrNull">
            <summary>
            Realizes the array.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ArrayBuilder`1.ToDowncastedImmutable``1">
            <summary>
            Realizes the array, downcasting each element to a derived type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ArrayBuilder`1.ToImmutableAndFree">
            <summary>
            Realizes the array and disposes the builder in one operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BitArray.Create(System.Int32)">
            <summary>
            Create BitArray with at least the specified number of bits.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BitArray.AllSet(System.Int32)">
            <summary>
            return a bit array with all bits set from index 0 through bitCount-1
            </summary>
            <param name="capacity"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BitArray.Clone">
            <summary>
            Maky a copy of a bit array.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.BitArray.IsNull">
            <summary>
            Is the given bit array null?
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BitArray.IntersectWith(Microsoft.CodeAnalysis.BitArray)">
            <summary>
            Modify this bit vector by bitwise AND-ing each element with the other bit vector.
            For the purposes of the intersection, any bits beyond the current length will be treated as zeroes.
            Return true if any changes were made to the bits of this bit vector.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BitArray.UnionWith(Microsoft.CodeAnalysis.BitArray)">
            <summary>
            Modify this bit vector by '|'ing each element with the other bit vector.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ByteSequenceComparer.GetHashCode(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Compute the FNV-1a hash code for a sequence of bytes.
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="x">The sequence of bytes</param>
            <returns>The FNV-1a hash code for the input sequence</returns>
            <exception cref="T:System.NullReferenceException">The input sequence was null (IsDefault)</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.CachingDictionary`2">
            <summary>
            The CachingLookup class provides a convenient representation of an ILookup that is based
            upon a potentially slow lookup, and caches lookup results so that subsequent lookups are
            fast. Internally a ConcurrentDictionary is used to cache lookup results. The client provides
            two delegates to perform lookups: One that maps a key to a IEnumerable of values, and one
            that provides all keys.
            
            The client must provide an IEqualityComparer used for comparing keys. Failed lookups are
            cached, but that has the disadvantage that every different failed lookup will consume a
            small amount of extra memory. However, that memory can be reclaimed by forcing a full
            population of the cache.
            
            Thread safe.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.CachingDictionary`2.#ctor(System.Func{`0,System.Collections.Immutable.ImmutableArray{`1}},System.Func{System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.HashSet{`0}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Create a CachingLookup.
            </summary>
            <param name="getElementsOfKey">A function that takes a key, and returns an IEnumerable of values that
            correspond to that key. If no values correspond, the function may either return null or an empty
            IEnumerable.</param>
            <param name="getKeys">A function that returns an IEnumerable of all keys that have associated values.</param>
            <param name="comparer">A IEqualityComparer used to compare keys.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.CachingDictionary`2.Contains(`0)">
            <summary>
            Does this key have one or more associated values?
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.CachingDictionary`2.Item(`0)">
            <summary>
            Get the values associated with a key. 
            </summary>
            <param name="key">Key to look up.</param>
            <returns>All values associated with key. Returns an empty IEnumerable if
            no values are associated. Never returns null.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.CachingDictionary`2.Count">
            <summary>
            Get the number of distinct keys.
            Forces a full population of the cache.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.CachingDictionary`2.Keys">
            <summary>
            Enumerate all the keys.
            Forces a full population of the cache.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.CachingDictionary`2.AddValues(Microsoft.CodeAnalysis.ArrayBuilder{`1})">
            <summary>
            Add the values from all keys to a flat array.
            Forces a full population of the cache.
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.CachingDictionary`2.CreateConcurrentDictionary">
            <summary>
            Create an instance of the concurrent dictionary.
            </summary>
            <returns>The concurrent dictionary</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.CachingDictionary`2.CreateDictionaryForFullyPopulatedMap(System.Int32)">
            <summary>
            Create a dictionary instance suitable for use as the fully populated map.
            </summary>
            <returns>A new, empty dictionary, suitable for use as the fully populated map.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.CachingDictionary`2.GetOrCreateValue(`0)">
            <summary>
            Use the underlying (possibly slow) functions to get the values associated with a key.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.CachingDictionary`2.AddToConcurrentMap(System.Collections.Concurrent.ConcurrentDictionary{`0,System.Collections.Immutable.ImmutableArray{`1}},`0)">
            <summary>
            Add a new value with the given key to the given concurrent map.
            </summary>
            <param name="map">The concurrent map to augment.</param>
            <param name="key">The key of the new entry.</param>
            <returns>The added entry. If there was a race, and another thread beat this one, then this returns the previously added entry.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.CachingDictionary`2.IsNotFullyPopulatedMap(System.Collections.Generic.IDictionary{`0,System.Collections.Immutable.ImmutableArray{`1}})">
            <summary>
            Determines if the given map is fully populated.
            </summary>
            <param name="existingMap">The map to test.</param>
            <returns>true if the map is fully populated.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.CachingDictionary`2.CreateFullyPopulatedMap(System.Collections.Generic.IDictionary{`0,System.Collections.Immutable.ImmutableArray{`1}})">
            <summary>
            Create the fully populated map from an existing map and the key generator.
            </summary>
            <param name="existingMap">The existing map which may be null or a ConcurrentDictionary.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.CachingDictionary`2.EnsureFullyPopulated">
            <summary>
            Fully populate the underlying dictionary. Once this returns, the dictionary is guaranteed 
            to have every key in it.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2">
            <summary>
            A MultiDictionary that allows only adding, and 
            preserves the order of values added to the dictionary.
            Thread-safe for reading, but not for adding.
            </summary>
            <remarks>
            Always uses the default comparer.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2.dictionary">
            <summary>
            Each value is either a single V or an <see cref="T:Microsoft.CodeAnalysis.ArrayBuilder`1"/>.
            Null when the dictionary is empty.
            Don't access the field directly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2.Add(`0,`1)">
            <summary>
            Add a value to the dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2.AddRange(`0,System.Collections.Immutable.ImmutableArray{`1})">
            <summary>
            Add multiple values to the dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2.GetCountForKey(`0)">
            <summary>
            Get the number of values assocaited with a key.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2.ContainsKey(`0)">
            <summary>
            Returns true if one or more items with given key have been added.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2.Item(`0)">
            <summary>
            Get all values associated with K, in the order they were added.
            Returns empty read-only array if no values were present.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2.Keys">
            <summary>
            Get a collection of all the keys.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.PooledStringBuilder">
            <summary>
            The usage is:
                   var inst = PooledStringBuilder.GetInstance();
                   var sb = inst.builder;
                   ... Do Stuff...
                   ... sb.ToString() ...
                   inst.Free();
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.SmallConcurrentSetOfInts">
            <summary>
            A set of ints that is small, thread-safe and lock free.
            Several assumptions have been made that allow it to be small and fast:
            1. Deletes never happen.
            2. The size is small. In dogfooding experiements, 89% had 4 or fewer elements and
               98% had 8 or fewer elements. The largest size was 17.
            3. As a result of assumption 2, linear look-up is good enough.
            4. One value, in this case int.MinValue, is used as a sentinel and may never appear in the set.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SmallConcurrentSetOfInts.Contains(System.Int32)">
            <summary>
            Determine if the given integer appears in the set.
            </summary>
            <param name="i">The value to look up.</param>
            <returns>true if <paramref name="i"/> appears in the set. false otherwise.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SmallConcurrentSetOfInts.Add(System.Int32)">
            <summary>
            Insert the given value into the set.
            </summary>
            <param name="i">The value to insert</param>
            <returns>true if <paramref name="i"/> was added. false if it was already present.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SmallConcurrentSetOfInts.AddHelper(System.Int32@,System.Int32,System.Boolean@)">
            <summary>
            If the given slot is unoccupied, then try to replace it with a new value.
            </summary>
            <param name="slot">The slot to examine.</param>
            <param name="i">The new value to insert if the slot is unoccupied.</param>
            <param name="added">An out param indicating whether the slot was successfully updated.</param>
            <returns>true if the value in the slot either now contains, or already contained <paramref name="i"/>. false otherwise.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ConsListExtensions">
            <summary>
            Extension methods associated with ConsList.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EnumerableExtensions.AsSingleton``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the only element of specified sequence if it has exactly one, and default(TSource) otherwise.
            Unlike <see cref="M: Enumerable.SingleOrDefault()"/> doesn't throw if there is more than one element in the sequence.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Grouping`2">
            <summary>
            A simple class to implement IGrouping.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IdentifierCollection">
            <summary>
            A dictionary that maps strings to all known spellings of that string. Can be used to
            efficiently store the set of known type names for a module for both VB and C# while also
            answering questions like "do you have a type called Foo" in either a case sensitive or
            insensitive manner.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ImmutableArrayExtensions">
            <summary>
            The collection of extension methods for the <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> type
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutable``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts a sequence to an immutable array.
            </summary>
            <typeparam name="T">Elemental type of the sequence.</typeparam>
            <param name="items">The sequence to convert.</param>
            <returns>An immutable copy of the contents of the sequence.</returns>
            <exception cref="T:System.ArgumentNullException">If items is null (default)</exception>
            <remarks>If the sequence is null, this will throw <see cref="T:System.ArgumentNullException"/></remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts a sequence to an immutable array.
            </summary>
            <typeparam name="T">Elemental type of the sequence.</typeparam>
            <param name="items">The sequence to convert.</param>
            <returns>An immutable copy of the contents of the sequence.</returns>
            <remarks>If the sequence is null, this will return an empty array.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts a sequence to an immutable array.
            </summary>
            <typeparam name="T">Elemental type of the sequence.</typeparam>
            <param name="items">The sequence to convert.</param>
            <returns>An immutable copy of the contents of the sequence.</returns>
            <remarks>If the sequence is null, this will return the default (null) array.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutable``1(``0[])">
            <summary>
            Converts an array to an immutable array. The array must not be null.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">The sequence to convert</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull``1(``0[])">
            <summary>
            Converts a array to an immutable array.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">The sequence to convert</param>
            <returns></returns>
            <remarks>If the sequence is null, this will return the default (null) array.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrEmpty``1(``0[])">
            <summary>
            Converts an array to an immutable array.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">The sequence to convert</param>
            <returns>If the array is null, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.ToImmutable(System.IO.MemoryStream)">
            <summary>
            Reads bytes from specified <see cref="T:System.IO.MemoryStream"/>.
            </summary>
            <param name="stream">The stream.</param>
            <returns>Read-only content of the stream.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``2(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,``1})">
            <summary>
            Maps an immutable array to another immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The array to map</param>
            <param name="map">The mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``3(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,``1,``2},``1)">
            <summary>
            Maps an immutable array to another immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TArg"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The sequence to map</param>
            <param name="map">The mapping delegate</param>
            <param name="arg">The extra input used by mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``3(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.Int32,``1,``2},``1)">
            <summary>
             Maps an immutable array to another immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TArg"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The sequence to map</param>
            <param name="map">The mapping delegate</param>
            <param name="arg">The extra input used by mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.WhereAsArray``1(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.Boolean})">
            <summary>
            Creates a new immutable array based on filtered elements by the predicate. The array must not be null.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array">The array to process</param>
            <param name="predicate">The delegate that defines the conditions of the element to search for.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AddRange``2(System.Collections.Generic.List{``0},System.Collections.Immutable.ImmutableArray{``1})">
            <summary>
            Adds all elements of the immutable array into the list; The list must not be null.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="U"></typeparam>
            <param name="list"></param>
            <param name="items"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.Cast``2(System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Casts the immutable array of a Type to an immutable array of its base type.
            </summary>
            <typeparam name="TDerived"></typeparam>
            <typeparam name="TBase"></typeparam>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SetEquals``1(System.Collections.Immutable.ImmutableArray{``0},System.Collections.Immutable.ImmutableArray{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Determines whether this instance and another immutable array are equal.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array1"></param>
            <param name="array2"></param>
            <param name="comparer">The comparer to determine if the two arrays are equal.</param>
            <returns>True if the two arrays are equal</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.NullToEmpty``1(System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Returns an empty array if the input array is null (defaut)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.Distinct``1(System.Collections.Immutable.ImmutableArray{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Returns an array of distinct elements, preserving the order in the original array.
            If the array has no duplicates, the original array is returned. The original array must not be null.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UnionCollection`1">
            <summary>
            Implements a readonly collection over a set of existing collections. This can be used to
            prevent having to copy items from one collection over to another (thus bloating space).
            
            Note: this is a *collection*, not a *set*.  There is no removal of duplicated elements. This
            allows us to be able to efficiently do operations like CopyTo, Count, etc. in O(c) time
            instead of O(n) (where 'c' is the number of collections and 'n' is the number of elements).
            If you have a few collections with many elements in them, then this is an appropriate
            collection for you.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CandidateReason">
            <summary>
            Indicates the reasons why a candidate (or set of candidate) symbols were not considered
            correct in SemanticInfo. Higher values take precedence over lower values, so if, for
            example, there a symbol with a given name that was inaccessible, and other with the wrong
            arity, only the inaccessible one would be reported in the SemanticInfo.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.None">
            <summary>
            No CandidateSymbols.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.NotATypeOrNamespace">
            <summary>
            Only a type or namespace was valid in the given location, but the candidate symbols was
            of the wrong kind.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.NotAnEvent">
            <summary>
            Only an event was valid in the given location, but the candidate symbols was
            of the wrong kind.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.NotAWithEventsMember">
            <summary>
            The candidate symbol must be a WithEvents member, but it was not. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.NotAnAttributeType">
            <summary>
            Only an attribute type was valid in the given location, but the candidate symbol was
            of the wrong kind.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.WrongArity">
            <summary>
            The candidate symbol takes a different number of type parameters that was required.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.NotCreatable">
            <summary>
            The candidate symbol existed, but was not allowed to be created in a new expression. 
            For example, interfaces, static classes, and unconstrained type parameters.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.NotReferencable">
            <summary>
            The candidate symbol existed, but was not allowed to be referenced. For example, the
            "get_XXX" method used to implement a property named "XXX" may not be directly
            referenced. Similarly, the type "System.Void" can not be directly referenced.
            Also occurs if "this" is used in a context (static method or field initializer)
            where "this" is not available.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.Inaccessible">
            <summary>
            The candidate symbol had an accessibility modifier (private, protected, ...) that made
            it inaccessible.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.NotAValue">
            <summary>
            The candidate symbol was in a place where a value was required, but was not a value
            (e.g., was a a type or namespace).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.NotAVariable">
            <summary>
            The candidate symbol was in a place where a variable (or sometimes, a property) was
            required, but was not allowed there because it isn't a symbol that can be assigned to. 
            For example, the left hand side of an assignment, or a ref or out parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.NotInvocable">
            <summary>
            The candidate symbol was used in a way that an invocable member (method, or variable of
            delegate type) was required, but the candidate symbol was not invocable.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.StaticInstanceMismatch">
            <summary>
            The candidate symbol must be an instance variable, but was used as static, or the
            reverse. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.OverloadResolutionFailure">
            <summary>
            Overload resolution did not choose a method. The candidate symbols are the methods there
            were considered during overload resolution (which may or may not be applicable methods). 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.LateBound">
            <summary>
            Method could not be selected statically.
            The candidate symbols are the methods there were considered during overload resolution 
            (which may or may not be applicable methods). 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.Ambiguous">
            <summary>
            Multiple ambiguous symbols were available with the same name. This can occur if "using"
            statements bring multiple namespaces into scope, and the same type is available in
            multiple. This can also occur if multiple properties of the same name are available in a
            multiple interface inheritance situation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonMemberResolutionKind">
            <summary>
            Indicates why the compiler accepted or rejected the member during overload resolution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonMemberResolutionKind.Applicable">
            <summary>
            The candidate member was accepted.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonMemberResolutionKind.UseSiteError">
            <summary>
            The candidate member was rejected because it is not supported by the language or cannot
            be used given the current set of assembly references.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonMemberResolutionKind.TypeInferenceFailed">
            <summary>
            The candidate member was rejected because type inference failed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonMemberResolutionKind.Worse">
            <summary>
            The candidate member was rejected because it was considered worse that another member.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonMemberResolutionResult`1">
            <summary>
            Represents the results of overload resolution for a single member.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonMemberResolutionResult`1.Member">
            <summary>
            The member considered during overload resolution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonMemberResolutionResult`1.Resolution">
            <summary>
            Indicates why the compiler accepted or rejected the member during overload resolution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonMemberResolutionResult`1.IsValid">
            <summary>
            Returns true if the compiler accepted this member as the sole correct result of overload resolution.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonOverloadResolutionResult`1">
            <summary>
            Summarizes the results of an overload resolution analysis, as described in section 7.5 of
            the language specification. Describes whether overload resolution succeeded, and which
            method was selected if overload resolution succeeded, as well as detailed information about
            each method that was considered. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonOverloadResolutionResult`1.Succeeded">
            <summary>
            True if overload resolution successfully selected a single best method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonOverloadResolutionResult`1.ValidResult">
            <summary>
            If overload resolution successfully selected a single best method, returns information
            about that method. Otherwise returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonOverloadResolutionResult`1.BestResult">
            <summary>
            If there was a method that overload resolution considered better than all others,
            returns information about that method. A method may be returned even if that method was
            not considered a successful overload resolution, as long as it was better that any other
            potential method considered.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonOverloadResolutionResult`1.Results">
            <summary>
            Returns information about each method that was considered during overload resolution,
            and what the results of overload resolution were for that method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Compilation">
            <summary>
            The compilation object is an immutable representation of a single invocation of the
            compiler. Although immutable, a compilation is also on-demand, and will realize and cache
            data as necessary. A compilation can produce a new compilation from existing compilation
            with the application of small deltas. In many cases, it is more efficient than creating a
            new compilation from scratch, as the new compilation can reuse information from the old
            compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.IsCaseSensitive">
            <summary>
            Returns true if this is a case sensitive compilation, false otherwise.  Case sensitivity
            affects compilation features such as name lookup as well as choosing what names to emit
            when there are multiple different choices (for example between a virtual method and an
            override).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.Language">
            <summary>
            Gets the source language ("C#" or "Visual Basic").
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CheckSubmissionOptions(Microsoft.CodeAnalysis.CompilationOptions)">
            <summary>
            Checks options passed to submission compilation constructor.
            Throws an exception if the options are not applicable to submissions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.Clone">
            <summary>
            Creates a new compilation equivalent to this one with different symbol instances.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.WithEventQueue(Microsoft.CodeAnalysis.Diagnostics.AsyncQueue{Microsoft.CodeAnalysis.Diagnostics.CompilationEvent})">
            <summary>
            Returns a new compilation with a given event queue.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetSemanticModel(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Gets a new <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/> for the specified syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CreateErrorTypeSymbol(Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Int32)">
            <summary>
            Returns a new INamedTypeSymbol representing an error type with the given name and arity
            in the given optional container.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.AssemblyName">
            <summary>
            Simple assembly name, or null if not specified.
            </summary>
            <remarks>
            The name is used for determining internals-visible-to relationship with referenced assemblies.
            
            If the compilation represents an assembly the value of <see cref="P:Microsoft.CodeAnalysis.Compilation.AssemblyName"/> is its simple name.
            
            Unless <see cref="P:CompilationOptions.ModuleName"/> specifies otherwise the module name
            written to metadata is <see cref="P:Name"/> with an extension based upon <see cref="P:CompilationOptions.OutputKind"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.WithAssemblyName(System.String)">
            <summary>
            Creates a compilation with the specified assembly name.
            </summary>
            <param name="assemblyName">The new assembly name.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.Options">
            <summary>
            Gets the options the compilation was created with.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.WithOptions(Microsoft.CodeAnalysis.CompilationOptions)">
            <summary>
            Creates a new compilation with the specified compilation options.
            </summary>
            <param name="options">The new options.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.IsSubmission">
            <summary>
            True if the compilation represents an interactive submission.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetSubmissionSlotIndex">
            <summary>
            Gets or allocates a runtime submission slot index for this compilation.
            </summary>
            <returns>Non-negative integer if this is a submission and it or a previous submission contains code, negative integer otherwise.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.SubmissionReturnType">
            <summary>
            The type object that represents the type of submission result the host requested.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.HostObjectType">
            <summary>
            The type of the host object or null if not specified for this compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetSubmissionResultType(System.Boolean@)">
            <summary>
            Returns the type of the submission return value.
            </summary>
            <param name="hasValue">
            True if the submission has a return value, i.e. if the submission
            ends with an expression statement.
            </param>
            <exception cref="T:System.InvalidOperationException">
            The compilation doesn't represent a submission
            (<see cref="P:Microsoft.CodeAnalysis.Compilation.IsSubmission"/> return false).
            </exception>
            <returns>
            Null if the type of the last expression is unknown, 
            <see cref="T:System.Void"/> if the type of the last expression statement is
            void or if the submission is not an expression statement, or
            otherwise the type of the last expression.
            </returns>
            <remarks>
            Note that the return type is <see cref="T:System.Void"/> if the last
            statement is a non-expression statement e.g.,
            <code>System.Console.WriteLine();</code>
            and if the statement is an expression statement of type void e.g,
            <code>System.Console.WriteLine()</code>. However,
            <paramref name="hasValue"/> is false in the former case and true
            in the latter.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.PreviousSubmission">
            <summary>
            The previous submission compilation, or null if either this
            compilation doesn't represent a submission or the submission is the
            first submission in a submission chain.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.WithPreviousSubmission(Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Returns a new compilation with the given compilation set as the
            previous submission.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.SyntaxTrees">
            <summary>
            Gets the syntax trees (parsed from source code) that this compilation was created with.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.AddSyntaxTrees(Microsoft.CodeAnalysis.SyntaxTree[])">
            <summary>
            Creates a new compilation with additional syntax trees.
            </summary>
            <param name="trees">The new syntax trees.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.AddSyntaxTrees(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTree})">
            <summary>
            Creates a new compilation with additional syntax trees.
            </summary>
            <param name="trees">The new syntax trees.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.RemoveSyntaxTrees(Microsoft.CodeAnalysis.SyntaxTree[])">
            <summary>
            Creates a new compilation without the specified syntax trees. Preserves metadata info for use with trees
            added later.
            </summary>
            <param name="trees">The new syntax trees.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.RemoveSyntaxTrees(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTree})">
            <summary>
            Creates a new compilation without the specified syntax trees. Preserves metadata info for use with trees
            added later.
            </summary>
            <param name="trees">The new syntax trees.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.RemoveAllSyntaxTrees">
            <summary>
            Creates a new compilation without any syntax trees. Preserves metadata info for use with
            trees added later.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.ReplaceSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Creates a new compilation with an old syntax tree replaced with a new syntax tree.
            Reuses metadata from old compilation object.
            </summary>
            <param name="newTree">The new tree.</param>
            <param name="oldTree">The old tree.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.ContainsSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Returns true if this compilation contains the specified tree. False otherwise.
            </summary>
            <param name="syntaxTree">A syntax tree.</param>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Compilation.EventQueue">
            <summary>
            The event queue that this compilation was created with.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.ExternalReferences">
            <summary>
            Metadata references passed to the compilation constructor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.DirectiveReferences">
            <summary>
            Unique metadata references specified via #r directive in the source code of this compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.ReferenceDirectives">
            <summary>
            All reference directives used in this compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.ReferenceDirectiveMap">
            <summary>
            Maps values of #r references to resolved metadata references.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.References">
            <summary>
            All metadata references -- references passed to the compilation
            constructor as well as references specified via #r directives.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.ToMetadataReference(System.Collections.Immutable.ImmutableArray{System.String},System.Boolean)">
            <summary>
            Creates a metadata reference for this compilation.
            </summary>
            <param name="aliases">
            Optional aliases that can be used to refer to the compilation root namespace via extern alias directive.
            </param>
            <param name="embedInteropTypes">
            Embed the COM types from the reference so that the compiled
            application no longer requires a primary interop assembly (PIA).
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.WithReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Creates a new compilation with the specified references.
            </summary>
            <param name="newReferences">
            The new references.
            </param>
            <returns>A new compilation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.WithReferences(Microsoft.CodeAnalysis.MetadataReference[])">
            <summary>
            Creates a new compilation with the specified references.
            </summary>
            <param name="newReferences">The new references.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CommonWithReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Creates a new compilation with the specified references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.AddReferences(Microsoft.CodeAnalysis.MetadataReference[])">
            <summary>
            Creates a new compilation with additional metadata references.
            </summary>
            <param name="references">The new references.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.AddReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Creates a new compilation with additional metadata references.
            </summary>
            <param name="references">The new references.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.RemoveReferences(Microsoft.CodeAnalysis.MetadataReference[])">
            <summary>
            Creates a new compilation without the specified metadata references.
            </summary>
            <param name="references">The new references.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.RemoveReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Creates a new compilation without the specified metadata references.
            </summary>
            <param name="references">The new references.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.RemoveAllReferences">
            <summary>
            Creates a new compilation without any metadata references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.ReplaceReference(Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Creates a new compilation with an old metadata reference replaced with a new metadata
            reference.
            </summary>
            <param name="newReference">The new reference.</param>
            <param name="oldReference">The old reference.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetAssemblyOrModuleSymbol(Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.IAssemblySymbol"/> or <see cref="T:Microsoft.CodeAnalysis.IModuleSymbol"/> for a metadata reference used to create this
            compilation.
            </summary>
            <param name="reference">The target reference.</param>
            <returns>
            Assembly or module symbol corresponding to the given reference or null if there is none.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetMetadataReference(Microsoft.CodeAnalysis.IAssemblySymbol)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.MetadataReference"/> that corresponds to the assembly symbol. 
            </summary>
            <param name="assemblySymbol">The target symbol.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.ReferencedAssemblyNames">
            <summary>
            Assembly identities of all assemblies directly referenced by this compilation.
            </summary>
            <remarks>
            Includes identities of references passed in the compilation constructor 
            as well as those specified via directives in source code. 
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.Assembly">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.IAssemblySymbol"/> that represents the assembly being created.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.SourceModule">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.IModuleSymbol"/> for the module being created by compiling all of
            the source code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.GlobalNamespace">
            <summary>
            The root namespace that contains all namespaces and types defined in source code or in 
            referenced metadata, merged into a single namespace hierarchy.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetCompilationNamespace(Microsoft.CodeAnalysis.INamespaceSymbol)">
            <summary>
            Gets the corresponding compilation namespace for the specified module or assembly namespace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetEntryPoint(System.Threading.CancellationToken)">
            <summary>
            Returns the Main method that will serves as the entry point of the assembly, if it is
            executable (and not a script).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetSpecialType(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Get the symbol for the predefined type from the Cor Library referenced by this
            compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.IsSystemTypeReference(Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Returns true if the type is System.Type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.IsAttributeType(Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Returns true if the specified type is equal to or derives from System.Attribute well-known type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.ObjectType">
            <summary>
            The INamedTypeSymbol for the .NET System.Object type, which could have a TypeKind of
            Error if there was no COR Library in this Compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.DynamicType">
            <summary>
            The TypeSymbol for the type 'dynamic' in this Compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.ScriptClass">
            <summary>
            A symbol representing the implicit Script class. This is null if the class is not
            defined in the compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CreateArrayTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol,System.Int32)">
            <summary>
            Returns a new ArrayTypeSymbol representing an array type tied to the base types of the
            COR Library in this Compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CreatePointerTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Returns a new PointerTypeSymbol representing a pointer type tied to a type in this
            Compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetTypeByMetadataName(System.String)">
            <summary>
            Gets the type within the compilation's assembly and all referenced assemblies (other than
            those that can only be referenced via an extern alias) using its canonical CLR metadata name.
            </summary>
            <returns>Null if the type can't be found.</returns>
            <remarks>
            Since VB does not have the concept of extern aliases, it considers all referenced assemblies.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetParseDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets the diagnostics produced during the parsing stage.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetDeclarationDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets the diagnostics produced during symbol declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetMethodBodyDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets the diagnostics produced during the analysis of method bodies and field initializers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets all the diagnostics for the compilation, including syntax, declaration, and
            binding. Does not include any diagnostics that might be produced during emit, see
            <see cref="T:EmitResult"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.FilterAndAppendAndFreeDiagnostics(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.DiagnosticBag@)">
            <param name="accumulator">Bag to which filtered diagnostics will be added.</param>
            <param name="incoming">Diagnostics to be filtered.</param>
            <returns>True if there were no errors or warnings-as-errors.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.FilterDiagnostic(Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            Modifies the incoming diagnostic, for example escalating its severity, or discarding it (returning null).
            </summary>
            <param name="diagnostic"></param>
            <returns>The modified diagnostic, or null</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CreateDefaultWin32Resources(System.Boolean,System.Boolean,System.IO.Stream,System.IO.Stream)">
            <summary>
            Create a stream filled with default win32 resources.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.ConstructModuleSerializationProperties(System.String,System.Guid)">
            <summary>
            Constructs the module serialization properties out of the compilation options of this compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.HasCodeToEmit">
            <summary>
            Return true if the compilation contains any code or types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.Emit(System.IO.Stream,System.String,System.String,System.IO.Stream,System.IO.Stream,System.Threading.CancellationToken,System.IO.Stream,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ResourceDescription})">
            <summary>
            Emit the IL for the compiled source code into the specified stream.
            </summary>
            <param name="executableStream">Stream to which the compilation will be written.</param>
            <param name="outputName">Name of the compilation: file name and extension.  Null to use the existing output name.
            CAUTION: If this is set to a (non-null) value other than the existing compilation output name, then internals-visible-to
            and assembly references may not work as expected.  In particular, things that were visible at bind time, based on the 
            name of the compilation, may not be visible at runtime and vice-versa.
            </param>
            <param name="pdbFilePath">
            The name of the PDB file embedded in the PE image. 
            If not specified, the file name of the source module with an extension changed to "pdb" is used.
            Ignored unless <paramref name="pdbStream"/> is non-null.
            </param>
            <param name="pdbStream">Stream to which the compilation's debug info will be written.  Null to forego PDB generation.</param>
            <param name="xmlDocStream">Stream to which the compilation's XML documentation will be written.  Null to forego XML generation.</param>
            <param name="cancellationToken">To cancel the emit process.</param>
            <param name="win32Resources">Stream from which the compilation's Win32 resources will be read (in RES format).  
            Null to indicate that there are none. The RES format begins with a null resource entry.</param>
            <param name="manifestResources">List of the compilation's managed resources.  Null to indicate that there are none.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.Emit(System.String,System.String,System.String,System.Threading.CancellationToken,System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ResourceDescription})">
            <summary>
            Emit the IL for the compilation into the specified stream.
            </summary>
            <param name="outputPath">Path of the file to which the compilation will be written.</param>
            <param name="pdbPath">Path of the file to which the compilation's debug info will be written.
            Also embedded in the output file.  Null to forego PDB generation.
            </param>
            <param name="xmlDocPath">Path of the file to which the compilation's XML documentation will be written.  Null to forego XML generation.</param>
            <param name="cancellationToken">To cancel the emit process.</param>
            <param name="win32ResourcesPath">Path of the file from which the compilation's Win32 resources will be read (in RES format).  
            Null to indicate that there are none.</param>
            <param name="manifestResources">List of the compilation's managed resources.  Null to indicate that there are none.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.EmitMetadataOnly(System.IO.Stream,System.String,System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Emits the IL for the symbol declarations into the specified stream. Useful for emitting
            information for cross-language modeling of code. This emits what it can even if there
            are errors.
            </summary>
            <param name="metadataStream">Stream to which the compilation's metadata will be written.</param>
            <param name="xmlDocStream">Stream to which the compilation's XML documentation will be written.  Null to forego XML generation.</param>
            <param name="outputName">Name of the compilation: file name and extension.  Null to use the existing output name.
            CAUTION: If this is set to a (non-null) value other than the existing compilation output name, then internals-visible-to
            and assembly references may not work as expected.  In particular, things that were visible at bind time, based on the 
            name of the compilation, may not be visible at runtime and vice-versa.
            </param>
            <param name="cancellationToken">To cancel the emit process.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.EmitDifference(Microsoft.CodeAnalysis.Emit.EmitBaseline,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Emit.SemanticEdit},System.IO.Stream,System.IO.Stream,System.IO.Stream,System.Collections.Generic.ICollection{System.UInt32},System.Threading.CancellationToken)">
            <summary>
            Emit the differences between the compilation and the previous generation
            for Edit and Continue. The differences are expressed as added and changed
            symbols, and are emitted as metadata, IL, and PDB deltas. A representation
            of the current compilation is returned as an EmitBaseline for use in a
            subsequent Edit and Continue.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.Emit(System.IO.Stream,System.String,System.String,System.IO.Stream,System.IO.Stream,System.Threading.CancellationToken,System.IO.Stream,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ResourceDescription},System.Boolean,Microsoft.CodeAnalysis.CodeGen.CompilationTestData)">
            <summary>
            This overload is only intended to be directly called by tests that want to pass <paramref name="testData"/>.
            The map is used for storing a list of methods and their associated IL.
            </summary>
            <returns>True if emit succeeded.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CompareSyntaxTreeOrdering(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            The compiler needs to define an ordering among different partial class in different syntax trees
            in some cases, because emit order for fields in structures, for example, is semantically important.
            This function defines an ordering among syntax trees in this compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CompareSourceLocations(Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.Location)">
            <summary>
            Compare two source locations, using their containing trees, and then by Span.First within a tree. 
            Can be used to get a total ordering on declarations, for example.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.FirstSourceLocation``1(``0,``0)">
            <summary>
            Return the lexically first of two locations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.FirstSourceLocation``1(System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Return the lexically first of multiple locations.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Compilation.retargetingAssemblySymbols">
            <summary>
            The list of RetargetingAssemblySymbol objects created for this Compilation. 
            RetargetingAssemblySymbols are created when some other compilation references this one, 
            but the other references provided are incompatible with it. For example, compilation C1 
            references v1 of Lib.dll and compilation C2 references C1 and v2 of Lib.dll. In this
            case, in context of C2, all types from v1 of Lib.dll leaking through C1 (through method 
            signatures, etc.) must be retargeted to the types from v2 of Lib.dll. This is what 
            RetargetingAssemblySymbol is responsible for. In the example above, modules in C2 do not 
            reference C1.AssemblySymbol, but reference a special RetargetingAssemblySymbol created
            for C1 by ReferenceManager.
             
            WeakReference is used to allow RetargetingAssemblySymbol to be collected when they become unused.
            
            Guarded by <see cref="F:CommonReferenceManager.SymbolCacheAndReferenceManagerStateGuard"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CacheRetargetingAssemblySymbolNoLock(Microsoft.CodeAnalysis.IAssemblySymbol)">
            <summary>
            Adds given retargeting assembly for this compilation into the cache.
            <see cref="F:CommonReferenceManager.SymbolCacheAndReferenceManagerStateGuard"/> must be locked while calling this method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.AddRetargetingAssemblySymbolsNoLock``1(System.Collections.Generic.List{``0})">
            <summary>
            Adds cached retargetting symbols into the given list.
            <see cref="F:CommonReferenceManager.SymbolCacheAndReferenceManagerStateGuard"/> must be locked while calling this method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CompilationOptions">
            <summary>
            Represents compilation options common to C# and VB.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.OutputKind">
            <summary>
            The kind of assembly generated when emitted.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.ModuleName">
            <summary>
            Name of the primary module, or null if a default name should be used.
            </summary>
            <remarks>
            The name usually (but not necessarily) includes an extension, e.g. "MyModule.dll".
            
            If <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.ModuleName"/> is null the actual name written to metadata  
            is derived from the name of the compilation (<see cref="P:Compilation.Name"/>)
            by appending a default extension for <see cref="P:OutputKind"/>.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.SubsystemVersion">
            <summary>
            Subsystem version
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.ScriptClassName">
            <summary>
            The full name of a global implicit class (script class). This class implicitly encapsulates top-level statements, 
            type declarations, and member declarations. Could be a namespace qualified name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.MainTypeName">
            <summary>
            The full name of a type that declares static Main method. Must be a valid non-generic namespace-qualified name.
            Null if any static Main method is a candidate for an entry point.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.CryptoKeyFile">
            <summary>
            The name of the file containing the key with which to sign the output.
            </summary>
            <remarks>
            To sign the output supply either one of <see cref="P:CryptoKeyContainer"/> or <see cref="P:CryptoKeyFile"/>.
            but not both.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.CryptoKeyContainer">
            <summary>
            The CSP container containing the key with which to sign the output.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.DelaySign">
            <summary>
            Turn off strong name signing when you have supplied a key either through
            attributes or  <see cref="P:CryptoKeyContainer"/> or <see cref="P:CryptoKeyFile"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.CheckOverflow">
            <summary>
            Whether bounds checking on integer arithmetic is enforced by default or not.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.FileAlignment">
            <summary>
            Specifies the size of sections in the output file. 
            </summary>
            <remarks>
            Valid values are 0, 512, 1024, 2048, 4096 and 8192.
            If the value is 0 the file alignment is determined based upon the value of <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.Platform"/>.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.BaseAddress">
            <summary>
            Specifies the preferred base address at which to load the output DLL.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.Platform">
            <summary>
            Specifies which version of the common language runtime (CLR) can run the assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.DebugInformationKind">
            <summary>
            Specifies the kind of debug information to be emitted.
            </summary>
            <remarks>
            This value is set based on the "/debug", "/debug+", "/debug-" and "/debug:{full|pdbonly}" command line switches.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.Optimize">
            <summary>
            Specifies whether or not optimizations should be performed on the output IL.
            This is independent of whether or not PDB information is generated.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.GeneralDiagnosticOption">
            <summary>
            Global warning report option
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.WarningLevel">
            <summary>
            Global warning level (from 0 to 4).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.ConcurrentBuild">
            <summary>
            Specifies whether building compilation may use multiple threads.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.MetadataImportOptions">
            <summary>
            Import internal/private members from all references regardless of "internals-visible-to" relationship.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.SpecificDiagnosticOptions">
            <summary>
            Warning report option for each warning.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.MetadataReferenceProvider">
            <summary>
            Translates a resolved assembly reference path to an actual <see cref="T:Microsoft.CodeAnalysis.PortableExecutableReference"/>.
            Null if the compilation can't contain references to metadata other than those explicitly passed to its factory (such as #r directives in sources). 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.MetadataReferenceResolver">
            <summary>
            Resolves paths to metadata references specified in source via #r directives.
            Null if the compilation can't contain references to metadata other than those explicitly passed to its factory (such as #r directives in sources). 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.XmlReferenceResolver">
            <summary>
            Gets the resolver for resolving XML document references for the compilation.
            Null if the compilation is not allowed to contain XML file references, such as XML doc comment include tags and permission sets stored in an XML file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.SourceReferenceResolver">
            <summary>
            Gets the resolver for resolving source document references for the compilation.
            Null if the compilation is not allowed to contain source file references, such as #line pragmas and #load directives.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.StrongNameProvider">
            <summary>
            Provides strong name and signature the source assembly.
            Null if assembly signing is not supported.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.AssemblyIdentityComparer">
            <summary>
            Used to compare assembly identities. May implement unification and portability policies specific to the target platform.
            <see cref="F:Microsoft.CodeAnalysis.AssemblyIdentityComparer.Default"/> if not specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.Features">
            <summary>
            A set of strings designating experimental compiler features that are to be enabled.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CompilationOptions.WithGeneralDiagnosticOption(Microsoft.CodeAnalysis.ReportDiagnostic)">
            <summary>
            Creates a new options instance with the specified general diagnostic option.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CompilationOptions.WithSpecificDiagnosticOptions(System.Collections.Immutable.ImmutableDictionary{System.String,Microsoft.CodeAnalysis.ReportDiagnostic})">
            <summary>
            Creates a new options instance with the specified diagnostic-specific options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CompilationOptions.WithSpecificDiagnosticOptions(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,Microsoft.CodeAnalysis.ReportDiagnostic}})">
            <summary>
            Creates a new options instance with the specified diagnostic-specific options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CompilationOptions.WithOutputKind(Microsoft.CodeAnalysis.OutputKind)">
            <summary>
            Creates a new options instance with the specified output kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CompilationOptions.WithPlatform(Microsoft.CodeAnalysis.Platform)">
            <summary>
            Creates a new options instance with the specified platform.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CompilationOptions.WithOptimizations(System.Boolean)">
            <summary>
            Creates a new options instance with optimizations enabled or disabled.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CompilationOptions.ValidateOptions(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.Diagnostic})">
            <summary>
            Performs validation of options compatibilities and generates diagnostics if needed
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.Errors">
            <summary>
            Errors collection related to an incompatible set of compilation options
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CompilationStage">
            <summary>
            Represents the possible compilation stages for which it is possible to get diagnostics
            (errors).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ControlFlowAnalysis">
            <summary>
            Provides information about statements which transfer control in and out of a region. This
            information is returned from a call to <see cref="M:SemanticModel.AnalyzeControlFlow" />.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ControlFlowAnalysis.EntryPoints">
            <summary>
            An enumerator for the set of statements inside the region what are the
            destination of branches outside the region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ControlFlowAnalysis.ExitPoints">
            <summary>
            An enumerator for the set of statements inside a region that jump to locations outside
            the region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ControlFlowAnalysis.EndPointIsReachable">
            <summary>
            Indicates whether a region completes normally. Return true if and only if the end of the
            last statement in a region is reachable or the region contains no statements.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ControlFlowAnalysis.ReturnStatements">
            <summary>
            An enumerator for the set of return statements found within a region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ControlFlowAnalysis.Succeeded">
            <summary>
            Returns true iff analysis was successful.  Analysis can fail if the region does not properly span a single expression,
            a single statement, or a contiguous series of statements within the enclosing block.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DataFlowAnalysis">
            <summary>
            Provides information about how data flows into and out of a region. This information is
            returned from a call to
            <see cref="M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeRegionDataFlow" />.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DataFlowAnalysis.VariablesDeclared">
            <summary>
            An enumerator for the set of local variables that are declared within a region. Note
            that the region must be bounded by a method's body or a field's initializer, so
            parameter symbols are never included in the result.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DataFlowAnalysis.DataFlowsIn">
            <summary>
            An enumerator for the set of local variables which are assigned a value outside a region
            that may be used inside the region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DataFlowAnalysis.DataFlowsOut">
            <summary>
            An enumerator for the set of local variables which are assigned a value inside a region
            that may be used outside the region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DataFlowAnalysis.AlwaysAssigned">
            <summary>
            An enumerator for the set of local variables for which a value is always assigned inside
            a region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DataFlowAnalysis.ReadInside">
            <summary>
            An enumerator for the set of local variables that are read inside a region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DataFlowAnalysis.WrittenInside">
            <summary>
            An enumerator for the set of local variables that are written inside a region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DataFlowAnalysis.ReadOutside">
            <summary>
            An enumerator for the set of the local variables that are read outside a region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DataFlowAnalysis.WrittenOutside">
            <summary>
            An enumerator for the set of local variables that are written outside a region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DataFlowAnalysis.Captured">
            <summary>
            An enumerator for the set of the local variables that have been referenced in anonymous
            functions within a region and therefore must be moved to a field of a frame class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DataFlowAnalysis.UnsafeAddressTaken">
            <summary>
            A collection of the non-constant local variables and parameters that have had their
            address (or the address of one of their fields) taken.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DataFlowAnalysis.Succeeded">
            <summary>
            Returns true iff analysis was successful.  Analysis can fail if the region does not
            properly span a single expression, a single statement, or a contiguous series of
            statements within the enclosing block.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DebugInformationKind">
            <summary>
            Specifies the kind of debug information to be emitted.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DebugInformationKind.None">
            <summary>
            Emit no debug information.
            </summary>
            <remarks>
            Not specifying "/debug" command line switch or specifying "/debug-" command line switch enforces this setting.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DebugInformationKind.PDBOnly">
            <summary>
            Emit PDB file only.
            </summary>
            <remarks>
            Specifying "/debug:pdbonly" command line switch enforces this setting.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DebugInformationKind.Full">
            <summary>
            Emit full debugging information.
            </summary>
            <remarks>
            Specifying "/debug" or "/debug:full" or "/debug+" command line switch enforces this setting.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EnumBounds.RequiresAmdInstructionSet(Microsoft.CodeAnalysis.Platform)">
            <summary>
            Gets a value indicating whether the options require the AMD instruction set.
            </summary>
            <value>
              <c>true</c> if the options require the AMD instruction set; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Emit.EmitResult">
            <summary>
            The result of the Compilation.Emit method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.EmitResult.Success">
            <summary>
            True if the compilation successfully produced an executable.
            If false then the diagnostics should include at least one error diagnostic
            indicating the cause of the failure.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.EmitResult.Diagnostics">
            <summary>
            A list of all the diagnostics associated with compilations. This include parse errors, declaration errors,
            compilation errors, and emitting errors.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.DeltaPeWriter.GetMethodTokens(System.Collections.Generic.ICollection{System.UInt32})">
            <summary>
            Return tokens for all modified methods.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.DeltaPeWriter.DefinitionIndex`1.AddUpdated(`0)">
            <summary>
            Add an item from a previous generation
            that has been updated in this generation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Emit.EmitBaseline">
            <summary>
            Represents a module from a previous compilation. Used in Edit and Continue
            to emit the differences in a subsequent compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.EmitBaseline.CreateInitialBaseline(Microsoft.CodeAnalysis.ModuleMetadata,Microsoft.CodeAnalysis.Emit.LocalVariableNameProvider)">
            <summary>
            Creates an <see cref="T:Microsoft.CodeAnalysis.Emit.EmitBaseline"/> from the metadata of the module before editing
            and from a function that maps from a method to an array of local names. 
            </summary>
            <param name="module">The metadata of the module before editing.</param>
            <param name="localNames">
            A function that returns the array of local names given a method index from the module metadata.
            </param>
            <returns>An <see cref="T:Microsoft.CodeAnalysis.Emit.EmitBaseline"/> for the module.</returns>
            <remarks>
            Only the initial baseline is created using this method; subsequent baselines are created
            automatically when emitting the differences in subsequent compilations.
            
            When an active method (one for which a frame is allocated on a stack) is updated the values of its local variables need to be preserved.
            The mapping of local variable names to their slots in the frame is not included in the metadata and thus needs to be provided by 
            <paramref name="localNames"/>.
            
            The <see cref="T:Microsoft.CodeAnalysis.Emit.LocalVariableNameProvider"/> is only needed for the initial generation. The mapping for the subsequent generations
            is carried over through <see cref="T:Microsoft.CodeAnalysis.Emit.EmitBaseline"/>. The compiler assigns slots to named local variables (including named temporary variables)
            it the order in which they appear in the source code. This property allows the compiler to reconstruct the local variable mapping 
            for the initial generation. A subsequent generation may add a new variable in between two variables of the previous generation. 
            Since the slots of the previous generation variables need to be preserved the only option is to add these new variables to the end.
            The slot ordering thus no longer matches the syntax ordering. It is therefore necessary to pass <see cref="P:Microsoft.CodeAnalysis.Emit.EmitDifferenceResult.Baseline"/>
            to the next generation (rather than e.g. create new <see cref="T:Microsoft.CodeAnalysis.Emit.EmitBaseline"/>s from scratch based on metadata produced by subsequent compilations).
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.EmitBaseline.OriginalMetadata">
            <summary>
            The original metadata of the module.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.EmitBaseline.Ordinal">
            <summary>
            Metadata generation ordinal. Zero for
            full metadata and non-zero for delta.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.EmitBaseline.EncId">
            <summary>
            Unique Guid for this delta, or default(Guid)
            if full metadata.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.EmitBaseline.LocalsForMethodsAddedOrChanged">
            <summary>
            Map from syntax to local variable for methods added or updated
            since the initial generation, indexed by method row.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.EmitBaseline.LocalNames">
            <summary>
            Local variable names for methods from metadata,
            indexed by method row.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.SymbolChange.None">
            <summary>
            No change to symbol or members.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.SymbolChange.ContainsChanges">
            <summary>
            No change to symbol but may contain changed symbols.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.SymbolChange.Updated">
            <summary>
            Symbol updated.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.SymbolChange.Added">
            <summary>
            Symbol added.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.SymbolChanges.RequiresCompilation(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns true if the symbol or some child symbol has changed and needs to be compiled.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.SymbolChanges.CalculateChanges(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Emit.SemanticEdit})">
            <summary>
            Calculate the set of changes up to top-level types. The result
            will be used as a filter when traversing the module.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.SymbolChanges.GetContainingSymbol(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Return the symbol that contains this symbol as far
            as changes are concerned. For instance, an auto property
            is considered the containing symbol for the backing
            field and the accessor methods. By default, the containing
            symbol is simply Symbol.ContainingSymbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Emit.ErrorType">
            <summary>
            Error type symbols should be replaced with an object of this class 
            in the translation layer for emit.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.ErrorType.name">
            <summary>
            For the name we will use a word "Error" followed by a guid, generated on the spot.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Emit.ErrorType.ErrorAssembly">
            <summary>
            A fake containing assembly for an ErrorType object.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.ErrorType.ErrorAssembly.name">
            <summary>
            For the name we will use a word "Error" followed by a guid, generated on the spot.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Emit.ModulePropertiesForSerialization">
            <summary>
            This class is used to store the module serialization properties for a compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.NoPia.EmbeddedTypesManager`21.CommonEmbeddedMethod.ToString">
            <remarks>
            This is only used for testing.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.NoPia.EmbeddedTypesManager`21.CommonEmbeddedParameter.ToString">
            <remarks>
            This is only used for testing.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.NoPia.EmbeddedTypesManager`21.CommonEmbeddedType.ToString">
            <remarks>
            This is only used for testing.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.NoPia.EmbeddedTypesManager`21.GetEmbeddedTypeForMember(`5,`3,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Returns null if member doesn't belong to an embedded NoPia type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Emit.PEModuleBuilder`12">
            <summary>
            Common base class for C# and VB PE module builder.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.PEModuleBuilder`12.assemblySymbolMapper">
            <summary>
            Used to translate assembly symbols to assembly references in scenarios when the physical assemblies 
            being emitted don't correspond to the assembly symbols 1:1. This happens, for example, in interactive sessions where
            multiple code submissions might be compiled into a single dynamic assembly or into multiple assemblies 
            depending on properties of the code being emitted. If null we map assembly symbol exactly to its assembly name.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Emit.PEModuleBuilder`12.SynthesizedDefinitions">
            <summary>
            Captures the set of synthesized definitions that should be added to a type
            during emit process.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.PEModuleBuilder`12.GetSynthesizedTypes(`7)">
            <summary>
            Returns null if there are no compiler generated types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.PEModuleBuilder`12.GetSynthesizedMethods(`7)">
            <summary>
            Returns null if there are no synthesized methods.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.PEModuleBuilder`12.GetSynthesizedProperties(`7)">
            <summary>
            Returns null if there are no synthesized properties.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.PEModuleBuilder`12.GetSynthesizedFields(`7)">
            <summary>
            Returns null if there are no synthesized fields.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.PEModuleBuilder`12.GetSymbolToLocationMap">
            <summary>
            Builds symbol definition to location map used for emitting token -> location info
            into PDB to be consumed by WinMdExp.exe tool (only applicable for /t:winmdobj)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.SemanticEditKind.None">
            <summary>
            No change.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.SemanticEditKind.Update">
            <summary>
            Node value was updated.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.SemanticEditKind.Insert">
            <summary>
            Node was inserted.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.SemanticEditKind.Delete">
            <summary>
            Node was deleted.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Emit.SemanticEdit">
            <summary>
            Describes a symbol edit between two compilations. 
            For example, an addition of a method, an update of a method, removal of a type, etc.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.SemanticEdit.Kind">
            <summary>
            The type of edit.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.SemanticEdit.OldSymbol">
            <summary>
            The symbol from the earlier compilation,
            or null if the edit represents an addition.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.SemanticEdit.NewSymbol">
            <summary>
            The symbol from the later compilation,
            or null if the edit represents a deletion.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.SemanticEdit.SyntaxMap">
            <summary>
            A map from syntax node in the later compilation to syntax node in the
            previous compilation, or null if the edit is not in the active method.
            </summary>
            <remarks>
            The map does not need to map all syntax nodes in the active method, only those syntax nodes
            that declare a local or generate a temporary with a scope spanning multiple methods (in C#,
            variable declarations, foreach, lock, using, and fixed; in VB, variable declarations, With,
            For Each, SyncLock, and Using).
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.SemanticEdit.PreserveLocalVariables">
            <summary>
            True if the edit is an update of the active method and local values
            should be preserved; false otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.SemanticEdit.#ctor(Microsoft.CodeAnalysis.Emit.SemanticEditKind,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,System.Func{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode},System.Boolean)">
            <summary>
            Initializes an instance of <see cref="T:Microsoft.CodeAnalysis.Emit.SemanticEdit"/>.
            </summary>
            <param name="kind">The type of edit.</param>
            <param name="oldSymbol">The symbol from the earlier compilation,
            or null if the edit represents an addition.</param>
            <param name="newSymbol">The symbol from the later compilation,
            or null if the edit represents a deletion.</param>
            <param name="syntaxMap">A map from syntax node in the later compilation to syntax
            node in the previous compilation, or null if the edit is not in the active method.</param>
            <param name="preserveLocalVariables">True if the edit is an update of the
            active method and local values should be preserved; false otherwise.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModelExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets symbol information about a syntax node.
            </summary>
            <param name="semanticModel"></param>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the semantic info.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModelExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the node in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information
            about an expression that did not actually appear in the source code.
            </summary>
            <param name="semanticModel"></param>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="expression">A syntax node that represents a parsed expression. This syntax
            node need not and typically does not appear in the source code referred to  SemanticModel
            instance.</param>
            <param name="bindingOption">Indicates whether to binding the expression as a full expressions,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <returns>The semantic information for the topmost node of the expression.</returns>
            <remarks>The passed in expression is interpreted as a stand-alone expression, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModelExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets type information about a syntax node.
            </summary>
            <param name="semanticModel"></param>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the semantic info.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModelExtensions.GetAliasInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            If "nameSyntax" resolves to an alias name, return the IAliasSymbol corresponding
            to A. Otherwise return null.
            </summary>
            <param name="semanticModel"></param>
            <param name="nameSyntax">Name to get alias info for.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the alias information.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModelExtensions.GetSpeculativeAliasInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the name in the context of the specified location and sees if it resolves to an
            alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.
            </summary>
            <param name="semanticModel"></param>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="nameSyntax">A syntax node that represents a name. This syntax
            node need not and typically does not appear in the source code referred to by the
            SemanticModel instance.</param>
            <param name="bindingOption">Indicates whether to binding the name as a full expression,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <remarks>The passed in name is interpreted as a stand-alone name, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModelExtensions.GetSpeculativeTypeInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the node in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information
            about an expression that did not actually appear in the source code.
            </summary>
            <param name="semanticModel"></param>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="expression">A syntax node that represents a parsed expression. This syntax
            node need not and typically does not appear in the source code referred to  SemanticModel
            instance.</param>
            <param name="bindingOption">Indicates whether to binding the expression as a full expressions,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <returns>The semantic information for the topmost node of the expression.</returns>
            <remarks>The passed in expression is interpreted as a stand-alone expression, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModelExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets the symbol associated with a declaration syntax node.
            </summary>
            <param name="semanticModel"></param>
            <param name="declaration">A syntax node that is a declaration. This can be any type
            derived from MemberDeclarationSyntax, TypeDeclarationSyntax, EnumDeclarationSyntax,
            NamespaceDeclarationSyntax, ParameterSyntax, TypeParameterSyntax, or the alias part of a
            UsingDirectiveSyntax</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol declared by the node or null if the node is not a declaration.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModelExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Analyze control-flow within a part of a method body. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModelExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Analyze control-flow within a part of a method body. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModelExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Analyze data-flow within a part of a method body. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModelExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Analyze data-flow within a part of a method body. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ParseOptions">
            <summary>
            Represents parse options common to C# and VB.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ParseOptions.Kind">
            <summary>
            Specifies whether to parse as regular code files, script files or interactive code.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ParseOptions.DocumentationMode">
            <summary>
            Gets a value indicating whether the documentation comments are parsed.
            </summary>
            <value><c>true</c> if documentation comments are parsed, <c>false</c> otherwise.</value>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ParseOptions.WithKind(Microsoft.CodeAnalysis.SourceCodeKind)">
            <summary>
            Creates a new options instance with the specified source code kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ParseOptions.WithDocumentationMode(Microsoft.CodeAnalysis.DocumentationMode)">
            <summary>
            Creates a new options instance with the specified documentation mode.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ParseOptions.PreprocessorSymbolNames">
            <summary>
            Names of defined preprocessor symbols.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Platform.AnyCpu">
            <summary>
            AnyCPU (default) compiles the assembly to run on any platform.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Platform.X86">
            <summary>
            x86 compiles the assembly to be run by the 32-bit, x86-compatible common language runtime.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Platform.X64">
            <summary>
            x64 compiles the assembly to be run by the 64-bit common language runtime on a computer that supports the AMD64 or EM64T instruction set.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Platform.Itanium">
            <summary>
            Itanium compiles the assembly to be run by the 64-bit common language runtime on a computer with an Itanium processor.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Platform.AnyCpu32BitPreferred">
            <summary>
            Compiles your assembly to run on any platform. Your application runs in 32-bit mode on systems that support both 64-bit and 32-bit applications.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Platform.Arm">
            <summary>
            Compiles your assembly to run on a computer that has an Advanced RISC Machine (ARM) processor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PreprocessingSymbolInfo.Symbol">
            <summary>
            The symbol that was referred to by the identifier, if any. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PreprocessingSymbolInfo.IsDefined">
            <summary>
            Returns true if this preprocessing symbol is defined at the identifier position.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SemanticModel">
            <summary>
            Allows asking semantic questions about a tree of syntax nodes in a Compilation. Typically,
            an instance is obtained by a call to GetBinding on a Compilation or Compilation.
            </summary>
            <remarks>
            <para>An instance of SemanticModel caches local symbols and semantic information. Thus, it
            is much more efficient to use a single instance of SemanticModel when asking multiple
            questions about a syntax tree, because information from the first question may be reused.
            This also means that holding onto an instance of SemanticModel for a long time may keep a
            significant amount of memory from being garbage collected.
            </para>
            <para>
            When an answer is a named symbol that is reachable by traversing from the root of the symbol
            table, (that is, from an AssemblySymbol of the Compilation), that symbol will be returned
            (i.e. the returned value will be reference-equal to one reachable from the root of the
            symbol table). Symbols representing entities without names (e.g. array-of-int) may or may
            not exhibit reference equality. However, some named symbols (such as local variables) are
            not reachable from the root. These symbols are visible as answers to semantic questions.
            When the same SemanticModel object is used, the answers exhibit reference-equality.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticModel.Language">
            <summary>
            Gets the source language ("C#" or "Visual Basic").
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticModel.Compilation">
            <summary>
            The compilation this model was obtained from.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticModel.CompilationCore">
            <summary>
            The compilation this model was obtained from.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticModel.SyntaxTree">
            <summary>
            The syntax tree this model was obtained from.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticModel.SyntaxTreeCore">
            <summary>
            The syntax tree this model was obtained from.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets symbol information about a syntax node.
            </summary>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the semantic info.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetSymbolInfoCore(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets symbol information about a syntax node.
            </summary>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the semantic info.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetSpeculativeSymbolInfo(System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the node in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information
            about an expression that did not actually appear in the source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="expression">A syntax node that represents a parsed expression. This syntax
            node need not and typically does not appear in the source code referred to  SemanticModel
            instance.</param>
            <param name="bindingOption">Indicates whether to binding the expression as a full expressions,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <returns>The semantic information for the topmost node of the expression.</returns>
            <remarks>The passed in expression is interpreted as a stand-alone expression, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetSpeculativeSymbolInfoCore(System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the node in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information
            about an expression that did not actually appear in the source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="expression">A syntax node that represents a parsed expression. This syntax
            node need not and typically does not appear in the source code referred to  SemanticModel
            instance.</param>
            <param name="bindingOption">Indicates whether to binding the expression as a full expressions,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <returns>The semantic information for the topmost node of the expression.</returns>
            <remarks>The passed in expression is interpreted as a stand-alone expression, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetSpeculativeTypeInfo(System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the node in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information
            about an expression that did not actually appear in the source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="expression">A syntax node that represents a parsed expression. This syntax
            node need not and typically does not appear in the source code referred to  SemanticModel
            instance.</param>
            <param name="bindingOption">Indicates whether to binding the expression as a full expressions,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <returns>The semantic information for the topmost node of the expression.</returns>
            <remarks>The passed in expression is interpreted as a stand-alone expression, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetSpeculativeTypeInfoCore(System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the node in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information
            about an expression that did not actually appear in the source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="expression">A syntax node that represents a parsed expression. This syntax
            node need not and typically does not appear in the source code referred to  SemanticModel
            instance.</param>
            <param name="bindingOption">Indicates whether to binding the expression as a full expressions,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <returns>The semantic information for the topmost node of the expression.</returns>
            <remarks>The passed in expression is interpreted as a stand-alone expression, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetTypeInfo(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets type information about a syntax node.
            </summary>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the semantic info.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetTypeInfoCore(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets type information about a syntax node.
            </summary>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the semantic info.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetAliasInfo(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            If "nameSyntax" resolves to an alias name, return the IAliasSymbol corresponding
            to A. Otherwise return null.
            </summary>
            <param name="nameSyntax">Name to get alias info for.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the alias information.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetAliasInfoCore(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            If "nameSyntax" resolves to an alias name, return the IAliasSymbol corresponding
            to A. Otherwise return null.
            </summary>
            <param name="nameSyntax">Name to get alias info for.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the alias information.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticModel.IsSpeculativeSemanticModel">
            <summary>
            Returns true if this is a speculative semantic model created with any of the TryGetSpeculativeSemanticModel methods.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticModel.OriginalPositionForSpeculation">
            <summary>
            If this is a speculative semantic model, returns the original position at which the speculative model was created.
            Otherwise, returns 0.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticModel.ParentModel">
            <summary>
            If this is a speculative semantic model, then returns its parent semantic model.
            Otherwise, returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticModel.ParentModelCore">
            <summary>
            If this is a speculative semantic model, then returns its parent semantic model.
            Otherwise, returns null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetSpeculativeAliasInfo(System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the name in the context of the specified location and sees if it resolves to an
            alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="nameSyntax">A syntax node that represents a name. This syntax
            node need not and typically does not appear in the source code referred to by the
            SemanticModel instance.</param>
            <param name="bindingOption">Indicates whether to binding the name as a full expression,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <remarks>The passed in name is interpreted as a stand-alone name, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetSpeculativeAliasInfoCore(System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the name in the context of the specified location and sees if it resolves to an
            alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="nameSyntax">A syntax node that represents a name. This syntax
            node need not and typically does not appear in the source code referred to by the
            SemanticModel instance.</param>
            <param name="bindingOption">Indicates whether to binding the name as a full expression,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <remarks>The passed in name is interpreted as a stand-alone name, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetDeclarationDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            Get all of the declaration errors within the syntax tree associated with this
            object. Does not get errors involving incorrect syntax, compiling method bodies or initializers.
            </summary>
            <param name="span">Optional span within the syntax tree for which to get diagnostics.
            If no argument is specified, then diagnostics for the entire tree are returned.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the diagnostics.</param>
            <remarks>The declaration errors for a syntax tree are cached. The first time this method
            is called, all declarations are analyzed for diagnostics. Calling this a second time
            will return the cached diagnostics.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetMethodBodyDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            Get all of the method body and initializer errors within the syntax tree associated with this
            object. Does not get errors involving incorrect syntax or declarations.
            </summary>
            <param name="span">Optional span within the syntax tree for which to get diagnostics.
            If no argument is specified, then diagnostics for the entire tree are returned.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the diagnostics.</param>
            <remarks>The method body errors for a syntax tree are not cached. The first time this method
            is called, all method bodies are analyzed for diagnostics. Calling this a second time
            will repeat this work.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            Get all the errors within the syntax tree associated with this object. Includes errors
            involving compiling method bodies or initializers, in addition to the errors returned by
            GetDeclarationDiagnostics.
            </summary>
            <param name="span">Optional span within the syntax tree for which to get diagnostics.
            If no argument is specified, then diagnostics for the entire tree are returned.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the diagnostics.</param>
            <remarks>
            Because this method must semantically bind all method bodies and initializers to check
            for diagnostics, it may take a significant amount of time. Unlike
            GetDeclarationDiagnostics, diagnostics for method bodies and initializers are not
            cached, any semantic information used to obtain the diagnostics is discarded.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetDeclaredSymbolForNode(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets the symbol associated with a declaration syntax node.
            </summary>
            <param name="declaration">A syntax node that is a declaration. This can be any type
            derived from MemberDeclarationSyntax, TypeDeclarationSyntax, EnumDeclarationSyntax,
            NamespaceDeclarationSyntax, ParameterSyntax, TypeParameterSyntax, or the alias part of a
            UsingDirectiveSyntax</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol declared by the node or null if the node is not a declaration.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetDeclaredSymbolCore(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets the symbol associated with a declaration syntax node.
            </summary>
            <param name="declaration">A syntax node that is a declaration. This can be any type
            derived from MemberDeclarationSyntax, TypeDeclarationSyntax, EnumDeclarationSyntax,
            NamespaceDeclarationSyntax, ParameterSyntax, TypeParameterSyntax, or the alias part of a
            UsingDirectiveSyntax</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol declared by the node or null if the node is not a declaration.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetDeclaredSymbolsForNode(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets the symbol associated with a declaration syntax node. Unlike <see cref="M:Microsoft.CodeAnalysis.SemanticModel.GetDeclaredSymbolForNode(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)"/>,
            this method returns all symbols declared by a given declaration syntax node. Specifically, in the case of field declaration syntax nodes,
            which can declare multiple symbols, this method returns all declared symbols.
            </summary>
            <param name="declaration">A syntax node that is a declaration. This can be any type
            derived from MemberDeclarationSyntax, TypeDeclarationSyntax, EnumDeclarationSyntax,
            NamespaceDeclarationSyntax, ParameterSyntax, TypeParameterSyntax, or the alias part of a
            UsingDirectiveSyntax</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbols declared by the node.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetDeclaredSymbolsCore(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets the symbol associated with a declaration syntax node. Unlike <see cref="M:Microsoft.CodeAnalysis.SemanticModel.GetDeclaredSymbolForNode(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)"/>,
            this method returns all symbols declared by a given declaration syntax node. Specifically, in the case of field declaration syntax nodes,
            which can declare multiple symbols, this method returns all declared symbols.
            </summary>
            <param name="declaration">A syntax node that is a declaration. This can be any type
            derived from MemberDeclarationSyntax, TypeDeclarationSyntax, EnumDeclarationSyntax,
            NamespaceDeclarationSyntax, ParameterSyntax, TypeParameterSyntax, or the alias part of a
            UsingDirectiveSyntax</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbols declared by the node.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.LookupSymbols(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)">
            <summary>
            Gets the available named symbols in the context of the specified location and optional container. Only
            symbols that are accessible and visible from the given location are returned.
            </summary>
            <param name="position">The character position for determining the enclosing declaration scope and
            accessibility.</param>
            <param name="container">The container to search for symbols within. If null then the enclosing declaration
            scope around position is used.</param>
            <param name="name">The name of the symbol to find. If null is specified then symbols
            with any names are returned.</param>
            <param name="includeReducedExtensionMethods">Consider (reduced) extension methods.</param>
            <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>
            <remarks>
            The "position" is used to determine what variables are visible and accessible. Even if "container" is
            specified, the "position" location is significant for determining which members of "containing" are
            accessible. 
            
            Labels are not considered (see <see cref="M:Microsoft.CodeAnalysis.SemanticModel.LookupLabels(System.Int32,System.String)"/>).
            
            Non-reduced extension methods are considered regardless of the value of <paramref name="includeReducedExtensionMethods"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.LookupSymbolsCore(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)">
            <summary>
            Backing implementation of <see cref="M:Microsoft.CodeAnalysis.SemanticModel.LookupSymbols(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.LookupBaseMembers(System.Int32,System.String)">
            <summary>
            Gets the available base type members in the context of the specified location.  Akin to
            calling <see cref="M:Microsoft.CodeAnalysis.SemanticModel.LookupSymbols(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)"/> with the container set to the immediate base type of
            the type in which <paramref name="position"/> occurs.  However, the accessibility rules
            are different: protected members of the base type will be visible.
            
            Consider the following example:
            
              public class Base
              {
                  protected void M() { }
              }
              
              public class Derived : Base
              {
                  void Test(Base b)
                  {
                      b.M(); // Error - cannot access protected member.
                      base.M();
                  }
              }
            
            Protected members of an instance of another type are only accessible if the instance is known
            to be "this" instance (as indicated by the "base" keyword).
            </summary>
            <param name="position">The character position for determining the enclosing declaration scope and
            accessibility.</param>
            <param name="name">The name of the symbol to find. If null is specified then symbols
            with any names are returned.</param>
            <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>
            <remarks>
            The "position" is used to determine what variables are visible and accessible.
            
            Non-reduced extension methods are considered, but reduced extension methods are not.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.LookupBaseMembersCore(System.Int32,System.String)">
            <summary>
            Backing implementation of <see cref="M:Microsoft.CodeAnalysis.SemanticModel.LookupBaseMembers(System.Int32,System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.LookupStaticMembers(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)">
            <summary>
            Gets the available named static member symbols in the context of the specified location and optional container.
            Only members that are accessible and visible from the given location are returned.
            
            Non-reduced extension methods are considered, since they are static methods.
            </summary>
            <param name="position">The character position for determining the enclosing declaration scope and
            accessibility.</param>
            <param name="container">The container to search for symbols within. If null then the enclosing declaration
            scope around position is used.</param>
            <param name="name">The name of the symbol to find. If null is specified then symbols
            with any names are returned.</param>
            <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>
            <remarks>
            The "position" is used to determine what variables are visible and accessible. Even if "container" is
            specified, the "position" location is significant for determining which members of "containing" are
            accessible. 
            
            Essentially the same as filtering instance members out of the results of an analogous <see cref="M:Microsoft.CodeAnalysis.SemanticModel.LookupSymbols(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)"/> call.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.LookupStaticMembersCore(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)">
            <summary>
            Backing implementation of <see cref="M:Microsoft.CodeAnalysis.SemanticModel.LookupStaticMembers(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.LookupNamespacesAndTypes(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)">
            <summary>
            Gets the available named namespace and type symbols in the context of the specified location and optional container.
            Only members that are accessible and visible from the given location are returned.
            </summary>
            <param name="position">The character position for determining the enclosing declaration scope and
            accessibility.</param>
            <param name="container">The container to search for symbols within. If null then the enclosing declaration
            scope around position is used.</param>
            <param name="name">The name of the symbol to find. If null is specified then symbols
            with any names are returned.</param>
            <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>
            <remarks>
            The "position" is used to determine what variables are visible and accessible. Even if "container" is
            specified, the "position" location is significant for determining which members of "containing" are
            accessible. 
            
            Does not return INamespaceOrTypeSymbol, because there could be aliases.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.LookupNamespacesAndTypesCore(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)">
            <summary>
            Backing implementation of <see cref="M:Microsoft.CodeAnalysis.SemanticModel.LookupNamespacesAndTypes(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.LookupLabels(System.Int32,System.String)">
            <summary>
            Gets the available named label symbols in the context of the specified location and optional container.
            Only members that are accessible and visible from the given location are returned.
            </summary>
            <param name="position">The character position for determining the enclosing declaration scope and
            accessibility.</param>
            <param name="name">The name of the symbol to find. If null is specified then symbols
            with any names are returned.</param>
            <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>
            <remarks>
            The "position" is used to determine what variables are visible and accessible. Even if "container" is
            specified, the "position" location is significant for determining which members of "containing" are
            accessible. 
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.LookupLabelsCore(System.Int32,System.String)">
            <summary>
            Backing implementation of <see cref="M:Microsoft.CodeAnalysis.SemanticModel.LookupLabels(System.Int32,System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeControlFlow(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Analyze control-flow within a part of a method body. 
            </summary>
            <param name="firstStatement">The first node to be included within the analysis.</param>
            <param name="lastStatement">The last node to be included within the analysis.</param>
            <returns>An object that can be used to obtain the result of the control flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The span is not with a method
            body.</exception>
            <remarks>
            The first and last nodes must be fully inside the same method body.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeControlFlowCore(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Analyze control-flow within a part of a method body. 
            </summary>
            <param name="firstStatement">The first node to be included within the analysis.</param>
            <param name="lastStatement">The last node to be included within the analysis.</param>
            <returns>An object that can be used to obtain the result of the control flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The span is not with a method
            body.</exception>
            <remarks>
            The first and last nodes must be fully inside the same method body.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeControlFlow(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Analyze control-flow within a part of a method body. 
            </summary>
            <param name="statement">The statement to be analyzed.</param>
            <returns>An object that can be used to obtain the result of the control flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The span is not with a method
            body.</exception>
            <remarks>
            The statement must be fully inside the same method body.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeControlFlowCore(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Analyze control-flow within a part of a method body. 
            </summary>
            <param name="statement">The statement to be analyzed.</param>
            <returns>An object that can be used to obtain the result of the control flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The span is not with a method
            body.</exception>
            <remarks>
            The statement must be fully inside the same method body.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeDataFlow(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Analyze data-flow within a part of a method body. 
            </summary>
            <param name="firstStatement">The first node to be included within the analysis.</param>
            <param name="lastStatement">The last node to be included within the analysis.</param>
            <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The span is not with a method
            body.</exception>
            <remarks>
            The first and last nodes must be fully inside the same method body.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeDataFlowCore(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Analyze data-flow within a part of a method body. 
            </summary>
            <param name="firstStatement">The first node to be included within the analysis.</param>
            <param name="lastStatement">The last node to be included within the analysis.</param>
            <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The span is not with a method
            body.</exception>
            <remarks>
            The first and last nodes must be fully inside the same method body.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeDataFlow(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Analyze data-flow within a part of a method body. 
            </summary>
            <param name="statementOrExpression">The statement or expression to be analyzed.</param>
            <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The statement or expression is not with a method
            body or field or property initializer.</exception>
            <remarks>
            The statement or expression must be fully inside a method body.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeDataFlowCore(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Analyze data-flow within a part of a method body. 
            </summary>
            <param name="statementOrExpression">The statement or expression to be analyzed.</param>
            <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The statement or expression is not with a method
            body or field or property initializer.</exception>
            <remarks>
            The statement or expression must be fully inside a method body.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetConstantValue(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            If the node provided has a constant value an Optional value will be returned with
            HasValue set to true and with Value set to the constant.  If the node does not have an
            constant value, an Optional will be returned with HasValue set to false.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetConstantValueCore(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            If the node provided has a constant value an Optional value will be returned with
            HasValue set to true and with Value set to the constant.  If the node does not have an
            constant value, an Optional will be returned with HasValue set to false.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetMemberGroup(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            When getting information for a symbol that resolves to a method group or property group,
            from which a method is then chosen; the chosen method or property is present in Symbol;
            all methods in the group that was consulted are placed in this property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetMemberGroupCore(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            When getting information for a symbol that resolves to a method group or property group,
            from which a method is then chosen; the chosen method or property is present in Symbol;
            all methods in the group that was consulted are placed in this property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetEnclosingSymbol(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Given a position in the SyntaxTree for this SemanticModel returns the innermost Symbol
            that the position is considered inside of.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetEnclosingSymbolCore(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Given a position in the SyntaxTree for this SemanticModel returns the innermost Symbol
            that the position is considered inside of.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.ResolveOverloads``1(System.Int32,System.Collections.Immutable.ImmutableArray{``0},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ITypeSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Resolves the set of provided arguments against set of provided members to determine the
            appropriate overload. The arguments are bound as if they were at 'position' within this
            semantic model. An CommonOverloadResolutionResult is returned that gives the result of
            the compiler's overload resolution analysis.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel. This position is used when binding the arguments.
            </param>
            <param name="members">The set of members to resolve overloads among.</param>
            <param name="arguments">The list of arguments, in order, to use when resolving the
            overloads. The arguments are interpreted as if they occurred within the declaration
            scope that encloses "position".</param>
            <param name="typeArguments">If present, the type argument provided. If not provided,
            type inference is done.</param>
            <remarks>
            This can be used to resolve constructors, properties as well as methods.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.ResolveOverloadsCore``1(System.Int32,System.Collections.Immutable.ImmutableArray{``0},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ITypeSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Resolves the set of provided arguments against set of provided members to determine the
            appropriate overload. The arguments are bound as if they were at 'position' within this
            semantic model. An CommonOverloadResolutionResult is returned that gives the result of
            the compiler's overload resolution analysis.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel. This position is used when binding the arguments.
            </param>
            <param name="members">The set of members to resolve overloads among.</param>
            <param name="arguments">The list of arguments, in order, to use when resolving the
            overloads. The arguments are interpreted as if they occurred within the declaration
            scope that encloses "position".</param>
            <param name="typeArguments">If present, the type argument provided. If not provided,
            type inference is done.</param>
            <remarks>
            This can be used to resolve constructors, properties as well as methods.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.IsAccessible(System.Int32,Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Determines if the symbol is accessible from the specified location. 
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="symbol">The symbol that we are checking to see if it accessible.</param>
            <returns>
            True if "symbol is accessible, false otherwise.</returns>
            <remarks>
            This method only checks accessibility from the point of view of the accessibility
            modifiers on symbol and its containing types. Even if true is returned, the given symbol
            may not be able to be referenced for other reasons, such as name hiding.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.IsAccessibleCore(System.Int32,Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Determines if the symbol is accessible from the specified location. 
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="symbol">The symbol that we are checking to see if it accessible.</param>
            <returns>
            True if "symbol is accessible, false otherwise.</returns>
            <remarks>
            This method only checks accessibility from the point of view of the accessibility
            modifiers on symbol and its containing types. Even if true is returned, the given symbol
            may not be able to be referenced for other reasons, such as name hiding.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.IsEventUsableAsField(System.Int32,Microsoft.CodeAnalysis.IEventSymbol)">
            <summary>
            Field-like events can be used as fields in types that can access private
            members of the declaring type of the event.
            </summary>
            <remarks>
            Always false for VB events.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.IsEventUsableAsFieldCore(System.Int32,Microsoft.CodeAnalysis.IEventSymbol)">
            <summary>
            Field-like events can be used as fields in types that can access private
            members of the declaring type of the event.
            </summary>
            <remarks>
            Always false for VB events.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetPreprocessingSymbolInfo(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            If <paramref name="nameSyntax"/> is an identifier name syntax node, return the <see cref="T:Microsoft.CodeAnalysis.PreprocessingSymbolInfo"/> corresponding
            to it.
            </summary>
            <param name="nameSyntax">The nameSyntax node to get semantic information for.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetPreprocessingSymbolInfoCore(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            If <paramref name="nameSyntax"/> is an identifier name syntax node, return the <see cref="T:Microsoft.CodeAnalysis.PreprocessingSymbolInfo"/> corresponding
            to it.
            </summary>
            <param name="nameSyntax">The nameSyntax node to get semantic information for.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.DeclarationsInSpanInternal(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Takes a Span and returns a set of declarations that overlap that span in this model's tree.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SourceReferenceResolver">
            <summary>
            Resolves references to source documents specified in the source.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SourceReferenceResolver.NormalizePath(System.String,System.String)">
            <summary>
            Normalizes specified source path with respect to base file path.
            </summary>
            <param name="path">The source path to normalize. May be absolute or relative.</param>
            <param name="baseFilePath">Path of the source file that contains the <paramref name="path"/> (may also be relative), or null if not available.</param>
            <returns>Normalized path, or null if <paramref name="path"/> can't be normalized. The resulting path doesn't need to exist.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SourceReferenceResolver.ResolveReference(System.String,System.String)">
            <summary>
            Resolves specified path with respect to base file path.
            </summary>
            <param name="path">The path to resolve. May be absolute or relative.</param>
            <param name="baseFilePath">Path of the source file that contains the <paramref name="path"/> (may also be relative), or null if not available.</param>
            <returns>Normalized path, or null if the file can't be resolved.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SourceReferenceResolver.OpenRead(System.String)">
            <summary>
            Opens a <see cref="T:System.IO.Stream"/> that allows reading the content of the specified file.
            </summary>
            <param name="resolvedPath">Path returned by <see cref="M:Microsoft.CodeAnalysis.SourceReferenceResolver.ResolveReference(System.String,System.String)"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="resolvedPath"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="resolvedPath"/> is not a valid absolute path.</exception>
            <exception cref="T:System.IO.IOException">Error reading file <paramref name="resolvedPath"/>. See <see cref="P:System.Exception.InnerException"/> for details.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SpeculativeBindingOption">
            <summary>
            Describes the kind of binding to be performed in one of the SemanticModel
            speculative binding methods.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpeculativeBindingOption.BindAsExpression">
            <summary>
            Binds the given expression using the normal expression binding rules
            that would occur during normal binding of expressions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpeculativeBindingOption.BindAsTypeOrNamespace">
            <summary>
            Binds the given expression as a type or namespace only. If this option
            is selected, then the given expression must derive from TypeSyntax.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SubsystemVersion">
            <summary>
            Represents subsystem version, see /subsystemversion command line 
            option for details and valid values.
            
            The following table lists common subsystem versions of Windows.
            
            Windows version             Subsystem version
              - Windows 2000                5.00
              - Windows XP                  5.01
              - Windows Vista               6.00
              - Windows 7                   6.01
              - Windows 8 Release Preview   6.02
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SubsystemVersion.Major">
            <summary>
            Major subsystem version
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SubsystemVersion.Minor">
            <summary>
            Minor subsystem version
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SubsystemVersion.None">
            <summary>
            Subsystem version not specified
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SubsystemVersion.Windows2000">
            <summary>
            Subsystem version: Windows 2000
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SubsystemVersion.WindowsXP">
            <summary>
            Subsystem version: Windows XP 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SubsystemVersion.WindowsVista">
            <summary>
            Subsystem version: Windows Vista
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SubsystemVersion.Windows7">
            <summary>
            Subsystem version: Windows 7
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SubsystemVersion.Windows8">
            <summary>
            Subsystem version: Windows 8
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SubsystemVersion.TryParse(System.String,Microsoft.CodeAnalysis.SubsystemVersion@)">
            <summary>
            Try parse subsystem version in "x.y" format. Note, no spaces are allowed in string representation.
            </summary>
            <param name="str">String to parse</param>
            <param name="version">the value if successfully parsed or None otherwise</param>
            <returns>true if parsed successfully, false otherwise</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SubsystemVersion.Create(System.Int32,System.Int32)">
            <summary>
            Create a new instance of subsystem version with specified major and minor values.
            </summary>
            <param name="major">major subsystem version</param>
            <param name="minor">minor subsystem version</param>
            <returns>subsystem version with provided major and minor</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SubsystemVersion.Default(Microsoft.CodeAnalysis.OutputKind,Microsoft.CodeAnalysis.Platform)">
            <summary>
            Subsystem version default for the specified output kind and platform combination
            </summary>
            <param name="outputKind">Output kind</param>
            <param name="platform">Platform</param>
            <returns>Subsystem version</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SubsystemVersion.IsValid">
            <summary>
            True if the subsystem version has a valid value
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolInfo.Symbol">
            <summary>
            The symbol that was referred to by the syntax node, if any. Returns null if the given
            expression did not bind successfully to a single symbol. If null is returned, it may
            still be that case that we have one or more "best guesses" as to what symbol was
            intended. These best guesses are available via the CandidateSymbols property.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolInfo.CandidateSymbols">
            <summary>
            If the expression did not successfully resolve to a symbol, but there were one or more
            symbols that may have been considered but discarded, this property returns those
            symbols. The reason that the symbols did not successfully resolve to a symbol are
            available in the CandidateReason property. For example, if the symbol was inaccessible,
            ambiguous, or used in the wrong context.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolInfo.CandidateReason">
            <summary>
             If the expression did not successfully resolve to a symbol, but there were one or more
             symbols that may have been considered but discarded, this property describes why those
             symbol or symbols were not considered suitable.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TypeInfo.Type">
            <summary>
            The type of the expression represented by the syntax node. For expressions that do not
            have a type, null is returned. If the type could not be determined due to an error, than
            an IErrorTypeSymbol is returned.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TypeInfo.ConvertedType">
            <summary>
            The type of the expression after it has undergone an implicit conversion. If the type
            did not undergo an implicit conversion, returns the same as Type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.XmlReferenceResolver">
            <summary>
            Resolves references to XML documents specified in source code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.XmlReferenceResolver.ResolveReference(System.String,System.String)">
            <summary>
            Resolves specified XML reference with respect to base file path.
            </summary>
            <param name="path">The reference path to resolve. May be absolute or relative path.</param>
            <param name="baseFilePath">Path of the source file that contains the <paramref name="path"/> (may also be relative), or null if not available.</param>
            <returns>Path to the XML artifact, or null if the file can't be resolved.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.XmlReferenceResolver.OpenRead(System.String)">
            <summary>
            Opens a <see cref="T:System.IO.Stream"/> that allows reading the content of the specified file.
            </summary>
            <param name="resolvedPath">Path returned by <see cref="M:Microsoft.CodeAnalysis.XmlReferenceResolver.ResolveReference(System.String,System.String)"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="resolvedPath"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="resolvedPath"/> is not a valid absolute path.</exception>
            <exception cref="T:System.IO.IOException">Error reading file <paramref name="resolvedPath"/>. See <see cref="P:System.Exception.InnerException"/> for details.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CvtResFile">
            <summary>
            Parses .RES a file into its constituent resource elements.
            Mostly translated from cvtres.cpp.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Win32ResourceConversions.VersionResourceSerializer.PadKeyLen(System.Int32)">
            <summary>
            Assume that 3 WORDs preceded this string and that they began 32-bit aligned.
            Given the string length compute the number of bytes that should be written to end
            the buffer on a 32-bit boundary</summary>
            <param name="cb"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Win32ResourceConversions.VersionResourceSerializer.PadToDword(System.Int32)">
            <summary>
            assuming the length of bytes submitted began on a 32-bit boundary,
            round up this length as necessary so that it ends at a 32-bit boundary.
            </summary>
            <param name="cb"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Win32ResourceConversions.VersionResourceSerializer.KEYSIZE(System.String)">
            <summary>
            compute number of chars needed to end up on a 32-bit boundary assuming that three
            WORDS preceded this string.
            </summary>
            <param name="sz"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver3`1">
            <summary>
            A proposed replacement for AnalyzerDriver that uses a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1"/> to drive its analysis.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver3`1.#ctor(Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzer[],System.Func{Microsoft.CodeAnalysis.SyntaxNode,`0},System.Threading.CancellationToken)">
            <summary>
            Create an analyzer driver.
            </summary>
            <param name="analyzers">The set of analyzers to include in the analysis</param>
            <param name="getKind">A delegate that returns the language-specific kind for a given syntax node</param>
            <param name="cancellationToken">a cancellation token that can be used to abort analysis</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver3`1.CompilationEventQueue">
            <summary>
            The compilation queue to create the compilation with via WithEventQueue.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver3`1.DiagnosticQueue">
            <summary>
            An async queue that is fed the diagnostics as they are computed.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver3`1.DiagnosticsAsync">
            <summary>
            Returns all diagnostics computed by the analyzers since the last time this was invoked.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver3`1.WhenCompleted">
            <summary>
            Return a task that completes when the driver is done producing diagnostics.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver3`1.IsDiagnosticAnalyzerSuppressed(Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzer,Microsoft.CodeAnalysis.CompilationOptions,System.Action{Microsoft.CodeAnalysis.Diagnostic},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Returns true if all the diagnostics that can be produced by this analyzer are suppressed through options.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerImageReference">
            <summary>
            Represents an in-memory analyzer reference image.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference">
            <summary>
            Represents an analyzer assembly reference that contains diagnostic analyzers.
            </summary>
            <remarks>
            Represents a logical location of the analyzer reference, not the content of the reference. 
            The content might change in time. A snapshot is taken when the compiler queries the reference for its analyzers.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference.FullPath">
            <summary>
            Full path describing the location of the analyzer reference, or null if the reference has no location.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference.Display">
            <summary>
            Path or name used in error messages to identity the reference.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference.IsUnresolved">
            <summary>
            Returns true if this reference is an unresolved reference.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.UnresolvedAnalyzerReference">
            <summary>
            Represents an analyzer reference that can't be resolved.
            </summary>
            <remarks>
            For error reporting only, can't be used to reference an analyzer assembly.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.GetDiagnostics(Microsoft.CodeAnalysis.Compilation,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzer},System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Executes the given diagnostic analyzers, <paramref name="analyzers"/>, on the given <paramref name="compilation"/> and returns the generated diagnostics.
            <paramref name="continueOnError"/> says whether the caller would like the exception thrown by the analyzers to be handled or not. If true - Handles ; False - Not handled.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.GetEffectiveDiagnostics(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostic},Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Given a set of compiler or <see cref="T:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzer"/> generated <paramref name="diagnostics"/>, returns the effective diagnostics after applying the below filters:
            1) <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.SpecificDiagnosticOptions"/> specified for the given <paramref name="compilation"/>.
            2) <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.GeneralDiagnosticOption"/> specified for the given <paramref name="compilation"/>.
            3) Diagnostic suppression through applied <see cref="T:System.Diagnostics.CodeAnalysis.SuppressMessageAttribute"/>.
            4) Pragma directives for the given <paramref name="compilation"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.IsDiagnosticAnalyzerSuppressed(Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzer,Microsoft.CodeAnalysis.CompilationOptions,System.Boolean)">
            <summary>
            Returns true if all the diagnostics that can be produced by this analyzer are suppressed through options.
            <paramref name="continueOnError"/> says whether the caller would like the exception thrown by the analyzers to be handled or not. If true - Handles ; False - Not handled.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.IsDiagnosticAnalyzerSuppressed(Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzer,Microsoft.CodeAnalysis.CompilationOptions,System.Action{Microsoft.CodeAnalysis.Diagnostic},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Returns true if all the diagnostics that can be produced by this analyzer are suppressed through options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationEvent.FlushCache">
            <summary>
            Flush any cached data in this <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationEvent"/> to minimize space usage (at the possible expense of time later).
            The principal effect of this is to free cached information on events that have a <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.CompilationEvent.CompilationStarted">
            <summary>
            The first event placed into a compilation's event queue.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.CompilationEvent.CompilationCompleted">
            <summary>
            The last event placed into a compilation's event queue.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.CompilationEvent.SymbolDeclared">
            <summary>
            An event for each declaration in the program (namespace, type, method, field, parameter, etc).
            Note that some symbols may have multiple declarations (namespaces, partial types) and may therefore
            have multiple events.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1">
            <summary>
            A thread-safe, asynchronously dequeuable queue.
            </summary>
            <typeparam name="TElement">The type of values kept by the queue.</typeparam>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.Count">
            <summary>
            The number of unconsumed elements in the queue.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1"/> class.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.Enqueue(`0)">
            <summary>
            Adds an element to the tail of the queue.
            </summary>
            <param name="value">The value to add.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.SetException(System.Exception)">
            <summary>
            Set the queue to an exception state. Once this has been done, every Enqueue
            and Dequeue operation will throw this exception.
            </summary>
            <param name="exception">The exception to be associated with this queue.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.IsCompleted">
            <summary>
            Gets a value indicating whether the queue has completed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.Complete">
            <summary>
            Signals that no further elements will be enqueued.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.WhenCompleted">
            <summary>
            Gets a task that transitions to a completed state when <see cref="M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.Complete"/> is called.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.DequeueAsync">
            <summary>
            Gets a task whose result is the element at the head of the queue. If the queue
            is empty, waits for an element to be enqueued. If <see cref="M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.Complete"/> is called
            before an element becomes available, the returned task is cancelled. If
            <see cref="M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.SetException(System.Exception)"/> is called before an element becomes available, the
            returned task thrown that exception.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerAttribute">
            <summary>
            Place this onto a class to cause it to be considered a diagnostic analyzer when loaded by the command-line compiler.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.ICodeBlockEndedAnalyzer">
            <summary>
            An analyzer that is invoked after running all other analyzers on a method body or field initializer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.ICodeBlockEndedAnalyzer.OnCodeBlockEnded(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SemanticModel,System.Action{Microsoft.CodeAnalysis.Diagnostic},System.Threading.CancellationToken)">
            <summary>
            Invoked after running all other analyzers on a method body or field initializer.
            </summary>
            <param name="codeBlock">The code block of a method or a field initializer</param>
            <param name="ownerSymbol">The method or field</param>
            <param name="semanticModel">A SemanticModel for the compilation unit</param>
            <param name="addDiagnostic">A delegate to be used to emit diagnostics</param>
            <param name="cancellationToken">A token for cancelling the computation</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.ICodeBlockStartedAnalyzer">
            <summary>
            An analyzer that is invoked when the compiler has analyzed a method body or field initializer, and which can return
            an additional analyzer to be used for method body.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.ICodeBlockStartedAnalyzer.OnCodeBlockStarted(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SemanticModel,System.Action{Microsoft.CodeAnalysis.Diagnostic},System.Threading.CancellationToken)">
            <summary>
            Invoked when the compiler has performed semantic analysis on a method body or field
            initializer, and which can return an additional analyzer to be used for the body.
            </summary>
            <param name="codeBlock">The code block of a method or a field initializer</param>
            <param name="ownerSymbol">The method or field</param>
            <param name="semanticModel">A SemanticModel for the compilation unit</param>
            <param name="addDiagnostic">A delegate to be used to emit diagnostics</param>
            <param name="cancellationToken">A token for cancelling the computation</param>
            <returns>An analyzer that will be used for the method body, or null</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.ICompilationEndedAnalyzer">
            <summary>
            An analyzer that is invoked when the compiler's semantic analysis has completed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.ICompilationEndedAnalyzer.OnCompilationEnded(Microsoft.CodeAnalysis.Compilation,System.Action{Microsoft.CodeAnalysis.Diagnostic},System.Threading.CancellationToken)">
            <summary>
            Called when the compiler's semantic analysis has completed.
            </summary>
            <param name="compilation">The compilation</param>
            <param name="addDiagnostic">A delegate to be used to emit diagnostics</param>
            <param name="cancellationToken">A token for cancelling the computation</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.ICompilationStartedAnalyzer">
            <summary>
            An analyzer that is invoked when compilation starts, and which can return an additional analyzer to be used for the compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.ICompilationStartedAnalyzer.OnCompilationStarted(Microsoft.CodeAnalysis.Compilation,System.Action{Microsoft.CodeAnalysis.Diagnostic},System.Threading.CancellationToken)">
            <summary>
            Called at the beginning of the compilation.
            </summary>
            <param name="compilation">The compilation</param>
            <param name="addDiagnostic">A delegate to be used to emit diagnostics</param>
            <param name="cancellationToken">A token for cancelling the computation</param>
            <returns>An analyzer that is used for the compilation, or null.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.ISemanticModelAnalyzer">
            <summary>
            An analyzer that is invoked on each compilation unit. Analyzers that implement this interface
            may report diagnostics based on the syntax and semantics of the compilation unit. For performance,
            you should consider performing analyses inside of method bodies using <see cref="T:Microsoft.CodeAnalysis.Diagnostics.ISyntaxNodeAnalyzer`1"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.ISemanticModelAnalyzer.AnalyzeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Action{Microsoft.CodeAnalysis.Diagnostic},System.Threading.CancellationToken)">
            <summary>
            Called for each compilation unit in the compilation.
            </summary>
            <param name="semanticModel">A SemanticModel for the compilation unit</param>
            <param name="addDiagnostic">A delegate to be used to emit diagnostics</param>
            <param name="cancellationToken">A token for cancelling the computation</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzer">
            <summary>
            The base interface for types that implement program analyzers that are capable of
            producing diagnostics at compile-time.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzer.SupportedDiagnostics">
            <summary>
            Returns a set of descriptors for the diagnostics that this analyzer is capable of producing.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.ISymbolAnalyzer">
            <summary>
            An analyzer that is invoked on each declared symbol in the compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.ISymbolAnalyzer.SymbolKindsOfInterest">
            <summary>
            Returns the set of symbol kinds for which <see cref="M:Microsoft.CodeAnalysis.Diagnostics.ISymbolAnalyzer.AnalyzeSymbol(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Compilation,System.Action{Microsoft.CodeAnalysis.Diagnostic},System.Threading.CancellationToken)"/> should be called.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.ISymbolAnalyzer.AnalyzeSymbol(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Compilation,System.Action{Microsoft.CodeAnalysis.Diagnostic},System.Threading.CancellationToken)">
            <summary>
            Called for each declared symbol in the compilation where the symbol's kind is an element of <see cref="P:Microsoft.CodeAnalysis.Diagnostics.ISymbolAnalyzer.SymbolKindsOfInterest"/>.
            </summary>
            <param name="symbol">The declared symbol</param>
            <param name="compilation">The compilation in which the symbol is declared</param>
            <param name="addDiagnostic">A delegate to be used to emit diagnostics</param>
            <param name="cancellationToken">A token for cancelling the computation</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.ISyntaxNodeAnalyzer`1">
            <summary>
            An analyzer that is invoked on each syntax node whose Kind is among the kinds return from SyntaxKindsOfInterest.
            </summary>
            <typeparam name="TSyntaxKind">either Microsoft.CodeAnalysis.CSharp.SyntaxKind (for C# syntax nodes)
            or Microsoft.CodeAnalysis.VisualBasic.SyntaxKind (for VB syntax nodes)</typeparam>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.ISyntaxNodeAnalyzer`1.SyntaxKindsOfInterest">
            <summary>
            Returns the syntax kinds of syntax nodes for which AnalyzeNode should be called.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.ISyntaxNodeAnalyzer`1.AnalyzeNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SemanticModel,System.Action{Microsoft.CodeAnalysis.Diagnostic},System.Threading.CancellationToken)">
            <summary>
            Called for each whose language-specific kind is an element of SyntaxKindsOfInterest.
            </summary>
            <param name="node">A node of a kind of interest</param>
            <param name="semanticModel">A SemanticModel for the compilation unit</param>
            <param name="addDiagnostic">A delegate to be used to emit diagnostics</param>
            <param name="cancellationToken">A token for cancelling the computation</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.ISyntaxTreeAnalyzer">
            <summary>
            An analyzer that is invoked on each syntax tree in the compilation. Implementations
            should report diagnostics based primarily on the text of the program (implement <see cref="T:Microsoft.CodeAnalysis.Diagnostics.ISemanticModelAnalyzer"/>
            instead if you want to use semantic information).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.ISyntaxTreeAnalyzer.AnalyzeSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree,System.Action{Microsoft.CodeAnalysis.Diagnostic},System.Threading.CancellationToken)">
            <summary>
            Called for each tree in the compilation.
            </summary>
            <param name="tree">A tree of the compilation</param>
            <param name="addDiagnostic">A delegate to be used to emit diagnostics</param>
            <param name="cancellationToken">A token for cancelling the computation</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference">
            <summary>
            Represents analyzers stored in an analyzer assembly file.
            </summary>
            <remarks>
            Analyzer are read from the file, owned by the reference, and doesn't change 
            since the reference is accessed until the reference object is garbage collected.
            During this time the file is open and its content is read-only.
            
            If you need to manage the lifetime of the anayzer reference (and the file stream) explicitly use <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerImageReference"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.GetAnalyzers(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference})">
            <summary>
            Returns the <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> defined in the given <paramref name="analyzerAssemblies"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.AddAnalyzers(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzer}.Builder,System.Collections.Generic.List{Microsoft.CodeAnalysis.DiagnosticInfo},Microsoft.CodeAnalysis.CommonMessageProvider)">
            <summary>
            Adds the <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> defined in this assembly reference
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonMessageProvider">
            <summary>
            Abstracts the ability to classify and load messages for error codes. Allows the error
            infrastructure to be reused between C# and VB.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonMessageProvider.GetSeverity(System.Int32)">
            <summary>
            Given an error code, get the severity (warning or error) of the code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonMessageProvider.LoadMessage(System.Int32,System.Globalization.CultureInfo)">
            <summary>
            Load the message for the given error code. If the message contains
            "fill-in" placeholders, those should be expressed in standard string.Format notation
            and be in the string.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonMessageProvider.CodePrefix">
            <summary>
            Get the text prefix (e.g., "CS" for C#) used on error messages.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonMessageProvider.GetWarningLevel(System.Int32)">
            <summary>
            Get the warning level for warnings (e.g., 1 through 4 for C#). VB does not have warning
            levels and always uses 1. Errors should return 0.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonMessageProvider.ErrorCodeType">
            <summary>
            Type that defines error codes. For testing purposes only.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonMessageProvider.CreateDiagnostic(System.Int32,Microsoft.CodeAnalysis.Location,System.Object[])">
            <summary>
            Create a simple language speicific diagnostic for given error code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonMessageProvider.GetMessagePrefix(System.String,Microsoft.CodeAnalysis.DiagnosticSeverity,System.Boolean,System.Globalization.CultureInfo)">
            <summary>
            Given a message identifier (e.g., CS0219), severity, warning as error and a culture, 
            get the entire prefix (e.g., "error CS0219: Warning as Error:" for C# or "error BC42024:" for VB) used on error messages.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonMessageProvider.GetIdForErrorCode(System.Int32)">
            <summary>
            Given an error code (like 1234) return the identifier (CS1234 or BC1234).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostic">
            <summary>
            Represents a diagnostic, such as a compiler error or a warning, along with the location where it occurred.
            </summary>
            <summary>
            A diagnostic (such as a compiler error or a warning), along with the location where it occurred.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostic.Create(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Location,System.Object[])">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.
            </summary>
            <param name="descriptor">A <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> describing the diagnostic</param>
            <param name="location">An optional primary location of the diagnostic. If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Location"/> will return <see cref="P:Microsoft.CodeAnalysis.Location.None"/>.</param>
            <param name="messageArgs">Arguments to the message of the diagnostic</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.</returns>
            <remarks>
            If severity is <see cref="F:Microsoft.CodeAnalysis.DiagnosticSeverity.Warning"/>, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.WarningLevel"/> will be 1; otherwise 0.
            <see cref="P:Microsoft.CodeAnalysis.Diagnostic.IsWarningAsError"/> will be false.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostic.Create(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Location,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Location},System.Object[])">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.
            </summary>
            <param name="descriptor">A <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> describing the diagnostic</param>
            <param name="location">An optional primary location of the diagnostic. If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Location"/> will return <see cref="P:Microsoft.CodeAnalysis.Location.None"/>.</param>
            <param name="additionalLocations">
            An optional set of additional locations related to the diagnostic.
            Typically, these are locations of other items referenced in the message.
            If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations"/> will return an empty list.
            </param>
            <param name="messageArgs">Arguments to the message of the diagnostic</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.</returns>
            <remarks>
            If severity is <see cref="F:Microsoft.CodeAnalysis.DiagnosticSeverity.Warning"/>, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.WarningLevel"/> will be 1; otherwise 0.
            <see cref="P:Microsoft.CodeAnalysis.Diagnostic.IsWarningAsError"/> will be false.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostic.Create(System.String,System.String,System.String,Microsoft.CodeAnalysis.DiagnosticSeverity,System.Boolean,System.Int32,System.Boolean,Microsoft.CodeAnalysis.Location,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Location},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.
            </summary>
            <param name="id">An identifier for the diagnostic. For diagnostics generated by the compiler, this will be a numeric code with a prefix such as "CS1001".</param>
            <param name="category">The category of the diagnostic. For diagnostics generated by the compiler, the category will be "Compiler".</param>
            <param name="message">The diagnostic message text.</param>
            <param name="severity">The diagnostic severity.</param>
            <param name="isEnabledByDefault">True if the diagnostic is enabled by default</param>
            <param name="warningLevel">The warning level, between 1 and 4 if severity is <see cref="F:Microsoft.CodeAnalysis.DiagnosticSeverity.Warning"/>; otherwise 0.</param>
            <param name="isWarningAsError">True if the diagnostic is a warning and should be treated as an error; otherwise false.</param>
            <param name="location">An optional primary location of the diagnostic. If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Location"/> will return <see cref="P:Microsoft.CodeAnalysis.Location.None"/>.</param>
            <param name="additionalLocations">
            An optional set of additional locations related to the diagnostic.
            Typically, these are locations of other items referenced in the message.
            If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations"/> will return an empty list.
            </param>
            <param name="customTags">
            An optional set of custom tags for the diagnostic. See <see cref="T:Microsoft.CodeAnalysis.WellKnownDiagnosticTags"/> for some well known tags.
            If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.CustomTags"/> will return an empty list.
            </param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostic.Id">
            <summary>
            Gets the diagnostic identifier. For diagnostics generated by the compiler, this will be a numeric code with a prefix such as "CS1001".
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostic.Category">
            <summary>
            Gets the category of diagnostic. For diagnostics generated by the compiler, the category will be "Compiler".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostic.GetMessage(System.Globalization.CultureInfo)">
            <summary>
            Get the text of the message.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostic.Severity">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.DiagnosticSeverity"/>.
            </summary>
            <remarks>
            To determine if this is a warning treated as an error, use <see cref="P:Microsoft.CodeAnalysis.Diagnostic.IsWarningAsError"/>.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostic.WarningLevel">
            <summary>
            Gets the warning level. This is an integer between 1 and 4 if severity
            is <see cref="F:Microsoft.CodeAnalysis.DiagnosticSeverity.Warning"/>; otherwise 0.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostic.IsEnabledByDefault">
            <summary>
            Returns true if this diagnostic is enabled by default by the author of the diagnostic.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostic.IsWarningAsError">
            <summary>
            Returns true if this is a warning treated as an error; otherwise false.
            </summary>
            <remarks>
            True implies <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Severity"/> = <see cref="F:Microsoft.CodeAnalysis.DiagnosticSeverity.Warning"/>.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostic.Location">
            <summary>
            Gets the primary location of the diagnostic, or <see cref="P:Microsoft.CodeAnalysis.Location.None"/> if no primary location.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations">
            <summary>
            Gets an array of additional locations related to the diagnostic.
            Typically these are the locations of other items referenced in the message.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostic.CustomTags">
            <summary>
            Gets an array of custom tags for the diagnostic.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostic.WithLocation(Microsoft.CodeAnalysis.Location)">
            <summary>
            Create a new instance of this diagnostic with the Location property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostic.WithWarningAsError(System.Boolean)">
            <summary>
            Create a new instance of this diagnostic with the IsWarningAsError property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostic.WithSeverity(Microsoft.CodeAnalysis.DiagnosticSeverity)">
            <summary>
            Create a new instance of this diagnostic with the Severity property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostic.ContainsLocation(Microsoft.CodeAnalysis.SyntaxTree,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan})">
            <summary>
            Returns true if the diagnostic location (or any additional location) is within the given tree and optional filterSpanWithinTree.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TriggerDiagnosticDescriptor">
            <summary>
            Provides a description about a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> that is a trigger for some custom behavior for code analyis clients.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TriggerDiagnosticDescriptor.#ctor(System.String,System.String[])">
            <summary>
            Create a TriggerDiagnosticDescriptor, which provides description about a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> that is a trigger for some custom behavior for code analyis clients.
            </summary>
            <param name="id">A unique identifier for the diagnostic. For example, code analysis diagnostic ID "CA1001".</param>
            <param name="customTags">Optional custom tags for the diagnostic. See <see cref="T:Microsoft.CodeAnalysis.WellKnownDiagnosticTags"/> for some well known tags.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DiagnosticInfo">
            <summary>
            A DiagnosticInfo object has information about a diagnostic, but without any attached location information.
            </summary>
            <remarks>
            More specialized diagnostics with additional information (e.g., ambiguity errors) can derive from this class to
            provide access to additional information about the error, such as what symbols were involved in the ambiguity.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticInfo.Code">
            <summary>
            The error code, as an integer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticInfo.Severity">
            <summary>
            Returns whether this diagnostic is informational, warning, or error.
            For checking if it is a warning treated as an error, use IsWarningsAsError.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticInfo.WarningLevel">
            <summary>
            Returns the warning level for a warning, 1 through 4. Errors have warning level 0.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticInfo.IsWarningAsError">
            <summary>
            Returns true if this is a warning treated as an error.
            </summary>
            <remarks>
            True implies <see cref="P:Microsoft.CodeAnalysis.DiagnosticInfo.Severity"/> = <see cref="F:Microsoft.CodeAnalysis.DiagnosticSeverity.Warning"/>.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticInfo.AdditionalLocations">
            <summary>
            If a derived class has additional information about other referenced symbols, it can
            expose the locations of those symbols in a general way, so they can be reported along
            with the error.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticInfo.MessageIdentifier">
            <summary>
            Get the message id (for example "CS1001") for the message. This includes both the error number
            and a prefix identifying the source.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticInfo.GetMessage(System.Globalization.CultureInfo)">
            <summary>
            Get the text of the message in the given language.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticInfo.GetResolvedInfo">
            <summary>
            For a DiagnosticInfo that is lazily evaluated, this method evaluates it
            and returns a non-lazy DiagnosticInfo.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownDiagnosticTags.Unnecessary">
            <summary>
            Indicates that the diagnostic is related to some unnecessary source code.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownDiagnosticTags.EditAndContinue">
            <summary>
            Indicates that the diagnostic is related to edit and continue.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DiagnosticBag">
            <summary>
            Represents a mutable bag of diagnostics. You can add diagnostics to the bag,
            and also get all the diagnostics out of the bag (the bag implements
            IEnumerable&lt;Diagnostics&gt;. Once added, diagnostics cannot be removed, and no ordering
            is guaranteed.
            
            It is ok to Add diagnostics to the same bag concurrently on multiple threads.
            It is NOT ok to Add concurrently with Clear or Free operations.
            </summary>
            <remarks>The bag is optimized to be efficient when containing zero errors.</remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticBag.IsEmptyWithoutResolution">
            <summary>
            Return true if the bag is completely empty - not even containing void diagnostics.
            </summary>
            <remarks>
            This exists for short-circuiting purposes. Use <see cref="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0})"/>
            to get a resolved Tuple(Of NamedTypeSymbol, ImmutableArray(Of Diagnostic)) (i.e. empty after eliminating void diagnostics).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticBag.HasAnyErrors">
            <summary>
            Returns true if the bag has any diagnostics with Severity=Error. Does not consider warnings or informationals.
            </summary>
            <remarks>
            Resolves any lazy diagnostics in the bag.
            
            Generally, this should only be called by the creator (modulo pooling) of the bag (i.e. don't use bags to communicate -
            if you need more info, pass more info).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticBag.Add(Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            Add a diagnostic to the bag.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticBag.AddRange``1(System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Add multiple diagnostics to the bag.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticBag.AddRange(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostic})">
            <summary>
            Add multiple diagnostics to the bag.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticBag.AddRange(Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Add another DiagnosticBag to the bag.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticBag.AddRangeAndFree(Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Add another DiagnosticBag to the bag and free the argument.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticBag.ToReadOnlyAndFree``1">
            <summary>
            Seal the bag so no further errors can be added, while clearing it and returning the old set of errors.
            Return the bag to the pool.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticBag.AsEnumerable">
            <remarks>
            Generally, this should only be called by the creator (modulo pooling) of the bag (i.e. don't use bags to communicate -
            if you need more info, pass more info).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticBag.AsEnumerableFiltered">
            <remarks>
            Using an iterator to avoid copying the list.  If perf is a problem,
            create an explicit enumerator type.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticBag.Bag">
            <summary>
            Get the underlying concurrent storage, creating it on demand if needed.
            NOTE: Concurrent Adding to the bag is supported, but concurrent Clearing is not.
                  If one thread adds to the bug while another clears it, the scenario is 
                  broken and we cannot do anything about it here.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticBag.Clear">
            NOTE: Concurrent Adding to the bag is supported, but concurrent Clearing is not.
                  If one thread adds to the bug while another clears it, the scenario is 
                  broken and we cannot do anything about it here.
        </member>
        <member name="T:Microsoft.CodeAnalysis.DiagnosticDescriptor">
            <summary>
            Provides a description about a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticDescriptor.Id">
            <summary>
            An unique identifier for the diagnostic.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticDescriptor.Description">
            <summary>
            A short localizable description of the diagnostic.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticDescriptor.MessageFormat">
            <summary>
            A localizable format message string, which can be passed as the first argument to <see cref="M:System.String.Format"/> when creating the diagnostic message with this descriptor.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticDescriptor.Category">
            <summary>
            The category of the diagnostic (like Design, Naming etc.)
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticDescriptor.DefaultSeverity">
            <summary>
            The default severity of the diagnostic.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticDescriptor.IsEnabledByDefault">
            <summary>
            Returns true if the diagnostic is enabled by default.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticDescriptor.CustomTags">
            <summary>
            Custom tags for the diagnostic.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticDescriptor.#ctor(System.String,System.String,System.String,System.String,Microsoft.CodeAnalysis.DiagnosticSeverity,System.Boolean,System.String[])">
            <summary>
            Create a DiagnosticDescriptor, which provides description about a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>.
            </summary>
            <param name="id">A unique identifier for the diagnostic. For example, code analysis diagnostic ID "CA1001".</param>
            <param name="description">A short localizable description of the diagnostic. For example, for CA1001: "Types that own disposable fields should be disposable".</param>
            <param name="messageFormat">A localizable format message string, which can be passed as the first argument to <see cref="M:System.String.Format"/> when creating the diagnostic message with this descriptor.
            For example, for CA1001: "Implement IDisposable on '{0}' because it creates members of the following IDisposable types: '{1}'."</param>
            <param name="category">The category of the diagnostic (like Design, Naming etc.). For example, for CA1001: "Microsoft.Design".</param>
            <param name="defaultSeverity">Default severity of the diagnostic.</param>
            <param name="isEnabledByDefault">True if the diagnostic is enabled by default.</param>
            <param name="customTags">Optional custom tags for the diagnostic. See <see cref="T:Microsoft.CodeAnalysis.WellKnownDiagnosticTags"/> for some well known tags.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DiagnosticFormatter">
            <summary>
            Formats <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> messages.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticFormatter.Format(Microsoft.CodeAnalysis.Diagnostic,System.IFormatProvider)">
            <summary>
            Formats the <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> message using the optional <see cref="T:System.IFormatProvider"/>.
            </summary>
            <param name="diagnostic">The diagnostic.</param>
            <param name="formatter">The formatter; or null to use the default formatter.</param>
            <returns>The formatted message.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DiagnosticSeverity">
            <summary>
            Describes how severe a diagnostic is.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DiagnosticSeverity.Hidden">
            <summary>
            Something that is an issue, as determined by some authority,
            but is not surfaced through normal means.
            There may be different mechanisms that act on these issues.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DiagnosticSeverity.Info">
            <summary>
            Information that does not indicate a problem (i.e. not proscriptive).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DiagnosticSeverity.Warning">
            <summary>
            Something suspicious but allowed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DiagnosticSeverity.Error">
            <summary>
            Something not allowed by the rules of the language or other authority.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.InternalDiagnosticSeverity">
            <summary>
            Values for severity that are used internally by the compiler but are not exposed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InternalDiagnosticSeverity.Unknown">
            <summary>
            An unknown severity diagnostic is something whose severity has not yet been determined.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InternalDiagnosticSeverity.Void">
            <summary>
            If an unknown diagnostic is resolved and found to be unnecessary then it is 
            treated as a "Void" diagnostic
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.InternalErrorCode">
            <summary>
            Values for ErrorCode/ERRID that are used internally by the compiler but are not exposed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InternalErrorCode.Unknown">
            <summary>
            The code has yet to be determined.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InternalErrorCode.Void">
            <summary>
            The code was lazily determined and does not need to be reported.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DiagnosticWithInfo">
            <summary>
            A diagnostic (such as a compiler error or a warning), along with the location where it occurred.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticWithInfo.Info">
            <summary>
            Get the information about the diagnostic: the code, severity, message, etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticWithInfo.HasLazyInfo">
            <summary>
            True if the DiagnosticInfo for this diagnostic requires (or required - this property
            is immutable) resolution.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FileLinePositionSpan">
            <summary>
            Represents a span of text in a source code file in terms of file name, line number, and offset within line.
            However, the file is actually whatever was passed in when asked to parse; there may not really be a file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileLinePositionSpan.Path">
            <summary>
            Path, or null if the span represents an invalid value.
            </summary>
            <remarks>
            Path may be <see cref="F:System.String.Empty"/> if not available.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileLinePositionSpan.HasMappedPath">
            <summary>
            True if the <see cref="P:Microsoft.CodeAnalysis.FileLinePositionSpan.Path"/> is a mapped path.
            </summary>
            <remarks>
            A mapped path is a path specified in source via <code>#line</code> (C#) or <code>#ExternalSource</code> (VB) directives.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileLinePositionSpan.StartLinePosition">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Text.LinePosition"/> of the start of the span.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileLinePositionSpan.EndLinePosition">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Text.LinePosition"/> of the end of the span.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileLinePositionSpan.Span">
            <summary>
            Gets the span.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileLinePositionSpan.#ctor(System.String,Microsoft.CodeAnalysis.Text.LinePosition,Microsoft.CodeAnalysis.Text.LinePosition)">
            <summary>
            Initializes the <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan"/> instance.
            </summary>
            <param name="path">The file identifier - typically a relative or absolute path.</param>
            <param name="start">The start line position.</param>
            <param name="end">The end line position.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileLinePositionSpan.#ctor(System.String,Microsoft.CodeAnalysis.Text.LinePositionSpan)">
            <summary>
            Initializes the <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan"/> instance.
            </summary>
            <param name="path">The file identifier - typically a relative or absolute path.</param>
            <param name="span">The span.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileLinePositionSpan.IsValid">
            <summary>
            Returns true if the span represents a valid location.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileLinePositionSpan.Equals(Microsoft.CodeAnalysis.FileLinePositionSpan)">
            <summary>
            Determines if two FileLinePositionSpan objects are equal.
            </summary>
            <remarks>
            The path is treated as an opaque string, i.e. a case-sensitive comparison is used.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileLinePositionSpan.Equals(System.Object)">
            <summary>
            Determines if two FileLinePositionSpan objects are equal.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileLinePositionSpan.GetHashCode">
            <summary>
            Serves as a hash function for FileLinePositionSpan.
            </summary>
            <returns>The hash code.</returns>
            <remarks>
            The path is treated as an opaque string, i.e. a case-sensitive hash is calculated.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileLinePositionSpan.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents FileLinePositionSpan.
            </summary>
            <returns>The string representation of FileLinePositionSpan.</returns>
            <example>Path: (0,0)-(5,6)</example>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ExternalFileLocation">
            <summary>
            A program location in source code.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IMessageSerializable">
            <summary>
            Indicates that the implementing type can be serialized via <see cref="M:System.Object.ToString"/> 
            for diagnostic message purposes.
            </summary>
            <remarks>
            Not appropriate on types that require localization, since localization should
            happen after serialization.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Location">
            <summary>
            A program location in source code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Location.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serializes the location.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Location.Kind">
            <summary>
            Location kind (None/SourceFile/MetadataFile).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Location.IsInSource">
            <summary>
            Returns true if the location represents a specific location in a source code file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Location.FilePath">
            <summary>
            Returns the path to this location if this is a location from source.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Location.IsInMetadata">
            <summary>
            Returns true if the location is in metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Location.SourceTree">
            <summary>
            The syntax tree this location is located in or null if not in a syntax tree.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Location.MetadataModule">
            <summary>
            Returns the metadata module the location is associated with or null if the module is not available.
            </summary>
            <remarks>
            Might return null even if <see cref="P:Microsoft.CodeAnalysis.Location.IsInMetadata"/> returns true. The module symbol might not be available anymore, 
            for example, if the location is serialized and deserialized.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Location.SourceSpan">
            <summary>
            The location within the syntax tree that this location is associated with.
            </summary>
            <remarks>
            If IsInSource returns False this method returns an empty TextSpan which starts at position 0.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Location.GetLineSpan">
            <summary>
            Gets the location in terms of path, line and column.
            </summary>
            <returns>
            <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan"/> that contains path, line and column information.
            
            Returns an invalid span (see <see cref="P:Microsoft.CodeAnalysis.FileLinePositionSpan.IsValid"/>) if the information is not available.
            
            The values are not affected by line mapping directives (#line in C# or #ExternalSource in VB).
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Location.GetMappedLineSpan">
            <summary>
            Gets the location in terms of path, line and column after applying source line mapping directives
            (<code>#line</code> in C# or <code>#ExternalSource</code> in VB). 
            </summary>
            <returns>
            <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan"/> that contains file, line and column information,
            or an invalid span (see <see cref="P:Microsoft.CodeAnalysis.FileLinePositionSpan.IsValid"/>) if not available.
            </returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Location.None">
            <summary>
            A location of kind LocationKind.None. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Location.Create(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Creates an instance of a Location for 
            </summary>
            <param name="syntaxTree"></param>
            <param name="textSpan"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Location.Create(System.String,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Text.LinePositionSpan)">
            <summary>
            Creates an instance of a Location for 
            </summary>
            <param name="filePath"></param>
            <param name="textSpan"></param>
            <param name="lineSpan"></param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LocationKind">
            <summary>
            Specifies the kind of location (source vs. metadata).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LocationKind.None">
            <summary>
            Unspecified location.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LocationKind.SourceFile">
            <summary>
            The location represents a position in a source file.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LocationKind.MetadataFile">
            <summary>
            The location represents a metadata file.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LocationKind.XmlFile">
            <summary>
            The location represents a position in an XML file.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LocationKind.ExternalFile">
            <summary>
            The location in some external file.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataLocation">
            <summary>
            A program location in metadata.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.NoLocation">
            <summary>
            A class that represents no location at all. Useful for errors in command line options, for example.
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ReportDiagnostic">
            <summary>
            Describes how to report a warning diagnostic.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ReportDiagnostic.Default">
            <summary>
            Report a diagnostic by default.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ReportDiagnostic.Error">
            <summary>
            Report a diagnostic as an error.  
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ReportDiagnostic.Warn">
            <summary>
            Report a diagnostic as a warning even though /warnaserror is specified.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ReportDiagnostic.Info">
            <summary>
            Report a diagnostic as an info.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ReportDiagnostic.Hidden">
            <summary>
            Report a diagnostic as hidden.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ReportDiagnostic.Suppress">
            <summary>
            Suppress a diagnostic.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SourceLocation">
            <summary>
            A program location in source code.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.XmlLocation">
            <summary>
            A program location in an XML file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentationCommentIncludeCache.CacheMissCount">
            <summary>
            WARN: This is a test hook - do not take a dependency on this.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentationCommentIncludeCache.MakeValue(Microsoft.CodeAnalysis.XmlReferenceResolver,System.String)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.Xml.XmlException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DocumentationProvider">
            <summary>
            A class used to provide XML documentation to the compiler for members from metadata. A
            custom implementation of this class should be returned from a DocumentationResolver to provide XML
            documentation comments from custom caches or locations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentationProvider.GetDocumentationForSymbol(System.String,System.Globalization.CultureInfo,System.Threading.CancellationToken)">
            <summary>
            Fetches a documentation comment for the given member ID.
            </summary>
            <param name="documentationMemberID">The documentation member ID of the item to fetch.</param>
            <param name="preferredCulture">The preferred culture to receive a comment in. Null if
            there is no preference. This is a preference only, and providers may choose to provide
            results from another culture if the preferred culture was unavailable.</param>
            <param name="cancellationToken">A cancellation token for the search.</param>
            <returns>A DocumentationComment.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentationProvider.Equals(System.Object)">
            <summary>
            DocumentationProviders are compared when determining whether an AssemblySymbol can be reused.
            Hence, if multiple instances can represent the same documentation, it is imperative that
            Equals (and GetHashCode) be overridden to capture this fact.  Otherwise, it is possible to end
            up with multiple AssemblySymbols for the same assembly, which plays havoc with the type hierarchy.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentationProvider.GetHashCode">
            <summary>
            DocumentationProviders are compared when determining whether an AssemblySymbol can be reused.
            Hence, if multiple instances can represent the same documentation, it is imperative that
            GetHashCode (and Equals) be overridden to capture this fact.  Otherwise, it is possible to end
            up with multiple AssemblySymbols for the same assembly, which plays havoc with the type hierarchy.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DocumentationProvider.NullDocumentationProvider">
            <summary>
            A trivial DocumentationProvider which never returns documentation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.XmlDocumentationCommentTextReader">
            <summary>
            Used by the DocumentationCommentCompiler(s) to check doc comments for XML parse errors.
            As a performance optimization, this class tries to re-use the same underlying XmlTextReader instance
            when possible.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DocumentationMode">
            <summary>
            Specifies the different documentation comment processing modes.
            </summary>
            <remarks>
            Order matters: least processing to most processing.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DocumentationMode.None">
            <summary>
            Treats documentation comments as regular comments.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DocumentationMode.Parse">
            <summary>
            Parses documentation comments as structured trivia, but do not report any diagnostics.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DocumentationMode.Diagnose">
            <summary>
            Parses documentation comments as structured trivia and report diagnostics.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ModuleCompilationState`2.lazyStateMachineTypes">
            <summary>
            Maps an async/iterator method to the synthesized state machine type that implements the method. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EnumConstantHelper.OffsetValue(Microsoft.CodeAnalysis.ConstantValue,System.UInt32,Microsoft.CodeAnalysis.ConstantValue@)">
            <summary>
            Generate a ConstantValue of the same integer type as the argument
            and offset by the given non-negative amount. Return ConstantValue.Bad
            if the generated constant would be outside the valid range of the type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Instrumentation.FunctionId">
            <summary>
            Enum that uniquely identifies every event (pair) that we will be logging.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Instrumentation.Logger">
            <summary>
            Logger class for logging ETW events.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Instrumentation.Logger.Block">
            <summary>
            A logger that logs 'start' and 'end' messages for a supplied event along with a number and a string.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Instrumentation.Logger.Block.#ctor(Microsoft.CodeAnalysis.Instrumentation.FunctionId,System.Int32,System.String,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Returns a logger that logs 'start' and 'end' messages for a supplied event along with a number and a string.
            The combination of the 'start' and the 'end' message is referred to as a 'block' and each block has a unique 'blockId'.
            </summary>
            <param name="functionId">A number that uniquely identifies the event being logged.</param>
            <param name="number">A number that is logged as part of the 'end' message.</param>
            <param name="message">A string that is logged as part of the 'start' message.</param>
            <param name="blockId">A number that uniquely identifies the 'start' and 'end' messages for a particular occurrence of the event in the log.
            In other words, each occurrence of the event will result in 'start' and 'end' messages that share the same unique blockId in the log.</param>
            <param name="cancellationToken">A cancellation token - If the operation was cancelled then a 'cancelled' message is logged in place of a 'end' meessage for the event.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Instrumentation.Logger.LogString(Microsoft.CodeAnalysis.Instrumentation.FunctionId,System.String)">
            <summary>
            Log an event with an optional simple message string.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Instrumentation.Logger.LogString(Microsoft.CodeAnalysis.Instrumentation.FunctionId,System.Func{System.String})">
            <summary>
            Log an event with a message string that will only be created when it is needed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Instrumentation.Logger.LogString``1(Microsoft.CodeAnalysis.Instrumentation.FunctionId,System.Func{``0,System.String},``0)">
            <summary>
            Log an event with a message string that will only be created when it is needed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Instrumentation.Logger.LogString``2(Microsoft.CodeAnalysis.Instrumentation.FunctionId,System.Func{``0,``1,System.String},``0,``1)">
            <summary>
            Log an event with a message string that will only be created when it is needed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Instrumentation.Logger.LogString``3(Microsoft.CodeAnalysis.Instrumentation.FunctionId,System.Func{``0,``1,``2,System.String},``0,``1,``2)">
            <summary>
            Log an event with a message string that will only be created when it is needed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Instrumentation.Logger.LogString``4(Microsoft.CodeAnalysis.Instrumentation.FunctionId,System.Func{``0,``1,``2,``3,System.String},``0,``1,``2,``3)">
            <summary>
            Log an event with a message string that will only be created when it is needed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Instrumentation.Logger.LogBlock(Microsoft.CodeAnalysis.Instrumentation.FunctionId,System.String,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Log an event with a 'start' and an 'end' component containing an optional number and an optional message string.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Instrumentation.Logger.LogBlock(Microsoft.CodeAnalysis.Instrumentation.FunctionId,System.Func{System.String},System.Int32,System.Threading.CancellationToken)">
            <summary>
            Log an event with a 'start' and an 'end' component containing an optional number and a message string that will only be created when it is needed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Instrumentation.Logger.LogBlock``1(Microsoft.CodeAnalysis.Instrumentation.FunctionId,System.Func{``0,System.String},``0,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Log an event with a 'start' and an 'end' component containing an optional number and a message string that will only be created when it is needed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Instrumentation.Logger.LogBlock``2(Microsoft.CodeAnalysis.Instrumentation.FunctionId,System.Func{``0,``1,System.String},``0,``1,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Log an event with a 'start' and an 'end' component containing an optional number and a message string that will only be created when it is needed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Instrumentation.Logger.LogBlock``3(Microsoft.CodeAnalysis.Instrumentation.FunctionId,System.Func{``0,``1,``2,System.String},``0,``1,``2,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Log an event with a 'start' and an 'end' component containing an optional number and a message string that will only be created when it is needed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Instrumentation.Logger.LogBlock``4(Microsoft.CodeAnalysis.Instrumentation.FunctionId,System.Func{``0,``1,``2,``3,System.String},``0,``1,``2,``3,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Log an event with a 'start' and an 'end' component containing an optional number and a message string that will only be created when it is needed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Instrumentation.RoslynCompilerEventSource">
            <summary>
            This EventSource exposes our events to ETW.
            RoslynCompilerEventSource GUID is {9f93daf9-7fee-5301-ebea-643b538889b4}.
            CodeSense.RoslynCompilerEventSource GUID is {08e567fa-f66d-52c7-4e58-d802264cc8db}.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CompilerFatalError.ReportUnlessCanceled(System.Exception)">
            <summary>
            Use in an exception filter to report a fatal error. 
            Unless the exception is <see cref="T:System.OperationCanceledException"/> 
            it calls <see cref="P:Microsoft.CodeAnalysis.CompilerFatalError.Handler"/>. The exception is passed thru (the method returns false).
            </summary>
            <returns>False to avoid catching the exception.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CompilerFatalError.Report(System.Exception)">
            <summary>
            Use in an exception filter to report a fatal error.
            Calls <see cref="P:Microsoft.CodeAnalysis.CompilerFatalError.Handler"/> and passes the exception thru (the method returns false).
            </summary>
            <returns>False to avoid catching the exception.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.InternalUtilities.ConcurrentLruCache`2">
            <summary>
            Cache with a fixed size that evictes the least recently used members.
            Thread-safe.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.InternalUtilities.ConcurrentLruCache`2.#ctor(System.Collections.Generic.KeyValuePair{`0,`1}[])">
            <summary>
            Create cache from an array. The cache capacity will be the size
            of the array. All elements of the array will be added to the 
            cache. If any duplicate keys are found in the array a
            <see cref="T:System.ArgumentException"/> will be thrown.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.InternalUtilities.ConcurrentLruCache`2.TestingEnumerable">
            <summary>
            For testing. Very expensive.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.InternalUtilities.ConcurrentLruCache`2.UnsafeEvictLastNode">
            <summary>
            Expects non-empty cache. Does not lock.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.InternalUtilities.ConcurrentLruCache`2.UnsafeAdd(`0,`1,System.Boolean)">
            <summary>
            Doesn't lock.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.InternalUtilities.ConcurrentLruCache`2.UnsafeTryGetValue(`0,`1@)">
            <summary>
            Doesn't lock.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ThreeState">
            <summary>
            Represent an optional bool as a single byte.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RuntimeMembers.MemberDescriptor">
            <summary>
            Structure that describes a member of a type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RuntimeMembers.MemberDescriptor.DeclaringTypeId">
            <summary>
            Id/token of containing type, usually value from some enum.
            For example from SpecialType enum.
            I am not using SpecialType as the type for this field because
            VB runtime types are not part of SpecialType.
            
            So, the implication is that any type ids we use outside of the SpecialType 
            (either for the VB runtime classes, or types like System.Task etc.) will need 
            to use IDs that are all mutually disjoint. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RuntimeMembers.MemberDescriptor.Signature">
            <summary>
            Signature of the field or method, similar to metadata signature, 
            but with the following exceptions:
               1) Truncated on the left, for methods starts at [ParamCount], for fields at [Type]
               2) Type tokens are not compressed
               3) BOOLEAN | CHAR | I1 | U1 | I2 | U2 | I4 | U4 | I8 | U8 | R4 | R8 | I | U | Void types are encoded by 
                  using VALUETYPE+typeId notation.
               4) array bounds are not included.
               5) modifiers are not included.
               6) (CLASS | VALUETYPE) are omitted after GENERICINST
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RuntimeMembers.SignatureComparer`5">
            <summary>
            Helper class to match signatures in format of 
            MemberDescriptor.Signature to members.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuntimeMembers.SignatureComparer`5.MatchFieldSignature(`1,System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Returns true if signature matches signature of the field.
            Signature should be in format described in MemberDescriptor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuntimeMembers.SignatureComparer`5.MatchPropertySignature(`2,System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Returns true if signature matches signature of the property.
            Signature should be in format described in MemberDescriptor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuntimeMembers.SignatureComparer`5.MatchMethodSignature(`0,System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Returns true if signature matches signature of the method.
            Signature should be in format described in MemberDescriptor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuntimeMembers.SignatureComparer`5.MatchType(`3,System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32@)">
            <summary>
            Does pretty much the same thing as MetadataDecoder.DecodeType only instead of 
            producing a type symbol it compares encoded type to the target.
            
            Signature should be in format described in MemberDescriptor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuntimeMembers.SignatureComparer`5.GetGenericTypeArgument(`3,System.Int32)">
            <summary>
            Should return null in case of error.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuntimeMembers.SignatureComparer`5.GetGenericTypeDefinition(`3)">
            <summary>
            Should return null in case of error.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuntimeMembers.SignatureComparer`5.GetPointedToType(`3)">
            <summary>
            Should only accept Pointer types.
            Should return null in case of error.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuntimeMembers.SignatureComparer`5.GetSZArrayElementType(`3)">
            <summary>
            Should return null in case of error.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuntimeMembers.SignatureComparer`5.MatchArrayRank(`3,System.Int32)">
            <summary>
            Should only accept multi-dimansional arrays.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuntimeMembers.SignatureComparer`5.GetArrayElementType(`3)">
            <summary>
            Should only accept multi-dimansional arrays.
            Should return null in case of error.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeTypeOrThrow(System.Reflection.Metadata.BlobReader@,System.Boolean@)">
            <exception cref="T:Microsoft.CodeAnalysis.UnsupportedSignatureContent">If the encoded type is invalid.</exception>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeTypeOrThrow(System.Reflection.Metadata.BlobReader@,System.Reflection.Metadata.SignatureTypeCode,System.Boolean@)">
            <exception cref="T:Microsoft.CodeAnalysis.UnsupportedSignatureContent">If the encoded type is invalid.</exception>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.ResolveSignatureTypeHandleOrThrow(System.Reflection.Metadata.BlobReader@,System.Boolean@)">
            <exception cref="T:Microsoft.CodeAnalysis.UnsupportedSignatureContent">If the encoded type is invalid.</exception>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.GetTypeByNameOrThrow(Microsoft.CodeAnalysis.MetadataTypeName@,System.Reflection.Metadata.Handle,System.Boolean@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeModifiersOrThrow(System.Reflection.Metadata.BlobReader@,System.Reflection.Metadata.SignatureTypeCode@)">
            <exception cref="T:Microsoft.CodeAnalysis.UnsupportedSignatureContent">If the encoded type is invalid.</exception>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.IsAcceptableModOptModifier(System.Reflection.Metadata.Handle,`0)">
            <summary>
            According to ECMA spec:
             The CMOD_OPT or CMOD_REQD is followed by a metadata token that
             indexes a row in the TypeDef table or the TypeRef table.
            i.e. No modopt in DecodeType (though it still works in DecodeModifier).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeLocalSignatureOrThrow(System.Reflection.Metadata.BlobHandle)">
            <exception cref="T:Microsoft.CodeAnalysis.UnsupportedSignatureContent">If the encoded local variable type is invalid.</exception>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeLocalVariableOrThrow(System.Reflection.Metadata.BlobReader@)">
            <exception cref="T:Microsoft.CodeAnalysis.UnsupportedSignatureContent">If the encoded local variable type is invalid.</exception>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeParameterOrThrow(System.Reflection.Metadata.BlobReader@,Microsoft.CodeAnalysis.MetadataDecoder{`0,`1,`2,`3,`4}.ParamInfo@)">
            <exception cref="T:Microsoft.CodeAnalysis.UnsupportedSignatureContent">If the encoded parameter type is invalid.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.GetSignatureCountsOrThrow(System.Reflection.Metadata.MethodHandle,System.Int32@,System.Int32@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeCustomAttributeParameterTypeOrThrow(System.Reflection.Metadata.BlobReader@,System.Reflection.Metadata.SerializationTypeCode@,`0@,System.Reflection.Metadata.SerializationTypeCode@,`0@,System.Boolean)">
            <summary>
            Decodes attribute parameter type from method signature.
            </summary>
            <exception cref="T:Microsoft.CodeAnalysis.UnsupportedSignatureContent">If the encoded parameter type is invalid.</exception>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeCustomAttributeFieldOrPropTypeOrThrow(System.Reflection.Metadata.BlobReader@,System.Reflection.Metadata.SerializationTypeCode@,`0@,System.Reflection.Metadata.SerializationTypeCode@,`0@,System.Boolean)">
            <summary>
            Decodes attribute argument type from attribute blob (called FieldOrPropType in the spec).
            </summary>
            <exception cref="T:Microsoft.CodeAnalysis.UnsupportedSignatureContent">If the encoded argument type is invalid.</exception>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeCustomAttributeFixedArgumentOrThrow(System.Reflection.Metadata.BlobReader@,System.Reflection.Metadata.BlobReader@)">
            <exception cref="T:Microsoft.CodeAnalysis.UnsupportedSignatureContent">If the encoded attribute argument is invalid.</exception>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeCustomAttributeElementOrThrow(System.Reflection.Metadata.BlobReader@,System.Reflection.Metadata.SerializationTypeCode,`0)">
            <exception cref="T:Microsoft.CodeAnalysis.UnsupportedSignatureContent">If the encoded attribute argument is invalid.</exception>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeCustomAttributeElementArrayOrThrow(System.Reflection.Metadata.BlobReader@,System.Reflection.Metadata.SerializationTypeCode,`0,`0)">
            <exception cref="T:Microsoft.CodeAnalysis.UnsupportedSignatureContent">If the encoded attribute argument is invalid.</exception>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeCustomAttributePrimitiveElementOrThrow(System.Reflection.Metadata.BlobReader@,System.Reflection.Metadata.SerializationTypeCode,`0)">
            <exception cref="T:Microsoft.CodeAnalysis.UnsupportedSignatureContent">If the given <paramref name="typeCode"/> is invalid.</exception>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeCustomAttributeNamedArgumentOrThrow(System.Reflection.Metadata.BlobReader@)">
            <exception cref="T:Microsoft.CodeAnalysis.UnsupportedSignatureContent">If the encoded named argument is invalid.</exception>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeMethodSpecTypeArgumentsOrThrow(System.Reflection.Metadata.BlobHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeSignatureHeaderOrThrow(System.Reflection.Metadata.BlobHandle,System.Byte@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeSignatureParametersOrThrow(System.Reflection.Metadata.BlobReader@,System.Byte,System.Int32@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.GetSignatureCountsOrThrow(System.Reflection.Metadata.BlobReader@,System.Byte,System.Int32@,System.Int32@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.GetExplicitlyOverriddenMethods(System.Reflection.Metadata.TypeHandle,System.Reflection.Metadata.MethodHandle,`0)">
            <summary>
            Find the methods that a given method explicitly overrides.
            </summary>
            <remarks>
            Methods may be on class or interfaces.
            Containing classes/interfaces will be supertypes of the implementing type.
            </remarks>
            <param name="implementingTypeDef">TypeDef handle of the implementing type.</param>
            <param name="implementingMethodDef">MethodDef handle of the implementing method.</param>
            <param name="implementingTypeSymbol">The type symbol for the implementing type.</param>
            <returns>Array of implemented methods.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.FindMethodSymbolInSuperType(System.Reflection.Metadata.TypeHandle,System.Reflection.Metadata.MethodHandle)">
            <summary>
            Search for the MethodSymbol corresponding to the a given MethodDef token.  Search amongst the supertypes
            (classes and interfaces) of a designated type.
            </summary>
            <remarks>
            Generally, the type will be a type that explicitly implements an interface and the method will be the
            implemented method (i.e. on the interface).
            </remarks>
            <param name="searchTypeDef">TypeDef token of the type from which the search should begin.</param>
            <param name="targetMethodDef">MethodDef token of the target method.</param>
            <returns>Corresponding MethodSymbol or null, if none is found.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.EnqueueTypeDefInterfacesAndBaseTypeOrThrow(System.Collections.Generic.Queue{System.Reflection.Metadata.TypeHandle},System.Collections.Generic.Queue{`0},System.Reflection.Metadata.TypeHandle)">
            <summary>
            Enqueue the interfaces implemented and the type extended by a given TypeDef.
            </summary>
            <param name="typeDefsToSearch">Queue of TypeDefs to search.</param>
            <param name="typeSymbolsToSearch">Queue of TypeSymbols (representing typeRefs to search).</param>
            <param name="searchTypeDef">Handle of the TypeDef for which we want to enqueue supertypes.</param>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.EnqueueTypeToken(System.Collections.Generic.Queue{System.Reflection.Metadata.TypeHandle},System.Collections.Generic.Queue{`0},System.Reflection.Metadata.Handle)">
            <summary>
            Helper method for enqueueing a type token in the right queue.
            Def -> typeDefsToSearch
            Ref -> typeSymbolsToSearch
            null -> neither
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.EnqueueTypeSymbolInterfacesAndBaseTypes(System.Collections.Generic.Queue{System.Reflection.Metadata.TypeHandle},System.Collections.Generic.Queue{`0},`0)">
            <summary>
            Enqueue the interfaces implemented and the type extended by a given TypeDef.
            </summary>
            <param name="typeDefsToSearch">Queue of TypeDefs to search.</param>
            <param name="typeSymbolsToSearch">Queue of TypeSymbols (representing typeRefs to search).</param>
            <param name="typeSymbol">Symbol for which we want to enqueue supertypes.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.EnqueueTypeSymbol(System.Collections.Generic.Queue{System.Reflection.Metadata.TypeHandle},System.Collections.Generic.Queue{`0},`0)">
            <summary>
            Enqueue the given type as either a def or a ref.
            </summary>
            <param name="typeDefsToSearch">Queue of TypeDefs to search.</param>
            <param name="typeSymbolsToSearch">Queue of TypeSymbols (representing typeRefs to search).</param>
            <param name="typeSymbol">Symbol to enqueue.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.FindMethodSymbolInType(`0,System.Reflection.Metadata.MethodHandle)">
            <summary>
            Search the members of a TypeSymbol to find the one that matches a given MethodDef token.
            </summary>
            <param name="type">Type to search for method.</param>
            <param name="methodDef">MethodDef handle of the method to find.</param>
            <returns>The corresponding MethodSymbol or null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.FindFieldSymbolInType(`0,System.Reflection.Metadata.FieldHandle)">
            <summary>
            Search the members of a TypeSymbol to find the one that matches a given FieldDef token.
            </summary>
            <param name="type">Type to search for field.</param>
            <param name="fieldDef">FieldDef handle of the field to find.</param>
            <returns>The corresponding FieldSymbol or null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.GetSymbolForMemberRef(System.Reflection.Metadata.MemberReferenceHandle,`0,System.Boolean)">
            <summary>
            Given a MemberRef token for a method, we can find a corresponding MethodSymbol by
            searching for the name and signature.
            </summary>
            <param name="memberRef">A MemberRef token for a method.</param>
            <param name="implementingTypeSymbol">Scope the search to supertypes of the implementing type.</param>
            <param name="methodsOnly">True to only return method symbols, null if the token resolves to a field.</param>
            <returns>The corresponding MethodSymbol or null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.GetMethodHandle(`1)">
            <summary>
            Given a method symbol, return the MethodDef token, if it is defined in
            this module, or a nil token, otherwise.
            </summary>
            <param name="method">The method symbol for which to return a MethodDef token.</param>
            <returns>A MethodDef token or nil.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.LookupTopLevelTypeDefSymbol(Microsoft.CodeAnalysis.MetadataTypeName@,System.Boolean@)">
            <summary>
            Lookup a type defined in this module.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.LookupTopLevelTypeDefSymbol(System.Int32,Microsoft.CodeAnalysis.MetadataTypeName@)">
            <summary>
            Lookup a type defined in referenced assembly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.SubstituteTypeParameters(`0,`0[],System.Boolean[])">
            <summary>
            Produce constructed type symbol.
            </summary>
            <param name="generic">
            Symbol for generic type.
            </param>
            <param name="arguments">
            Generic type arguments, including those for nesting types.
            </param>
            <param name="refersToNoPiaLocalType">
            Flags for arguments. Each item indicates whether corresponding argument refers to NoPia local types.
            </param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.SubstituteWithUnboundIfGeneric(`0)">
            <summary>
            Produce unbound generic type symbol if the type is a generic type.
            </summary>
            <param name="type">
            Symbol for type.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.GetSymbolForILToken(System.Reflection.Metadata.Handle)">
            <summary>
            Returns a symbol that given token resolves to or null of the token represents entity that isn't represented by a symbol,
            such as vararg MemberRef.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.GetMemberRefTypeSymbol(System.Reflection.Metadata.MemberReferenceHandle)">
            <summary>
            Given a MemberRef token, return the TypeSymbol for its Class field.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DoPropertySignaturesMatch(Microsoft.CodeAnalysis.MetadataDecoder{`0,`1,`2,`3,`4}.ParamInfo[],Microsoft.CodeAnalysis.MetadataDecoder{`0,`1,`2,`3,`4}.ParamInfo[],System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Checks whether signatures match where the signatures are either from a property
            and an accessor or two accessors. When comparing a property or getter to setter, the
            setter signature must be the second argument and 'comparingToSetter' must be true.
            </summary>
            <param name="signature1">
            Signature of the property containing the accessor, or the getter (type, then parameters).
            </param>
            <param name="signature2">
            Signature of the accessor when comparing property and accessor,
            or the setter when comparing getter and setter (return type and then parameters).
            </param>
            <param name="comparingToSetter">
            True when comparing a property or getter to a setter, false otherwise.
            </param>
            <param name="compareParamByRef">
            True if differences in IsByRef for parameters should be treated as significant.
            </param>
            <param name="compareReturnType">
            True if differences in return type (or value parameter for setter) should be treated as significant.
            </param>
            <returns>True if the accessor signature is appropriate for the containing property.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DoesSignatureMatchEvent(`0,Microsoft.CodeAnalysis.MetadataDecoder{`0,`1,`2,`3,`4}.ParamInfo[])">
            <summary>
            Check whether an event accessor has an appropriate signature.
            </summary>
            <param name="eventType">Type of the event containing the accessor.</param>
            <param name="methodParams">Signature of the accessor (return type and then parameters).</param>
            <returns>True if the accessor signature is appropriate for the containing event.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataHelpers.SerializedTypeDecoder">
            <summary>
            Decodes a serialized type name in its canonical form. The canonical name is its full type name, followed
            optionally by the assembly where it is defined, its version, culture and public key token.  If the assembly
            name is omitted, the type name is in the current assembly otherwise it is in the referenced assembly. The
            full type name is the fully qualified metadata type name. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataHelpers.SerializedTypeDecoder.DecodeTypeName(System.Boolean,System.Boolean)">
            <summary>
            Decodes a type name.  A type name is a string which is terminated by the end of the string or one of the
            delimiters '+', ',', '[', ']'. '+' separates nested classes. '[' and ']'
            enclosed generic type arguments.  ',' separates types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataHelpers.SerializedTypeDecoder.DecodeGenericName(System.Int32)">
            <summary>
            Decodes a generic name.  This is a type name followed optionally by a type parameter count
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataHelpers.SplitQualifiedNameSystem">
            <summary>
            An ImmutableArray representing the single string "System"
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataHelpers.GetInfoForImmediateNamespaceMembers(System.Int32,System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.Reflection.Metadata.TypeHandle}},System.StringComparer,System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.Reflection.Metadata.TypeHandle}}@,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.Reflection.Metadata.TypeHandle}}}}@)">
            <summary>
            Calculates information about types and namespaces immediately contained within a namespace.
            </summary>
            <param name="namespaceNameLength">
            Length of the fully-qualified name of this namespace.
            </param>
            <param name="typesByNS">
            The sequence of groups of TypeDef row ids for types contained within the namespace, 
            recursively including those from nested namespaces. The row ids must be grouped by the 
            fully-qualified namespace name in case-sensitive manner. 
            Key of each IGrouping is a fully-qualified namespace name, which starts with the name of 
            this namespace. There could be multiple groups for each fully-qualified namespace name.
            
            The groups must be sorted by the keys in a manner consistent with comparer passed in as
            nameComparer. Therefore, all types immediately contained within THIS namespace, if any, 
            must be in several IGrouping at the very beginning of the sequence.
            </param>
            <param name="nameComparer">
            Equality comparer to compare namespace names.
            </param>
            <param name="types">
            Output parameter, never null:
            A sequence of groups of TypeDef row ids for types immediately contained within this namespace.
            </param>
            <param name="namespaces">
            Output parameter, never null:
            A sequence with information about namespaces immediately contained within this namespace.
            For each pair:
              Key - contains simple name of a child namespace.
              Value – contains a sequence similar to the one passed to this function, but
                      calculated for the child namespace. 
            </param>
            <remarks></remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataHelpers.ExtractSimpleNameOfChildNamespace(System.Int32,System.String)">
            <summary>
            Extract a simple name of a top level child namespace from potentially qualified namespace name.
            </summary>
            <param name="parentNamespaceNameLength">
            Parent namespace name length plus the dot.
            </param>
            <param name="fullName">
            Fully qualified namespace name.
            </param>
            <returns>
            Simple name of a top level child namespace, the left-most name following parent namespace name 
            in the fully qualified name.
            </returns>
            <remarks></remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataHelpers.IsValidMetadataIdentifier(System.String)">
            <summary>
            Determines whether given string can be used as a non-empty metadata identifier (a NUL-terminated UTF8 string).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataHelpers.IsValidUnicodeString(System.String)">
            <summary>
            True if the string doesn't contain incomplete surrogates.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataHelpers.SplitNameEqualsFullyQualifiedName(System.String,System.String,System.String)">
            <summary>
            Determine if the given namespace and type names combine to produce the given fully qualified name.
            </summary>
            <param name="namespaceName">The namespace part of the split name.</param>
            <param name="typeName">The type name part of the split name.</param>
            <param name="fullyQualified">The fully qualified name to compare with.</param>
            <returns>true if the combination of <paramref name="namespaceName"/> and <paramref name="typeName"/> equals the fully-qualified name given by <paramref name="fullyQualified"/></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataImportOptions">
            <summary>
            Specifies what symbols to import from metadata.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataImportOptions.Public">
            <summary>
            Only import public and protected symbols.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataImportOptions.Internal">
            <summary>
            Import public, protected and internal symbols.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataImportOptions.All">
            <summary>
            Import all symbols.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataTypeName">
            <summary>
            Helper structure to encapsulate/cache various information about metadata name of a type and 
            name resolution options.
            Also, allows us to stop using strings in the APIs that accept only metadata names, 
            making usage of them less bug prone.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataTypeName.fullName">
            <summary>
            Full metadata name of a type, includes namespace name for top level types.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataTypeName.namespaceName">
            <summary>
            Namespace name for top level types.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataTypeName.typeName">
            <summary>
            Name of the type without namespace prefix, but possibly with generic arity mangling present.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataTypeName.unmangledTypeName">
            <summary>
            Name of the type without namespace prefix and without generic arity mangling.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataTypeName.inferredArity">
            <summary>
            Arity of the type inferred based on the name mangling. It doesn't have to match the actual
            arity of the type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataTypeName.forcedArity">
            <summary>
            While resolving the name, consider only types with this arity.
            (-1) means allow any arity.
            If forcedArity >= 0 and useCLSCompliantNameArityEncoding, lookup may
            fail because forcedArity doesn't match the one encoded in the name.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataTypeName.useCLSCompliantNameArityEncoding">
            <summary>
            While resolving the name, consider only types following 
            CLS-compliant generic type names and arity encoding (ECMA-335, section 10.7.2).
            I.e. arity is inferred from the name and matching type must have the same
            emitted name and arity.
            TODO: PERF: Encode this field elsewhere to save 4 bytes
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataTypeName.namespaceSegments">
            <summary>
            Individual parts of qualified namespace name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataTypeName.FullName">
            <summary>
            Full metadata name of a type, includes namespace name for top level types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataTypeName.NamespaceName">
            <summary>
            Namespace name for top level types, empty string for nested types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataTypeName.TypeName">
            <summary>
            Name of the type without namespace prefix, but possibly with generic arity mangling present.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataTypeName.UnmangledTypeName">
            <summary>
            Name of the type without namespace prefix and without generic arity mangling.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataTypeName.InferredArity">
            <summary>
            Arity of the type inferred based on the name mangling. It doesn't have to match the actual
            arity of the type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataTypeName.IsMangled">
            <summary>
            Does name include arity mangling suffix.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataTypeName.UseCLSCompliantNameArityEncoding">
            <summary>
            While resolving the name, consider only types following 
            CLS-compliant generic type names and arity encoding (ECMA-335, section 10.7.2).
            I.e. arity is inferred from the name and matching type must have the same
            emitted name and arity.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataTypeName.ForcedArity">
            <summary>
            While resolving the name, consider only types with this arity.
            (-1) means allow any arity.
            If ForcedArity >= 0 and UseCLSCompliantNameArityEncoding, lookup may
            fail because ForcedArity doesn't match the one encoded in the name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataTypeName.NamespaceSegments">
            <summary>
            Individual parts of qualified namespace name.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataTypeName.Key">
            <summary>
            A digest of MetadataTypeName's fully qualified name which can be used as the key in a dictionary
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleExtensions.ShouldImportNestedType(Microsoft.CodeAnalysis.PEModule,System.Reflection.Metadata.TypeHandle)">
            <summary>
            Returns true if the nested type should be imported. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleExtensions.ShouldImportField(Microsoft.CodeAnalysis.PEModule,System.Reflection.Metadata.FieldHandle,Microsoft.CodeAnalysis.MetadataImportOptions)">
            <summary>
            Returns true if the field should be imported. Visibility
            and the value of <paramref name="importOptions"/> are considered
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleExtensions.ShouldImportField(System.Reflection.FieldAttributes,Microsoft.CodeAnalysis.MetadataImportOptions)">
            <summary>
            Returns true if the flags represent a field that should be imported.
            Visibility and the value of <paramref name="importOptions"/> are considered
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleExtensions.ShouldImportMethod(Microsoft.CodeAnalysis.PEModule,System.Reflection.Metadata.MethodHandle,Microsoft.CodeAnalysis.MetadataImportOptions)">
            <summary>
            Returns true if the method should be imported. Returns false for private methods that are not
            explicit interface implementations. For other methods, visibility and the value of
            <paramref name="importOptions"/> are considered.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleExtensions.GetVTableGapSize(System.String)">
            <summary>
            Returns 0 if method name doesn't represent a v-table gap.
            Otherwise, returns the gap size.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PEAssembly.AssemblyReferences">
            <summary>
            All assemblies this assembly references.
            </summary>
            <remarks>
            A concatenation of assemblies referenced by each module in the order they are listed in <see cref="F:Microsoft.CodeAnalysis.PEAssembly.modules"/>.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PEAssembly.ModuleReferenceCounts">
            <summary>
            The number of assemblies referenced by each module in <see cref="F:Microsoft.CodeAnalysis.PEAssembly.modules"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PEAssembly.identity">
            <summary>
            Assembly identity read from Assembly table, or null if the table is empty.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PEAssembly.lazyContainsNoPiaLocalTypes">
            <summary>
            Using <see cref="T:Microsoft.CodeAnalysis.ThreeState"/> for atomicity.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEAssembly.#ctor(Microsoft.CodeAnalysis.AssemblyMetadata,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.PEModule})">
            <exception cref="T:System.BadImageFormatException"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PEModule">
            <summary>
            A set of helpers for extracting elements from metadata.
            This type is not responsible for managing the underlying storage
            backing the PE image.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PEModule.lazyContainsNoPiaLocalTypes">
            <summary>
            Using <see cref="T:Microsoft.CodeAnalysis.ThreeState"/> as a type for atomicity.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PEModule.lazyNoPiaLocalTypeCheckBitMap">
            <summary>
            If bitmap is not null, each bit indicates whether a TypeDef 
            with corresponding RowId has been checked if it is a NoPia 
            local type. If the bit is 1, local type will have an entry 
            in m_lazyTypeDefToTypeIdentifierMap.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PEModule.lazyTypeDefToTypeIdentifierMap">
            <summary>
            For each TypeDef that has 1 in m_lazyNoPiaLocalTypeCheckBitMap,
            this map stores corresponding TypeIdentifier AttributeInfo. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PEModule.Machine">
            <summary>
            Target architecture of the machine.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PEModule.Bit32Required">
            <summary>
            Indicates that this PE file makes Win32 calls. See CorPEKind.pe32BitRequired for more information (http://msdn.microsoft.com/en-us/library/ms230275.aspx).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetModuleVersionIdOrThrow">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMetadataModuleNamesOrThrow">
            <summary>
            Returns the names of linked managed modules.
            </summary>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetReferencedManagedModulesOrThrow">
            <summary>
            Returns names of referenced modules.
            </summary>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetModuleRefNameOrThrow(System.Reflection.Metadata.ModuleReferenceHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetReferencedAssembliesOrThrow(System.Reflection.Metadata.MetadataReader)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMemoryReaderOrThrow(System.Reflection.Metadata.BlobHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetFullNameOrThrow(System.Reflection.Metadata.Handle,System.Reflection.Metadata.StringHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.ReadAssemblyIdentityOrThrow">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.CreateAssemblyIdentityOrThrow(System.Reflection.Metadata.MetadataReader,System.Version,System.Reflection.AssemblyFlags,System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetContainingTypeOrThrow(System.Reflection.Metadata.TypeHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetTypeDefNameOrThrow(System.Reflection.Metadata.TypeHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetTypeDefNamespaceOrThrow(System.Reflection.Metadata.TypeHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetTypeDefExtendsOrThrow(System.Reflection.Metadata.TypeHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetTypeDefFlagsOrThrow(System.Reflection.Metadata.TypeHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetTypeDefGenericParamsOrThrow(System.Reflection.Metadata.TypeHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.HasGenericParametersOrThrow(System.Reflection.Metadata.TypeHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetTypeDefPropsOrThrow(System.Reflection.Metadata.TypeHandle,System.String@,System.String@,System.Reflection.TypeAttributes@,System.Reflection.Metadata.Handle@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.IsSystemObjectOrThrow(System.Reflection.Metadata.TypeDefinition)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.IsNestedTypeDefOrThrow(System.Reflection.Metadata.TypeHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.IsInterfaceOrThrow(System.Reflection.Metadata.TypeHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetTypeDefsOrThrow(System.Boolean)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GroupTypesByNamespaceOrThrow(System.StringComparer)">
            <summary>
            The function groups types defined in the module by their fully-qualified namespace name.
            The case-sensitivity of the grouping depends upon the provided StringComparer.
            
            The sequence is sorted by name by using provided comparer. Therefore, if there are multiple 
            groups for a namespace name (e.g. because they differ in case), the groups are going to be 
            adjacent to each other. 
            
            Empty string is used as namespace name for types in the Global namespace. Therefore, all types 
            in the Global namespace, if any, should be in the first group (assuming a reasonable StringComparer).
            </summary>
            Comparer to sort the groups.
            <param name="nameComparer">
            </param>
            <returns>A sorted list of TypeDef row ids, grouped by fully-qualified namespace name.</returns>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetTypeNamespaceNamesOrThrow(System.Collections.Generic.Dictionary{System.String,Microsoft.CodeAnalysis.ArrayBuilder{System.Reflection.Metadata.TypeHandle}})">
            <summary>
            Groups together the RowIds of types in a given namespaces.  The types considered are
            those defined in this module.
            </summary>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetForwardedTypeNamespaceNamesOrThrow(System.Collections.Generic.Dictionary{System.String,Microsoft.CodeAnalysis.ArrayBuilder{System.Reflection.Metadata.TypeHandle}})">
            <summary>
            Supplements the namespace-to-RowIDs map with the namespaces of forwarded types.
            These types will not have associated row IDs (represented as null, for efficiency).
            These namespaces are important because we want lookups of missing forwarded types
            to succeed far enough that we can actually find the type forwarder and provide
            information about the target assembly.
            
            For example, consider the following forwarded type:
            
            .class extern forwarder Namespace.Type {}
            
            If this type is referenced in source as "Namespace.Type", then dev10 reports
            
            error CS1070: The type name 'Namespace.Name' could not be found. This type has been 
            forwarded to assembly 'pe2, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'. 
            Consider adding a reference to that assembly.
            
            If we did not include "Namespace" as a child of the global namespace of this module
            (the forwarding module), then Roslyn would report that the type "Namespace" was not
            found and say nothing about "Name" (because of the diagnostic already attached to 
            the qualifier).
            </summary>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetNestedTypeDefsOrThrow(System.Reflection.Metadata.TypeHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMethodImplementationsOrThrow(System.Reflection.Metadata.TypeHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetImplementedInterfacesOrThrow(System.Reflection.Metadata.TypeHandle)">
            <summary>
            Returns a collection of interfaces implemented by given type.
            </summary>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMethodsOfTypeOrThrow(System.Reflection.Metadata.TypeHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetPropertiesOfTypeOrThrow(System.Reflection.Metadata.TypeHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetEventsOfTypeOrThrow(System.Reflection.Metadata.TypeHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetFieldsOfTypeOrThrow(System.Reflection.Metadata.TypeHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetBaseTypeOfTypeOrThrow(System.Reflection.Metadata.TypeHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetParamArrayCountOrThrow(System.Reflection.Metadata.Handle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.IsTypeIdentifierAttribute(System.Reflection.Metadata.CustomAttributeHandle)">
            <summary>
            Determine if custom attribute application is 
            NoPia TypeIdentifier.
            </summary>
            <returns>
            An index of the target constructor signature in 
            signaturesOfTypeIdentifierAttribute array, -1 if
            this is not NoPia TypeIdentifier.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.IsTargetAttribute(System.Reflection.Metadata.CustomAttributeHandle,System.String,System.String,System.Reflection.Metadata.Handle@,System.Boolean)">
            <summary>
            Determines if a custom attribute matches a namespace and name.
            </summary>
            <param name="customAttribute">Handle of the custom attribute.</param>
            <param name="namespaceName">The custom attribute's namespace in metadata format (case sensitive)</param>
            <param name="typeName">The custom attribute's type name in metadata format (case sensitive)</param>
            <param name="ctor">Constructor of the custom attribute.</param>
            <param name="ignoreCase">Should case be ignored for name comparison?</param>
            <returns>true if match is found</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetAssemblyRef(System.String)">
            <summary>
            Returns MetadataToken for assembly ref matching name
            </summary>
            <param name="assemblyName">The assembly name in metadata format (case sensitive)</param>
            <returns>Matching assembly ref token or nil (0)</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetTypeRef(System.Reflection.Metadata.Handle,System.String,System.String)">
            <summary>
            Returns MetadataToken for type ref matching resolution scope and name
            </summary>
            <param name="resolutionScope">The resolution scope token</param>
            <param name="namespaceName">The namespace name in metadata format (case sensitive)</param>
            <param name="typeName">The type name in metadata format (case sensitive)</param>
            <returns>Matching type ref token or nil (0)</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetTypeRefPropsOrThrow(System.Reflection.Metadata.TypeReferenceHandle,System.String@,System.String@,System.Reflection.Metadata.Handle@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetTargetAttributeSignatureIndex(System.Reflection.Metadata.CustomAttributeHandle,Microsoft.CodeAnalysis.AttributeDescription)">
            <summary>
            Determine if custom attribute matches the target attribute.
            </summary>
            <param name="customAttribute">
            Handle of the custom attribute.
            </param>
            <param name="description">The attribute to match.</param>
            <returns>
            An index of the target constructor signature in
            signatures array, -1 if
            this is not the target attribute.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetTypeAndConstructor(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.Handle@,System.Reflection.Metadata.Handle@)">
            <summary>
            Given a token for a constructor, return the token for the constructor's type and the blob containing the
            constructor's signature.
            </summary>
            <returns>True if the function successfully returns the type and signature.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetAttributeNamespaceAndName(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle@,System.Reflection.Metadata.StringHandle@)">
            <summary>
            Given a token for a type, return the type's name and namespace.  Only works for top level types. 
            namespaceHandle will be NamespaceHandle for defs and StringHandle for refs. 
            </summary>
            <returns>True if the function successfully returns the name and namespace.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.PretendThereArentNoPiaLocalTypes">
            <summary>
            For testing purposes only!!!
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetTypeSpecificationSignatureReaderOrThrow(System.Reflection.Metadata.TypeSpecificationHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMethodSpecificationOrThrow(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.Handle@,System.Reflection.Metadata.BlobHandle@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetGenericParamPropsOrThrow(System.Reflection.Metadata.GenericParameterHandle,System.String@,System.Reflection.GenericParameterAttributes@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetGenericParamConstraintsOrThrow(System.Reflection.Metadata.GenericParameterHandle)">
            <summary>
            Returns an array of tokens for type constraints. Null reference if none.
            </summary>
            <param name="genericParam"></param>
            <returns>
            An array of tokens for type constraints. Null reference if none.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMethodDefNameOrThrow(System.Reflection.Metadata.MethodHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMethodSignatureOrThrow(System.Reflection.Metadata.MethodHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMethodSignatureOrThrow(System.Reflection.Metadata.Handle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMethodDefFlagsOrThrow(System.Reflection.Metadata.MethodHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.FindContainingTypeOrThrow(System.Reflection.Metadata.MethodHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.FindContainingTypeOrThrow(System.Reflection.Metadata.FieldHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetContainingTypeOrThrow(System.Reflection.Metadata.MemberReferenceHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMethodDefPropsOrThrow(System.Reflection.Metadata.MethodHandle,System.String@,System.Reflection.MethodImplAttributes@,System.Reflection.MethodAttributes@,System.Int32@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMethodImplPropsOrThrow(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.Handle@,System.Reflection.Metadata.Handle@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetGenericParametersForMethodOrThrow(System.Reflection.Metadata.MethodHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetParametersOfMethodOrThrow(System.Reflection.Metadata.MethodHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMemberRefNameOrThrow(System.Reflection.Metadata.MemberReferenceHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetSignatureOrThrow(System.Reflection.Metadata.MemberReferenceHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMemberRefPropsOrThrow(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.Handle@,System.String@,System.Byte[]@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetParamPropsOrThrow(System.Reflection.Metadata.ParameterHandle,System.String@,System.Reflection.ParameterAttributes@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetParameterSequenceNumberOrThrow(System.Reflection.Metadata.ParameterHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetPropertyDefNameOrThrow(System.Reflection.Metadata.PropertyHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetPropertySignatureOrThrow(System.Reflection.Metadata.PropertyHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetPropertyDefPropsOrThrow(System.Reflection.Metadata.PropertyHandle,System.String@,System.Reflection.PropertyAttributes@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetEventDefNameOrThrow(System.Reflection.Metadata.EventHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetEventDefPropsOrThrow(System.Reflection.Metadata.EventHandle,System.String@,System.Reflection.EventAttributes@,System.Reflection.Metadata.Handle@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetFieldDefNameOrThrow(System.Reflection.Metadata.FieldHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetFieldSignatureOrThrow(System.Reflection.Metadata.FieldHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetFieldDefFlagsOrThrow(System.Reflection.Metadata.FieldHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetFieldDefPropsOrThrow(System.Reflection.Metadata.FieldHandle,System.String@,System.Reflection.FieldAttributes@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetCustomAttributesOrThrow(System.Reflection.Metadata.Handle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetCustomAttributeValueOrThrow(System.Reflection.Metadata.CustomAttributeHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMarshallingDescriptorHandleOrThrow(System.Reflection.Metadata.Handle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetConstantValueOrThrow(System.Reflection.Metadata.ConstantHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetPropertyMethodsOrThrow(System.Reflection.Metadata.PropertyHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetEventMethodsOrThrow(System.Reflection.Metadata.EventHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetAssemblyReferenceIndexOrThrow(System.Reflection.Metadata.AssemblyReferenceHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PEModule.HasIL">
            <summary>
            Returns true if method IL can be retrieved from the the module.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PEModule.IsEntireImageAvailable">
            <summary>
            Returns true if the full image of the module is available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMethodBodyOrThrow(System.Reflection.Metadata.MethodHandle)">
            <exception cref="T:System.BadImageFormatException">Invalid metadata.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TypeAttributesExtensions.ToCharSet(System.Reflection.TypeAttributes)">
            <summary>
            Extracts <see cref="T:System.Runtime.InteropServices.CharSet"/> information from TypeDef flags.
            Returns 0 if the value is invalid.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AssemblyIdentity">
            <summary>
            Represents an identity of an assembly as defined by CLI metadata specification.
            </summary>
            <remarks>
            May represent assembly definition or assembly reference identity.
            </remarks>
            <summary>
            Represents an identity of an assembly as defined by CLI metadata specification.
            </summary>
            <remarks>
            May represent assembly definition or assembly reference identity.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentity.#ctor(System.String,System.Version,System.String,System.Collections.Immutable.ImmutableArray{System.Byte},System.Boolean,System.Boolean,System.Reflection.AssemblyContentType)">
            <summary>
            Constructs an <see cref="T:Microsoft.CodeAnalysis.AssemblyIdentity"/> from its constituent parts.
            </summary>
            <param name="name">The simple name of the assembly.</param>
            <param name="version">The version of the assembly.</param>
            <param name="cultureName">The name of the culture to associate with the assembly.</param>
            <param name="publicKeyOrToken">The public key or public key token of the assembly.</param>
            <param name="hasPublicKey">Indicates whether <paramref name="publicKeyOrToken"/> represents a public key.</param>
            <param name="isRetargetable">Indicates whether the assembly is retargetable.</param>
            <param name="contentType">Specifies the binding model for how this object will be treated in comparisons.</param>
            <exception cref="T:System.ArgumentException">If <paramref name="name"/> is null, empty or contains an embedded null character.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="contentType"/> is not a value of the <see cref="T:System.Reflection.AssemblyContentType"/> enumeration.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="version"/> contains values that are not greater than or equal to zero and less than or equal to ushort.MaxValue.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="hasPublicKey"/> is true and <paramref name="publicKeyOrToken"/> is not set.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="hasPublicKey"/> is false and <paramref name="publicKeyOrToken"/> 
            contains a value that is not the size of a public key token, 8 bytes.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AssemblyIdentity.Name">
            <summary>
            The simple name of the assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AssemblyIdentity.Version">
            <summary>
            The version of the assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AssemblyIdentity.CultureName">
            <summary>
            The culture name of the assembly, or empty if the culture is neutral.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AssemblyIdentity.Flags">
            <summary>
            The AssemblyNameFlags.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AssemblyIdentity.ContentType">
            <summary>
            Specifies assembly binding model for the assembly definition or reference;
            that is how assembly references are matched to assembly definitions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AssemblyIdentity.HasPublicKey">
            <summary>
            True if the assembly identity includes full public key.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AssemblyIdentity.PublicKey">
            <summary>
            Full public key or empty.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AssemblyIdentity.PublicKeyToken">
            <summary>
            Low 8 bytes of SHA1 hash of the public key, or empty.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AssemblyIdentity.IsStrongName">
            <summary>
            True if the assembly identity has a strong name, ie. either a full public key or a token.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AssemblyIdentity.IsRetargetable">
            <summary>
            Gets the value which specifies if the assembly is retargetable. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentity.op_Equality(Microsoft.CodeAnalysis.AssemblyIdentity,Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            Determines whether two <see cref="T:Microsoft.CodeAnalysis.AssemblyIdentity"/> instances are equal.
            </summary>
            <param name="left">The operand appearing on the left side of the operator.</param>
            <param name="right">The operand appearing on the right side of the operator.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentity.op_Inequality(Microsoft.CodeAnalysis.AssemblyIdentity,Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            Determines whether two <see cref="T:Microsoft.CodeAnalysis.AssemblyIdentity"/> instances are not equal.
            </summary>
            <param name="left">The operand appearing on the left side of the operator.</param>
            <param name="right">The operand appearing on the right side of the operator.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentity.Equals(Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            Determines whether the specified instance is equal to the current instance.
            </summary>
            <param name="obj">The object to be compared with the current instance.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentity.Equals(System.Object)">
            <summary>
            Determines whether the specified instance is equal to the current instance.
            </summary>
            <param name="obj">The object to be compared with the current instance.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentity.GetHashCode">
            <summary>
            Returns the hash code for the current instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentity.MemberwiseEqual(Microsoft.CodeAnalysis.AssemblyIdentity,Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            Returns true (false) if specified assembly identities are (not) equal 
            regardless of unification, retargeting or other assembly binding policies. 
            Returns null if these policies must be consulted to determine name equivalence.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentity.FromAssemblyDefinition(System.Reflection.Assembly)">
            <summary>
            Retrieves assembly definition identity from given runtime assembly.
            </summary>
            <param name="assembly">The runtime assembly.</param>
            <returns>Assembly definition identity.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="assembly"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentity.GetDisplayName(System.Boolean)">
            <summary>
            Returns the display name of the assembly identity.
            </summary>
            <param name="fullKey">True if the full public key should be included in the name. Otherwise public key token is used.</param>
            <returns>The display name.</returns>
            <remarks>
            Characters ',', '=', '"', '\'', '\' occuring in the simple name are escaped by backslash in the display name.
            Any character '\t' is replaced by two characters '\' and 't',
            Any character '\n' is replaced by two characters '\' and 'n',
            Any character '\r' is replaced by two characters '\' and 'r',
            The assembly name in the display name is enclosed in double quotes if it starts or ends with 
            a whitespace character (' ', '\t', '\r', '\n').
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentity.ToString">
            <summary>
            Returns the display name of the current instance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentity.TryParseDisplayName(System.String,Microsoft.CodeAnalysis.AssemblyIdentity@,Microsoft.CodeAnalysis.AssemblyIdentityParts@)">
            <summary>
            Parses display name filling defaults for any basic properties that are missing.
            </summary>
            <param name="displayName">Display name.</param>
            <param name="identity">A full assembly identity.</param>
            <param name="parts">
            Parts of the assembly identity that were specified in the display name, 
            or 0 if the parsing failed.
            </param>
            <returns>True if display name parsed correctly.</returns>
            <remarks>
            The simple name has to be non-empty.
            A partially specified version might be missing build and/or revision number. The default value for these is 65535.
            The default culture is neutral (<see cref="P:Microsoft.CodeAnalysis.AssemblyIdentity.CultureName"/> is <see cref="F:System.String.Empty"/>.
            If neither public key nor token is specified the identity is considered weak.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="displayName"/> is null.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AssemblyIdentityComparer">
            <summary>
            Compares assembly identities. 
            Derived types may implement platform specific unification and portability policies.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AssemblyIdentityComparer.ComparisonResult">
            <summary>
            A set of possible outcomes of <see cref="T:Microsoft.CodeAnalysis.AssemblyIdentity"/> comparison.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AssemblyIdentityComparer.ComparisonResult.NotEquivalent">
            <summary>
            Reference doesn't match definition.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AssemblyIdentityComparer.ComparisonResult.Equivalent">
            <summary>
            Strongly named reference matches strongly named definition (strong identity is identity with public key or token),
            Or weak reference matches weak definition.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AssemblyIdentityComparer.ComparisonResult.EquivalentIgnoringVersion">
            <summary>
            Reference matches definition except for version (reference version is lower or higher than definition version).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentityComparer.ReferenceMatchesDefinition(System.String,Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            Compares assembly reference name (possibly partial) with definition identity.
            </summary>
            <param name="referenceDisplayName">Partial or full assembly display name.</param>
            <param name="definition">Full assembly display name.</param>
            <returns>True if the reference name matches the definition identity.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentityComparer.ReferenceMatchesDefinition(Microsoft.CodeAnalysis.AssemblyIdentity,Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            Compares assembly reference identity with definition identity.
            </summary>
            <param name="reference">Reference assembly identity.</param>
            <param name="definition">Full assembly display name.</param>
            <returns>True if the reference identity matches the definition identity.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentityComparer.Compare(Microsoft.CodeAnalysis.AssemblyIdentity,Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            Compares reference assembly identity with definition identity and returns their relationship.
            </summary>
            <param name="reference">Reference identity.</param>
            <param name="definition">Definition identity.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AssemblyMetadata">
            <summary>
            Represents an immutable snapshot of assembly CLI metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AssemblyMetadata.Modules">
            <summary>
            Modules comprising this assembly. The first module is the manifest module.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AssemblyMetadata.CachedSymbols">
            <summary>
            Cached assembly symbols.
            </summary>
            <remarks>
            Guarded by <see cref="F:CommonReferenceManager.SymbolCacheAndReferenceManagerStateGuard"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Creates a single-module assembly.
            </summary>
            <param name="peImage">
            Manifest module image.
            </param>
            <exception cref="T:System.ArgumentException"><paramref name="peImage"/> has the default value.</exception>
            <exception cref="T:System.BadImageFormatException">The PE image format is invalid.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromImage(System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
            Creates a single-module assembly.
            </summary>
            <param name="peImage">
            Manifest module image.
            </param>
            <exception cref="T:System.BadImageFormatException">The PE image format is invalid.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromImageStream(System.IO.Stream,System.Boolean)">
            <summary>
            Creates a single-module assembly.
            </summary>
            <param name="peStream">Manifest module PE image stream.</param>
            <param name="leaveOpen">False to close the stream upon disposal of the metadata.</param>
            <exception cref="T:System.BadImageFormatException">The PE image format is invalid.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromImageStream(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions)">
            <summary>
            Creates a single-module assembly.
            </summary>
            <param name="peStream">Manifest module PE image stream.</param>
            <param name="options">False to close the stream upon disposal of the metadata.</param>
            <exception cref="T:System.BadImageFormatException">The PE image format is invalid.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyMetadata.Create(Microsoft.CodeAnalysis.ModuleMetadata)">
            <summary>
            Creates a single-module assembly.
            </summary>
            <param name="module">
            Manifest module.
            </param>
            <remarks>This object disposes <paramref name="module"/> it when it is itself disposed.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyMetadata.Create(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ModuleMetadata})">
            <summary>
            Creates a multi-module assembly.
            </summary>
            <param name="modules">
            Modules comprising the assembly. The first module is the manifest module of the assembly.</param>
            <remarks>This object disposes the elements of <paramref name="modules"/> it when it is itself <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.Dispose"/>.</remarks>
            <exception cref="T:System.ArgumentException"><paramref name="modules"/> is default value.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="modules"/> contains null elements.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="modules"/> is empty or contains a module that doesn't own its image (was created via <see cref="M:MetadataModule.Copy"/>).</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyMetadata.Create(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ModuleMetadata})">
            <summary>
            Creates a multi-module assembly.
            </summary>
            <param name="modules">
            Modules comprising the assembly. The first module is the manifest module of the assembly.</param>
            <remarks>This object disposes the elements of <paramref name="modules"/> it when it is itself <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.Dispose"/>.</remarks>
            <exception cref="T:System.ArgumentException"><paramref name="modules"/> is default value.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="modules"/> contains null elements.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="modules"/> is empty or contains a module that doesn't own its image (was created via <see cref="M:MetadataModule.Copy"/>).</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyMetadata.Create(Microsoft.CodeAnalysis.ModuleMetadata[])">
            <summary>
            Creates a multi-module assembly.
            </summary>
            <param name="modules">Modules comprising the assembly. The first module is the manifest module of the assembly.</param>
            <remarks>This object disposes the elements of <paramref name="modules"/> it when it is itself <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.Dispose"/>.</remarks>
            <exception cref="T:System.ArgumentException"><paramref name="modules"/> is default value.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="modules"/> contains null elements.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="modules"/> is empty or contains a module that doesn't own its image (was created via <see cref="M:MetadataModule.Copy"/>).</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyMetadata.Copy">
            <summary>
            Creates a shallow copy of contained modules and wraps them into a new instance of <see cref="T:Microsoft.CodeAnalysis.AssemblyMetadata"/>.
            </summary>
            <remarks>
            The resulting copy shares the metadata images and metadata information read from them with the original.
            It doesn't own the underlying metadata images and is not responsible for its disposal.
            
            This is used, for example, when a metadata cache needs to return the cached metadata to its users
            while keeping the ownership of the cached metadata object.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyMetadata.Dispose">
            <summary>
            Disposes all modules contained in the assembly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyMetadata.IsValidAssembly">
            <summary>
            Checks if the first module has a single row in Assembly table and that all other modules have none.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AssemblyMetadata.ManifestModule">
            <summary>
            The manifest module of the assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AssemblyMetadata.Kind">
            <summary>
            Returns the metadata kind. <seealso cref="T:Microsoft.CodeAnalysis.MetadataImageKind"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromFile(System.String)">
            <summary>
            Finds all modules of an assembly on a specified path and builds an instance of <see cref="T:Microsoft.CodeAnalysis.AssemblyMetadata"/> that represents them.
            </summary>
            <param name="fullPath">The full path to the assembly on disk.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="fullPath"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="fullPath"/> is not an absolute path.</exception>
            <exception cref="T:System.IO.IOException">Error reading file <paramref name="fullPath"/>. See <see cref="P:System.Exception.InnerException"/> for details.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Metadata">
            <summary>
            Represents immutable assembly or module CLI metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Metadata.Kind">
            <summary>
            Retrieves the <see cref="T:Microsoft.CodeAnalysis.MetadataImageKind"/> for this instance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Metadata.Dispose">
            <summary>
            Releases any resources associated with this instance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Metadata.Copy">
            <summary>
            Creates a copy of this object.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataImageKind">
            <summary>
            The kind of metadata a PE file image contains.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataImageKind.Assembly">
            <summary>
            The PE file is an assembly.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataImageKind.Module">
            <summary>
            The PE file is a module.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataImageReference">
            <summary>
            Represents an in-memory Portable-Executable image.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataImageReference.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte},Microsoft.CodeAnalysis.DocumentationProvider,System.Collections.Immutable.ImmutableArray{System.String},System.Boolean,System.String,System.String)">
            <summary>
            Creates a reference to a single-module assembly image.
            </summary>
            <param name="assemblyImage">Read-only assembly image.</param>
            <param name="documentation">Provides XML documentation for symbol found in the reference.</param>
            <param name="aliases">Reference aliases.</param>
            <param name="embedInteropTypes">True if interop types contained in the reference should be embedded to the compilation that uses the reference.</param>
            <param name="fullPath">Optional full path used for reference comparison when used in compilation. The file doesn't need to exist.</param>
            <param name="display">Display string for error reporting.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataImageReference.#ctor(System.Collections.Generic.IEnumerable{System.Byte},Microsoft.CodeAnalysis.DocumentationProvider,System.Collections.Immutable.ImmutableArray{System.String},System.Boolean,System.String,System.String)">
            <summary>
            Creates a reference to a single-module assembly image.
            </summary>
            <param name="assemblyImage">Read-only assembly image.</param>
            <param name="documentation">Provides XML documentation for symbol found in the reference.</param>
            <param name="aliases">Reference aliases.</param>
            <param name="embedInteropTypes">True if interop types contained in the reference should be embedded to the compilation that uses the reference.</param>
            <param name="fullPath">Optional full path used for reference comparison when used in compilation. The file doesn't need to exist.</param>
            <param name="display">Display string for error reporting.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataImageReference.#ctor(System.IO.Stream,Microsoft.CodeAnalysis.DocumentationProvider,System.Collections.Immutable.ImmutableArray{System.String},System.Boolean,System.String,System.String)">
            <summary>
            Creates a reference to a single-module assembly image.
            </summary>
            <param name="assemblyImage">Stream with assembly image, it should support seek operations.</param>
            <param name="documentation">Provides XML documentation for symbol found in the reference.</param>
            <param name="aliases">Reference alias.</param>
            <param name="embedInteropTypes">True if interop types contained in the reference should be embedded to the compilation that uses the reference.</param>
            <param name="fullPath">Optional full path used for reference comparison when used in compilation. The file doesn't need to exist.</param>
            <param name="display">Display string for error reporting.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataImageReference.#ctor(Microsoft.CodeAnalysis.ModuleMetadata,Microsoft.CodeAnalysis.DocumentationProvider,System.String,System.String)">
            <summary>
            Creates a reference to a standalone module image.
            </summary>
            <param name="metadata">Metadata for the standalone module.</param>
            <param name="fullPath">
            Optional full path used for reference comparison when used in compilation. 
            The file doesn't need to exist.
            If <paramref name="metadata"/> represents a memory mapped file and this parameter is not specified the path to the memory mapped file is used.
            </param>
            <param name="documentation">Provides XML documentation for symbol found in the reference.</param>
            <param name="display">Display string for error reporting.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataImageReference.#ctor(Microsoft.CodeAnalysis.AssemblyMetadata,Microsoft.CodeAnalysis.DocumentationProvider,System.Collections.Immutable.ImmutableArray{System.String},System.Boolean,System.String,System.String)">
            <summary>
            Creates a reference to an assembly or a module image. The assembly can comprise multiple modules.
            </summary>
            <param name="metadata">Assembly or module metadata.</param>
            <param name="documentation">Provides XML documentation for symbol found in the reference.</param>
            <param name="aliases">Reference aliases.</param>
            <param name="embedInteropTypes">True if interop types contained in the reference should be embedded to the compilation that uses the reference.</param>
            <param name="fullPath">
            Optional full path used for reference comparison when used in compilation. 
            The file doesn't need to exist.
            If the manifest module of the assembly is a memory mapped file and this parameter is not specified the path to the memory mapped file is used.
            </param>
            <param name="display">Display string for error reporting.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataImageReference.WithAliases(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Returns an instance of the reference with specified aliases.
            </summary>
            <param name="aliases">The new aliases for the reference.</param>
            <exception cref="T:System.ArgumentException">Alias is invalid for the metadata kind.</exception> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataImageReference.WithAliases(System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
            Returns an instance of the reference with specified aliases.
            </summary>
            <param name="aliases">The new aliases for the reference.</param>
            <exception cref="T:System.ArgumentException">Alias is invalid for the metadata kind.</exception> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataImageReference.WithEmbedInteropTypes(System.Boolean)">
            <summary>
            Returns an instance of the reference with specified interop types embedding.
            </summary>
            <param name="value">The new value for <see cref="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.EmbedInteropTypes"/>.</param>
            <exception cref="T:System.ArgumentException">Interop types can't be embedded from modules.</exception> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataImageReference.WithDocumentationProvider(Microsoft.CodeAnalysis.DocumentationProvider)">
            <summary>
            Returns an instance of the reference with specified documentation provider.
            </summary>
            <param name="provider">The new <see cref="T:Microsoft.CodeAnalysis.DocumentationProvider"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="provider"/> is null.</exception> 
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataReference">
            <summary>
            Represents metadata image reference.
            </summary>
            <remarks>
            Represents a logical location of the image, not the content of the image. 
            The content might change in time. A snapshot is taken when the compiler queries the reference for its metadata.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataReference.Display">
            <summary>
            Path or name used in error messages to identity the reference.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataReference.IsUnresolved">
            <summary>
            Returns true if this reference is an unresolved reference.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataReferenceProperties">
            <summary>
            Information about a metadata reference.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataReferenceProperties.Module">
            <summary>
            Default properties for a module reference.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataReferenceProperties.Assembly">
            <summary>
            Default properties for an assembly reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataReferenceProperties.#ctor(Microsoft.CodeAnalysis.MetadataImageKind,System.Collections.Immutable.ImmutableArray{System.String},System.Boolean)">
            <summary>
            Initializes reference properties.
            </summary>
            <param name="kind">The image kind - assembly or module.</param>
            <param name="aliases">Assembly aliases. Can't be set for a module.</param>
            <param name="embedInteropTypes">True to embed interop types from the referenced assembly to the referencing compilation. Must be false for a module.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataReferenceProperties.WithAliases(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Returns <see cref="T:Microsoft.CodeAnalysis.MetadataReferenceProperties"/> with specified aliases.
            </summary>
            <exception cref="T:System.ArgumentException">
            <see cref="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.Kind"/> is <see cref="F:Microsoft.CodeAnalysis.MetadataImageKind.Module"/>, as modules can't be aliased.
            </exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataReferenceProperties.WithAliases(System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
            Returns <see cref="T:Microsoft.CodeAnalysis.MetadataReferenceProperties"/> with specified aliases.
            </summary>
            <exception cref="T:System.ArgumentException">
            <see cref="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.Kind"/> is <see cref="F:Microsoft.CodeAnalysis.MetadataImageKind.Module"/>, as modules can't be aliased.
            </exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataReferenceProperties.WithEmbedInteropTypes(System.Boolean)">
            <summary>
            Returns <see cref="T:Microsoft.CodeAnalysis.MetadataReferenceProperties"/> with <see cref="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.EmbedInteropTypes"/> set to specified value.
            </summary>
            <exception cref="T:System.ArgumentException"><see cref="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.Kind"/> is <see cref="F:Microsoft.CodeAnalysis.MetadataImageKind.Module"/>, as interop types can't be embedded from modules.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.Kind">
            <summary>
            The image kind (assembly or module) the reference refers to.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataReferenceProperties.GlobalAlias">
            <summary>
            Alias that represents a global declaration space.
            </summary>
            <remarks>
            Namespaces in references whose <see cref="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.Aliases"/> contain <see cref="F:Microsoft.CodeAnalysis.MetadataReferenceProperties.GlobalAlias"/> are available in global declaration space.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.Aliases">
            <summary>
            Aliases for the metadata reference, or default(<see cref="T:System.Collections.Immutable.ImmutableArray"/>) if no aliases were specified.
            </summary>
            <remarks>
            In C# these aliases can be used in "extern alias" syntax to disambiguate type names. 
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.EmbedInteropTypes">
            <summary>
            True if interop types defined in the referenced metadata should be embedded into the compilation referencing the metadata.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataReferenceProvider">
            <summary>
            An extensible mechanism for providing <see cref="T:Microsoft.CodeAnalysis.PortableExecutableReference"/>
            to services that require them.
            </summary>
            <remarks>Used to create <see cref="T:Microsoft.CodeAnalysis.PortableExecutableReference"/> when 
            processing interactive code directives that load .NET metadata.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataReferenceProvider.GetReference(System.String,Microsoft.CodeAnalysis.MetadataReferenceProperties)">
            <summary>
            Maps "metadata about .NET metadata" to <see cref="T:Microsoft.CodeAnalysis.PortableExecutableReference"/>. 
            </summary>
            <param name="resolvedPath">Path returned by <see cref="M:Microsoft.CodeAnalysis.MetadataReferenceResolver.ResolveReference(System.String,System.String)"/>.</param>
            <param name="properties">Metadata reference properties.</param>
            <returns>A <see cref="T:Microsoft.CodeAnalysis.PortableExecutableReference"/> corresponding to the <paramref name="resolvedPath"/> and
            <paramref name="properties"/> parameters.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataReferenceResolver">
            <summary>
            Resolves references to metadata specified in the source (#r directives).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ModuleMetadata">
            <summary>
            Represents an immutable snapshot of module CLI metadata.
            </summary>
            <remarks>This object may allocate significant resources or lock files depending upon how it is constructed.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromMetadata(System.IntPtr,System.Int32)">
            <summary>
            Create metadata module from a raw memory pointer to metadata directory of a PE image or .cormeta section of an object file.
            Only manifest modules are currently supported.
            </summary>
            <param name="metadata">Pointer to the start of metadata block.</param>
            <param name="size">The size of the metadata block.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="metadata"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size"/> is not positive.</exception>
            <exception cref="T:System.BadImageFormatException"><paramref name="metadata"/> doesn't contain valid metadata.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="metadata"/> doesn't represent an assembly (manifest module).</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromImage(System.IntPtr,System.Int32)">
            <summary>
            Create metadata module from a raw memory pointer to a PE image or an object file.
            </summary>
            <param name="peImage">Pointer to the DOS header ("MZ") of a portable executable image.</param>
            <param name="size">The size of the image pointed to by <paramref name="peImage"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="peImage"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size"/> is not positive.</exception>
            <exception cref="T:System.BadImageFormatException"><paramref name="peImage"/> is not valid portable executable image containing CLI metadata</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromImage(System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
            Create metadata module from a sequence of bytes.
            </summary>
            <param name="peImage">The portable executable image beginning with the DOS header ("MZ").</param>
            <exception cref="T:System.ArgumentException"><paramref name="peImage"/> is null.</exception>
            <exception cref="T:System.BadImageFormatException"><paramref name="peImage"/> is not valid portable executable image containing CLI metadata</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Create metadata module from a byte array.
            </summary>
            <param name="peImage">Portable executable image beginning with the DOS header ("MZ").</param>
            <exception cref="T:System.ArgumentException"><paramref name="peImage"/> is null.</exception>
            <exception cref="T:System.BadImageFormatException"><paramref name="peImage"/> is not valid portable executable image containing CLI metadata</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromImageStream(System.IO.Stream,System.Boolean)">
            <summary>
            Create metadata module from a stream.
            </summary>
            <param name="peStream">Stream containing portable executable image. Position zero should contain the first byte of the DOS header ("MZ").</param>
            <param name="leaveOpen">
            False to close the stream upon disposal of the metadata (the responsibility for disposal of the stream is transferred upon entry of the constructor
            unless the arguments given are invalid).
            </param>
            <exception cref="T:System.BadImageFormatException"><paramref name="peStream"/> is not valid portable executable image containing CLI metadata</exception>
            <exception cref="T:System.ArgumentException">The stream doesn't support seek operations.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="peStream"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromImageStream(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions)">
            <summary>
            Create metadata module from a stream.
            </summary>
            <param name="peStream">Stream containing portable executable image. Position zero should contain the first byte of the DOS header ("MZ").</param>
            <param name="options">
            Options specifying how sections of the PE image are read from the stream.
            Unless <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen"/> is specified, the responsibility for disposal of the stream is transferred upon entry of the constructor
            unless the arguments given are invalid.
            </param>
            <exception cref="T:System.BadImageFormatException"><paramref name="peStream"/> is not valid portable executable image containing CLI metadata</exception>
            <exception cref="T:System.ArgumentException">The stream doesn't support read and seek operations.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="peStream"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options"/> has an invalid value.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleMetadata.Copy">
            <summary>
            Creates a shallow copy of this object.
            </summary>
            <remarks>
            The resulting copy shares the metadata image and metadata information read from it with the original.
            It doesn't own the underlying metadata image and is not responsible for its disposal.
            
            This is used, for example, when a metadata cache needs to return the cached metadata to its users
            while keeping the ownership of the cached metadata object.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleMetadata.Dispose">
            <summary>
            Frees memory and handles allocated for the module.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ModuleMetadata.Name">
            <summary>
            Name of the module.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Module has been disposed.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleMetadata.GetModuleVersionId">
            <summary>
            Version of the module content.
            </summary>
            <exception cref="T:System.BadImageFormatException">Invalid metadata.</exception>
            <exception cref="T:System.ObjectDisposedException">Module has been disposed.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ModuleMetadata.Kind">
            <summary>
            Returns the <see cref="T:Microsoft.CodeAnalysis.MetadataImageKind"/> for this instance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleMetadata.GetModuleNames">
            <summary>
            Returns the file names of linked managed modules.
            </summary>
            <exception cref="T:System.BadImageFormatException">When an invalid module name is encountered.</exception>
            <exception cref="T:System.ObjectDisposedException">Module has been disposed.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromFile(System.String)">
            <summary>
            Creates metadata module from a file containing a portable executable image.
            </summary>
            <param name="fullPath">Absolute file path.</param>
            <remarks>
            The file might remain mapped (and read-locked) until this object is disposed.
            The memory map is only created for large files. Small files are read into memory.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="fullPath"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="fullPath"/> is not a valid absolute path.</exception>
            <exception cref="T:System.BadImageFormatException">The PE image format is invalid.</exception>
            <exception cref="T:System.IO.IOException">Error reading file <paramref name="fullPath"/>. See <see cref="P:System.Exception.InnerException"/> for details.</exception>
            <exception cref="T:System.IO.FileNotFoundException">File <paramref name="fullPath"/> not found.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PortableExecutableReference">
            <summary>
            Reference to metadata stored in the standard ECMA-335 metadata format.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PortableExecutableReference.Display">
            <summary>
            Path or name used in error messages to identity the reference.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PortableExecutableReference.FullPath">
            <summary>
            Full path describing the location of the metadata, or null if the metadata have no location.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PortableExecutableReference.CreateDocumentationProvider">
            <summary>
            Create documentation provider for the reference.
            </summary>
            <remarks>
            Called when the compiler needs to read the documentation for the reference. 
            This method is called at most once per metadata reference and its result is cached on the reference object.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PortableExecutableReference.DocumentationProvider">
            <summary>
            XML documentation comments provider for the reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PortableExecutableReference.GetMetadataImpl">
             <summary>
             Get metadata representation for the PE file.
             </summary>
             <exception cref="T:System.BadImageFormatException">If the PE image format is invalid.</exception>
             <exception cref="T:System.IO.IOException">The metadata image content can't be read.</exception>
             <exception cref="T:System.IO.FileNotFoundException">The metadata image is stored in a file that can't be found.</exception>
             <remarks>
             Called when the <see cref="T:Microsoft.CodeAnalysis.Compilation"/> needs to read the reference metadata.
             
             The listed exceptions are caught and converted to compilation diagnostics.
             Any other exception is considered an unexpected error in the implementation and is not caught.
            
             <see cref="T:Microsoft.CodeAnalysis.Metadata"/> objects may cache information decoded from the PE image.
             Reusing <see cref="T:Microsoft.CodeAnalysis.Metadata"/> instances accross metadata references will result in better performance.
             
             The calling <see cref="T:Microsoft.CodeAnalysis.Compilation"/> doesn't take ownership of the <see cref="T:Microsoft.CodeAnalysis.Metadata"/> objects returned by this method.
             The implementation needs to retrieve the object from a provider that manages their lifetime (such as metadata cache).
             The <see cref="T:Microsoft.CodeAnalysis.Metadata"/> object is kept alive by the <see cref="T:Microsoft.CodeAnalysis.Compilation"/> that called <see cref="M:Microsoft.CodeAnalysis.PortableExecutableReference.GetMetadata"/>
             and by all compilations created from it via calls to With- factory methods on <see cref="T:Microsoft.CodeAnalysis.Compilation"/>, 
             other than <see cref="M:Compilation.WithReferences"/> overloads. A compilation created using 
             <see cref="M:Compilation.WithReferences"/> will call to <see cref="M:Microsoft.CodeAnalysis.PortableExecutableReference.GetMetadata"/> again.
             </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ReferenceDirective">
            <summary>
            Represents the value of #r reference along with its source location.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UnresolvedMetadataReference">
            <summary>
            Represents a metadata reference that can't be resolved.
            </summary>
            <remarks>
            For error reporting only, can't be used to reference a metadata file.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentityExtensions.ToAssemblyName(Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            Converts this identity to <see cref="T:System.Reflection.AssemblyName"/>.
            </summary>
            <returns>A new instance of <see cref="T:System.Reflection.AssemblyName"/>.</returns>
            <exception cref="T:System.Globalization.CultureNotFoundException">The culture specified in <see cref="P:Microsoft.CodeAnalysis.AssemblyIdentity.CultureName"/> is not available on the current platform.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AssemblyPortabilityPolicy">
            <summary>
            Policy to be used when matching assembly reference to an assembly definition accross platforms.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyVersion.op_Explicit(System.Version)~Microsoft.CodeAnalysis.AssemblyVersion">
            <summary>
            Converts <see cref="T:System.Version"/> to <see cref="T:Microsoft.CodeAnalysis.AssemblyVersion"/>.
            </summary>
            <exception cref="T:System.InvalidCastException">Major, minor, build or revision number are less than 0 or greater than 0xFFFF.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ClrMetaHost">
            <summary>
            Managed abstraction of the functionality provided by ICLRMetaHost.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ClrMetaHost.CurrentRuntime">
            <summary>
            Gets the <see cref="T:Microsoft.Runtime.Hosting.ClrRuntimeInfo"/> corresponding to the current runtime.
            That is, the runtime executing currently.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommandLineReference">
            <summary>
            Describes a command line metadata reference (assembly or netmodule) specification.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineReference.Reference">
            <summary>
            Metadata file path or an assembly display name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineReference.Properties">
            <summary>
            Metadata reference properties.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommandLineSourceFile">
            <summary>
            Describes a source file specification stored on command line arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineSourceFile.Path">
            <summary>
            Resolved absolute path of the source file (does not contain wildcards).
            </summary>
            <remarks>
            Although this path is absolute it may not be normalized. That is, it may contain ".." and "." in the middle. 
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineSourceFile.IsScript">
            <summary>
            True if the file should be treated as a script file.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommandLineArguments">
            <summary>
            The base class for representing command line arguments to a
            <see cref="T:Microsoft.CodeAnalysis.CommonCompiler"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.BaseDirectory">
            <summary>
            Directory used to resolve relative paths stored in the arguments.
            </summary>
            <remarks>
            Except for paths stored in <see cref="P:Microsoft.CodeAnalysis.CommandLineArguments.MetadataReferences"/>, all
            paths stored in the properties of this class are resolved and
            absolute. This is the directory that relative paths specified on
            command line were resolved against.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.ReferencePaths">
            <summary>
            Sequence of absolute paths used to search for references.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.KeyFileSearchPaths">
            <summary>
            Sequence of absolute paths used to search for key files.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.Utf8Output">
            <summary>
            If true, use UTF8 for output.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.CompilationName">
            <summary>
            Compilation name or null if not specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.OutputFileName">
            <summary>
            Name of the output file or null if not specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.PdbPath">
            <summary>
            Path of the PDB file or null if not specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.OutputDirectory">
            <summary>
            Absolute path of the output directory.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.DocumentationPath">
            <summary>
            Absolute path of the documentation comment XML file or null if not specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.AppConfigPath">
            <summary>
            An absolute path of the App.config file or null if not specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.Errors">
            <summary>
            Errors while parsing the command line arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.MetadataReferences">
            <summary>
            References to metadata supplied on the command line. 
            Includes assemblies specified via /r and netmodules specified via /addmodule.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.AnalyzerReferences">
            <summary>
            References to analyzers supplied on the command line.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.DisplayLogo">
            <summary>
            If true, prepend the command line header logo during 
            <see cref="M:Microsoft.CodeAnalysis.CommonCompiler.Run(System.IO.TextWriter,System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.DisplayHelp">
            <summary>
            If true, append the command line help during
            <see cref="M:Microsoft.CodeAnalysis.CommonCompiler.Run(System.IO.TextWriter,System.Threading.CancellationToken)"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.Win32ResourceFile">
            <summary>
            The path to a Win32 resource.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.Win32Icon">
            <summary>
            The path to a .ico icon file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.Win32Manifest">
            <summary>
            The path to a Win32 manifest file to embed
            into the output portable executable (PE) file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.NoWin32Manifest">
            <summary>
            If true, do not embed any Win32 manifest, including
            one specified by <see cref="P:Microsoft.CodeAnalysis.CommandLineArguments.Win32Manifest"/> or any
            default manifest.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.ManifestResources">
            <summary>
            Resources specified as arguments to the compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.Encoding">
            <summary>
            Encoding to be used for source files or 'null' for autodetect/default.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.ScriptArguments">
            <summary>
            Arguments following script argument separator "--" or null if <see cref="P:Microsoft.CodeAnalysis.CommandLineArguments.IsInteractive"/> is false.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.SourceFiles">
            <summary>
            Source file paths.
            </summary>
            <remarks>
            Includes files specified directly on command line as well as files matching patterns specified 
            on command line using '*' and '?' wildcards or /recurse option.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.TouchedFilesPath">
            <summary>
            Fule path of a log of file paths accessed by the compiler, or null if file logging should be suppressed.
            </summary>
            <remarks>
            Two log files will be created: 
            One with path <see cref="P:Microsoft.CodeAnalysis.CommandLineArguments.TouchedFilesPath"/> and extension ".read" logging the files read,
            and second with path <see cref="P:Microsoft.CodeAnalysis.CommandLineArguments.TouchedFilesPath"/> and extension ".write" logging the files written to  during compilation.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.PrintFullPaths">
            <summary>
            If true, prints the full path of the file containing errors or
            warnings in diagnostics.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.ParseOptions">
            <summary>
            Options to the <see cref="T:Microsoft.CodeAnalysis.CommandLineParser"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.CompilationOptions">
            <summary>
            Options to the <see cref="T:Microsoft.CodeAnalysis.Compilation"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.PreferredUILang">
            <summary>
            Specify the preferred output language name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineArguments.ResolveMetadataReferences(Microsoft.CodeAnalysis.MetadataReferenceResolver,Microsoft.CodeAnalysis.MetadataReferenceProvider)">
            <summary>
            Resolves metadata references stored in <see cref="P:Microsoft.CodeAnalysis.CommandLineArguments.MetadataReferences"/> using given file resolver and metadata provider.
            </summary>
            <param name="metadataResolver"><see cref="T:Microsoft.CodeAnalysis.MetadataReferenceResolver"/> to use for assembly name and relative path resolution.</param>
            <param name="metadataProvider"><see cref="T:Microsoft.CodeAnalysis.MetadataReferenceProvider"/> to read metadata from resolved paths.</param>
            <returns>Yields resolved metadata references or <see cref="T:Microsoft.CodeAnalysis.UnresolvedMetadataReference"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="metadataResolver"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="metadataProvider"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineArguments.ResolveMetadataReferences(Microsoft.CodeAnalysis.MetadataReferenceResolver,Microsoft.CodeAnalysis.MetadataReferenceProvider,System.Collections.Generic.List{Microsoft.CodeAnalysis.DiagnosticInfo},Microsoft.CodeAnalysis.CommonMessageProvider)">
            <summary>
            Resolves metadata references stored in <see cref="P:Microsoft.CodeAnalysis.CommandLineArguments.MetadataReferences"/> using given file resolver and metadata provider.
            If a non-null diagnostic bag <paramref name="diagnosticsOpt"/> is provided, it catches exceptions that may be generated while reading the metadata file and
            reports appropriate diagnostics.
            Otherwise, if <paramref name="diagnosticsOpt"/> is null, the exceptions are unhandled.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineArguments.ResolveAnalyzerReferences">
            <summary>
            Resolves analyzer references stored in <see cref="P:Microsoft.CodeAnalysis.CommandLineArguments.AnalyzerReferences"/> using given file resolver.
            </summary>
            <returns>Yields resolved <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference"/> or <see cref="T:Microsoft.CodeAnalysis.Diagnostics.UnresolvedAnalyzerReference"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.EnumerateFiles(System.String,System.String,System.IO.SearchOption)">
            <summary>
            Enumerates files in the specified directory and subdirectories whose name matches the given pattern.
            </summary>
            <param name="directory">Full path of the directory to enumerate.</param>
            <param name="fileNamePattern">File name pattern. May contain wildcards '*' (matches zero or more characters) and '?' (matches any character).</param>
            <param name="searchOption">Specifies whether to search the specified <paramref name="directory"/> only, or all its subdirectories as well.</param>
            <returns>Sequence of file paths.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.ParseResponseFile(System.String,System.Collections.Generic.IList{Microsoft.CodeAnalysis.Diagnostic})">
            <summary>
            Parse a response file into a set of arguments. Errors openening the response file are output into "errors".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.ParseResponseLines(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Take a string of lines from a response file, remove comments, 
            and split into a set of command line arguments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.RemoveAllQuotes(System.String)">
            <summary>
            Remove all double quote characters from the given string.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.Unquote(System.String)">
            <summary>
            Remove one set of leading and trailing double quote characters, if both are present.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.SplitCommandLineIntoArguments(System.String,System.Boolean)">
            <summary>
            Split a command line by the same rules as Main would get the commands.
            </summary>
            <remarks>
            Rules for command line parsing, according to MSDN:
            
            Arguments are delimited by white space, which is either a space or a tab.
             
            A string surrounded by double quotation marks ("string") is interpreted 
            as a single argument, regardless of white space contained within. 
            A quoted string can be embedded in an argument.
             
            A double quotation mark preceded by a backslash (\") is interpreted as a 
            literal double quotation mark character (").
             
            Backslashes are interpreted literally, unless they immediately precede a 
            double quotation mark.
             
            If an even number of backslashes is followed by a double quotation mark, 
            one backslash is placed in the argv array for every pair of backslashes, 
            and the double quotation mark is interpreted as a string delimiter.
             
            If an odd number of backslashes is followed by a double quotation mark, 
            one backslash is placed in the argv array for every pair of backslashes, 
            and the double quotation mark is "escaped" by the remaining backslash, 
            causing a literal double quotation mark (") to be placed in argv.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.Split(System.String,System.Func{System.Char,System.Boolean})">
            <summary>
            Split a string, based on whether "splitHere" returned true on each character.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.CondenseDoubledBackslashes(System.String)">
            <summary>
            Condense double backslashes that precede a quotation mark to single backslashes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.AddBackslashes(System.Text.StringBuilder,System.Int32)">
            <summary>
            Add "count" backslashes to a StringBuilder. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.ParseSeparatedStrings(System.String,System.Char[],System.StringSplitOptions)">
            <summary>
            Split a string by a set of separators, taking quotes into account.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.TryParseUInt64(System.String,System.UInt64@)">
            <summary>
            Tries to parse a UInt64 from string in either decimal, octal or hex format.
            </summary>
            <param name="value">The string value.</param>
            <param name="result">The result if parsing was successful.</param>
            <returns>true if parsing was successful, otherwise false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.TryParseUInt16(System.String,System.UInt16@)">
            <summary>
            Tries to parse a UInt16 from string in either decimal, octal or hex format.
            </summary>
            <param name="value">The string value.</param>
            <param name="result">The result if parsing was successful.</param>
            <returns>true if parsing was successful, otherwise false.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommandLineSplitter">
            <remarks>
            Rules for command line parsing, according to MSDN:
            
            Arguments are delimited by white space, which is either a space or a tab.
             
            A string surrounded by double quotation marks ("string") is interpreted 
            as a single argument, regardless of white space contained within. 
            A quoted string can be embedded in an argument.
             
            A double quotation mark preceded by a backslash (\") is interpreted as a 
            literal double quotation mark character (").
             
            Backslashes are interpreted literally, unless they immediately precede a 
            double quotation mark.
             
            If an even number of backslashes is followed by a double quotation mark, 
            one backslash is placed in the argv array for every pair of backslashes, 
            and the double quotation mark is interpreted as a string delimiter.
             
            If an odd number of backslashes is followed by a double quotation mark, 
            one backslash is placed in the argv array for every pair of backslashes, 
            and the double quotation mark is "escaped" by the remaining backslash, 
            causing a literal double quotation mark (") to be placed in argv.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonCompiler">
            <summary>
            Base class for csc.exe, csi.exe, vbc.exe and vbi.exe implementations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.ResolveMetadataReferences(Microsoft.CodeAnalysis.MetadataReferenceResolver,Microsoft.CodeAnalysis.MetadataReferenceProvider,System.Collections.Generic.List{Microsoft.CodeAnalysis.DiagnosticInfo},Microsoft.CodeAnalysis.AssemblyIdentityComparer,Microsoft.CodeAnalysis.TouchedFileLogger,Microsoft.CodeAnalysis.MetadataReferenceResolver@)">
            <summary>
            Resolves metadata references stored in command line arguments and reports errors for those that can't be resolved.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.ResolveMetadataReferencesFromArguments(Microsoft.CodeAnalysis.MetadataReferenceResolver,Microsoft.CodeAnalysis.MetadataReferenceProvider,System.Collections.Generic.List{Microsoft.CodeAnalysis.DiagnosticInfo},System.Collections.Generic.List{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Returns false if there were unresolved references in arguments, true otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.ReadFileContent(Microsoft.CodeAnalysis.CommandLineSourceFile,System.Collections.Generic.IList{Microsoft.CodeAnalysis.DiagnosticInfo},System.Text.Encoding)">
            <summary>
            Reads content of a source file.
            </summary>
            <param name="file">Source file information.</param>
            <param name="diagnostics">Storage for diagnostics.</param>
            <param name="encoding">Encoding to use or 'null' for autodetect/default</param>
            <returns>File content or null on failure.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.ReadFileContent(Microsoft.CodeAnalysis.CommandLineSourceFile,System.Collections.Generic.IList{Microsoft.CodeAnalysis.DiagnosticInfo},System.Text.Encoding,System.String@)">
            <summary>
            Reads content of a source file.
            </summary>
            <param name="file">Source file information.</param>
            <param name="diagnostics">Storage for diagnostics.</param>
            <param name="encoding">Encoding to use or 'null' for autodetect/default</param>
            <param name="normalizedFilePath">If given <paramref name="file"/> opens successfully, set to normalized absolute path of the file, null otherwise.</param>
            <returns>File content or null on failure.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.Run(System.IO.TextWriter,System.Threading.CancellationToken)">
            <summary>
            csc.exe and vbc.exe entry point.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.GetOutputFileName(Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken)">
            <summary>
            Given a compilation and a destination directory, determine three names:
              1) The name with which the assembly should be output (default = null, which indicates that the compilation output name should be used).
              2) The path of the assembly/module file (default = destination directory + compilation output name).
              3) The path of the pdb file (default = assembly/module path with ".pdb" extension).
            </summary>
            <remarks>
            C# has a special implementation that implements idiosyncratic behavior of csc.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonCompiler.FileOpen">
            <summary>
            Test hook for intercepting File.Open.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonCompiler.FileDelete">
            <summary>
            Test hook for intercepting File.Delete.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonCompiler.FileMove">
            <summary>
            Test hook for intercepting File.Move.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonCompiler.PathGetTempFileName">
            <summary>
            Test hook for intercepting Path.GetTempFileName.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.RunInteractive(System.IO.TextWriter)">
            <summary>
            csi.exe and vbi.exe entry point.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonCompiler.Culture">
            <summary>
              When overriden by a derived class, this property can override the current thread's
              CurrentUICulture property for diagnostic message resource lookups.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonCompiler.ExistingReferencesResolver">
            <summary>
            Looks for metadata references among the assembly file references given to the compilation when constructed.
            When scripts are included into a project we don't want #r's to reference other assemblies than those 
            specified explicitly in the project references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.ExistingReferencesResolver.ResolveAssemblyName(System.String)">
            <summary>
            When compiling to a file all unresolved assembly names have to match one of the file references specified on command line.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.ExistingReferencesResolver.ResolveMetadataFile(System.String,System.String)">
            <summary>
            When compiling to a file all relative paths have to match one of the file references specified on command line.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.InvalidRuleSetException">
            <summary>
            Represents errors that occur while parsing RuleSet files.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RuleSet">
            <summary>
            Represents a set of rules as specified in a rulset file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.RuleSet.FilePath">
            <summary>
            The file path of the ruleset file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.RuleSet.GeneralDiagnosticOption">
            <summary>
            The global option specified by the IncludeAll tag.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.RuleSet.SpecificDiagnosticOptions">
            <summary>
            Individual ruleids and their associated actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.RuleSet.Includes">
            <summary>
            List of rulesets included by this ruleset.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSet.#ctor(System.String,Microsoft.CodeAnalysis.ReportDiagnostic,System.Collections.Generic.IDictionary{System.String,Microsoft.CodeAnalysis.ReportDiagnostic},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.RuleSetInclude})">
            <summary>
            Create a RuleSet.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSet.WithEffectiveAction(Microsoft.CodeAnalysis.ReportDiagnostic)">
            <summary>
            Create a RuleSet with a global effective action applied on it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSet.GetEffectiveRuleSet">
            <summary>
            Get the effective ruleset after resolving all the included rulesets.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSet.GetEffectiveIncludes">
            <summary>
            Get all the files involved in resolving this ruleset.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSet.IsStricterThan(Microsoft.CodeAnalysis.ReportDiagnostic,Microsoft.CodeAnalysis.ReportDiagnostic)">
            <summary>
            Returns true if the action1 is stricter than action2.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSet.LoadEffectiveRuleSetFromFile(System.String)">
            <summary>
            Load the ruleset from the specified file. This ruleset will contain
            all the rules resolved from the includes specified in the ruleset file
            as well. See also: <seealso cref="M:Microsoft.CodeAnalysis.RuleSet.GetEffectiveIncludesFromFile(System.String)" />.
            </summary>
            <returns>
            A ruleset that contains resolved rules or null if there were errors.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSet.GetEffectiveIncludesFromFile(System.String)">
            <summary>
            Get the paths to all files contributing rules to the ruleset from the specified file.
            See also: <seealso cref="M:Microsoft.CodeAnalysis.RuleSet.LoadEffectiveRuleSetFromFile(System.String)" />.
            </summary>
            <returns>
            The full paths to included files, or an empty array if there were errors.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSet.GetDiagnosticOptionsFromRulesetFile(System.String,System.Collections.Generic.Dictionary{System.String,Microsoft.CodeAnalysis.ReportDiagnostic}@)">
            <summary>
            Parses the ruleset file at the given <paramref name="rulesetFileFullPath"/> and returns the following diagnostic options from the parsed file:
            1) A map of <paramref name="specificDiagnosticOptions"/> from rule ID to <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/> option.
            2) A global <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/> option for all rules in the ruleset file.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RuleSetInclude">
            <summary>
            Represents a Include tag in a RuleSet file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.RuleSetInclude.IncludePath">
            <summary>
            The path of the included file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.RuleSetInclude.Action">
            <summary>
            The effective action to apply on this included ruleset.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetInclude.#ctor(System.String,Microsoft.CodeAnalysis.ReportDiagnostic)">
            <summary>
            Create a RuleSetInclude given the includepath and the effective action.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetInclude.LoadRuleSet(Microsoft.CodeAnalysis.RuleSet)">
            <summary>
            Gets the RuleSet associated with this ruleset include
            </summary>
            <param name="parent">The parent of this ruleset include</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetInclude.GetIncludePath(Microsoft.CodeAnalysis.RuleSet)">
            <summary>
            Returns a full path to the include file. Relative paths are expanded relative to the current rule set file.
            </summary>
            <param name="parent">The parent of this rule set include</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RuleSetProcessor">
            <summary>
            This type is responsible for parsing a ruleset xml file and producing a <see cref="T:Microsoft.CodeAnalysis.RuleSet"/> object.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetProcessor.CreateRuleSetSchema">
            <summary>
            Static constructor for initializing the schema object to be used for schema validation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetProcessor.LoadFromFile(System.String)">
            <summary>
            Creates and loads the rule set from a file
            </summary>
            <param name="filePath">The file path to load the rule set</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetProcessor.ReadRuleSet(System.Xml.XmlNode,System.String)">
            <summary>
            Load the rule set from the XML node
            </summary>
            <param name="ruleSetNode">The rule set node from which to create a rule set object</param>
            <param name="filePath">The file path to the rule set file</param>
            <returns>A rule set object with data from the given XML node</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetProcessor.ReadRules(System.Xml.XmlNode)">
            <summary>
            Load the rules from the XML node
            </summary>
            <param name="rulesNode">The rules node from which to loop through each child rule node</param>
            <returns>A list of rule objects with data from the given XML node</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetProcessor.ReadRule(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            Load the rule from the XML node
            </summary>
            <param name="ruleNode">The rule node from which to create a rule object</param>
            <param name="analyzer">The analyzer this rule belongs to</param>
            <param name="space">The namespace this rule belongs to</param>
            <returns>A rule object with data from the given XML node</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetProcessor.ReadRuleSetInclude(System.Xml.XmlNode)">
            <summary>
            Load the included rule set from the XML node
            </summary>
            <param name="includeNode">The include node from which to create a RuleSetInclude object</param>
            <returns>A RuleSetInclude object with data from the given XML node</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetProcessor.ReadAction(System.Xml.XmlNode)">
            <summary>
            Reads the action from the given node
            </summary>
            <param name="node">The node to read the action, it can be a rule node or an include node</param>
            <returns>The rule action</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetProcessor.ReadIncludeAll(System.Xml.XmlNode)">
            <summary>
            Load the IncludedAll from the XML node
            </summary>
            <param name="includeAllNode">The IncludeAll node from which to create a IncludeAll object</param>
            <returns>A IncludeAll object with data from the given XML node</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetProcessor.ReadNonEmptyAttribute(System.Xml.XmlNode,System.String)">
            <summary>
            Reads an attribute from a node and validates that it is not empty.
            </summary>
            <param name="node">The XML node that contains the attribute</param>
            <param name="attributeName">The name of the attribute to read</param>
            <returns>The attribute value</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetProcessor.GetDefaultXmlReaderSettings">
            <summary>
            Gets the default settings to read the rulset xml file.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TouchedFileLogger">
            <summary>
            Used for logging all the paths which are "touched" (used) in any way
            in the process of compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TouchedFileLogger.AddRead(System.String)">
            <summary>
            Adds a fully-qualified path to the Logger for a read file.
            Semantics are undefined after a call to <see cref="M:Microsoft.CodeAnalysis.TouchedFileLogger.WriteReadPaths(System.IO.TextWriter)" />.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TouchedFileLogger.AddWritten(System.String)">
            <summary>
            Adds a fully-qualified path to the Logger for a written file.
            Semantics are undefined after a call to <see cref="M:Microsoft.CodeAnalysis.TouchedFileLogger.WriteWrittenPaths(System.IO.TextWriter)" />.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TouchedFileLogger.AddReadWritten(System.String)">
            <summary>
            Adds a fully-qualified path to the Logger for a read and written
            file. Semantics are undefined after a call to
            <see cref="M:Microsoft.CodeAnalysis.TouchedFileLogger.WriteWrittenPaths(System.IO.TextWriter)" />.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TouchedFileLogger.WriteReadPaths(System.IO.TextWriter)">
            <summary>
            Writes all of the paths the TouchedFileLogger to the given 
            TextWriter in upper case. After calling this method the
            logger is in an undefined state.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TouchedFileLogger.WriteWrittenPaths(System.IO.TextWriter)">
            <summary>
            Writes all of the paths the TouchedFileLogger to the given 
            TextWriter in upper case. After calling this method the
            logger is in an undefined state.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DesktopAssemblyIdentityComparer.#ctor(Microsoft.CodeAnalysis.AssemblyPortabilityPolicy)">
            <param name="policy">Assembly portability policy, usually provided through an app.config file.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DesktopAssemblyIdentityComparer.LoadFromXml(System.IO.Stream)">
            <summary>
            Loads <see cref="T:Microsoft.CodeAnalysis.AssemblyPortabilityPolicy"/> information from XML with App.config schema.
            </summary>
            <exception cref="T:System.Xml.XmlException">The stream doesn't contain a well formed XML.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="input"/> is null.</exception>
            <remarks>
            Tries to find supportPortability elements in the given XML:
            <![CDATA[
            <configuration>
               <runtime>
                  <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
                     <supportPortability PKT="7cec85d7bea7798e" enable="false"/>
                     <supportPortability PKT="31bf3856ad364e35" enable="false"/>
                  </assemblyBinding>
               </runtime>
            </configuration>
            ]]>
            
            Keeps the stream open.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DesktopAssemblyIdentityComparer.IsFrameworkAssembly(Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            Returns true if the identity is a Framework 4.5 or lower assembly.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DesktopStrongNameProvider">
            <summary>
            Provides strong name and signs source assemblies.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DesktopStrongNameProvider.#ctor(System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
            Creates an instance of <see cref="T:Microsoft.CodeAnalysis.DesktopStrongNameProvider"/>.
            </summary>
            <param name="keyFileSearchPaths">
            An ordered set of fully qualified paths which are searched when locating a cryptographic key file.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DesktopStrongNameProvider.ResolveStrongNameKeyFile(System.String)">
            <summary>
            Resolves assembly strong name key file path.
            Internal for testing.
            </summary>
            <returns>Normalized key file path or null if not found.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DesktopStrongNameProvider.SignAssembly(Microsoft.CodeAnalysis.StrongNameKeys,System.IO.Stream,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DesktopStrongNameProvider.GetPublicKey(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DesktopStrongNameProvider.Sign(System.String,System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DesktopStrongNameProvider.Sign(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommandLineAnalyzerReference">
            <summary>
            Describes a command line analyzer assembly specification.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineAnalyzerReference.FilePath">
            <summary>
            Assembly file path.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.EncodedStringText">
            <summary>
            Implementation of SourceText based on a <see cref="T:System.String"/> input
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Text.EncodedStringText.source">
            <summary>
            Underlying string on which this SourceText instance is based
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Text.EncodedStringText.sha1Checksum">
            <summary>
            Sha1 checksum of the underlying stream.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.EncodedStringText.Source">
            <summary>
            Underlying string which is the source of this SourceText instance
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Initializes an instance of <see cref="T:StringText"/> with provided bytes.
            </summary>
            <param name="stream"></param>
            <param name="encodingOpt">
            Automatically detected, if not specified: BigEndianUnicode, Unicode, UTF8
            (with or without byte order mark). Windows-1252 will be used as a fallback.
            This method will throw an InvalidDataException if the stream appears to be a binary file and 
            a DecoderFallbackException if it can't be decoded.
            </param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.EncodedStringText.Length">
            <summary>
            The length of the text represented by <see cref="T:StringText"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.EncodedStringText.Item(System.Int32)">
            <summary>
            Returns a character at given position.
            </summary>
            <param name="position">The position to get the character from.</param>
            <returns>The character.</returns>
            <exception cref="T:ArgumentOutOfRangeException">When position is negative or 
            greater than <see cref="T:"/> length.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.ToString(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Provides a string representation of the StringText located within given span.
            </summary>
            <exception cref="T:ArgumentOutOfRangeException">When given span is outside of the text range.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.DetectEncodingAndDecode(System.IO.Stream)">
            <summary>
            The following encodings will be automatically detected: 
            BigEndianUnicode, Unicode, UTF8 (with or without byte order mark).
            The default windows codepage will be used as a fallback. If the 
            default windows codepage is 1252 (Western European), we will try to
            detect if the stream is binary encoded. Does not close the stream 
            after decoding.
            </summary>
            <exception cref="T:System.IO.InvalidDataException">If a binary file is 
            detected.</exception>
            <exception cref="T:System.Text.DecoderFallbackException">If the detected 
            encoding can't decode the stream.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.DecodeIfNotBinary(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Decodes the file using the supplied <paramref name="encoding"/> if and only 
            if the file fails the heuristic for detecting a binary file. The heuristic checks
            for occurrence of two consecutive NUL (U+0000) characters in the stream, which are 
            highly unlikely to appear in a text file. Since the heuristic is applied after 
            the text has been decoded, it can be used with any encoding.
            Does not close the stream when finished.
            </summary>
            <param name="data">Data stream</param>
            <param name="encoding">Encoding to use for decode</param>
            <exception cref="T:System.IO.InvalidDataException">If the stream is binary encoded</exception>
            <returns>Decoded stream as a text string</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.Decode(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Decode the given stream using the given encoding. Does not
            close the stream afterwards.
            </summary>
            <param name="data">Data stream</param>
            <param name="encoding">Encoding to use for decode</param>
            <exception cref="T:System.Text.DecoderFallbackException">If the given 
            encoding is set to use <see cref="T:System.Text.DecoderExceptionFallback"/>
            as its fallback decoder.</exception>
            <returns>Decoded stream as a text string</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.ReadUnicodeStringFromMemoryMappedViewStream(System.IO.MemoryMappedFiles.MemoryMappedViewStream)">
            <summary>
            Read a Unicode string from a memory mapped view. The stream is not closed on exit.
            </summary>
            <param name="memoryMappedViewStream">A view over a memory mapped stream which contains a Unicode string (preceded by a Unicode BOM)</param>
            <returns>The string</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.TryDecodeMemoryStream(System.IO.MemoryStream,System.Text.Encoding,System.Boolean,System.String@)">
            <summary>
            If the MemoryStream was created with publiclyVisible=true, then we can access its buffer
            directly and save allocations in StreamReader. The input MemoryStream is not closed on exit.
            </summary>
            <exception cref="T:System.Text.DecoderFallbackException">If the given encoding is set to use <see cref="T:System.Text.DecoderExceptionFallback"/> 
            as its fallback decoder.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.TryDecodeUTF8NoBOM(System.IO.Stream,System.String@)">
            <summary>
            Assume that the input is UTF8 encoded with no byte order mark (BOM)
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.CompositeText">
            <summary>
            An SourceText that is a composite of a sequence of ITexts
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.CompositeText.CheckCopyToArguments(System.Int32,System.Char[],System.Int32,System.Int32)">
            <summary>
            Validates the arguments passed to CopyTo against the published contract.
            </summary>
            <param name="sourceIndex"></param>
            <param name="destination"></param>
            <param name="destinationIndex"></param>
            <param name="count"></param>
            <returns>True if should bother to proceed with copying.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.LinePosition">
            <summary>
            Immutable representation of a line number and position within a SourceText instance.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Text.LinePosition.Zero">
            <summary>
            A <see cref="T:LinePositions"/> that represents position 0 at line 0.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.LinePosition.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of a <see cref="T:Microsoft.CodeAnalysis.Text.LinePosition"/> with the given line and character.
            </summary>
            <param name="line">
            The line of the line position. The first line in a file is defined as line 0 (zero based line numbering).
            </param>
            <param name="character">
            The character position in the line.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="line"/> or <paramref name="character"/> is less than zero. </exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.LinePosition.Line">
            <summary>
            The line number. The first line in a file is defined as line 0 (zero based line numbering).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.LinePosition.Character">
            <summary>
            The character position within the line.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.LinePosition.op_Equality(Microsoft.CodeAnalysis.Text.LinePosition,Microsoft.CodeAnalysis.Text.LinePosition)">
            <summary>
            Determines whether two <see cref="T:Microsoft.CodeAnalysis.Text.LinePosition"/> are the same.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.LinePosition.op_Inequality(Microsoft.CodeAnalysis.Text.LinePosition,Microsoft.CodeAnalysis.Text.LinePosition)">
            <summary>
            Determines whether two <see cref="T:Microsoft.CodeAnalysis.Text.LinePosition"/> are different.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.LinePosition.Equals(Microsoft.CodeAnalysis.Text.LinePosition)">
            <summary>
            Determines whether two <see cref="T:Microsoft.CodeAnalysis.Text.LinePosition"/> are the same.
            </summary>
            <param name="other">The object to compare.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.LinePosition.Equals(System.Object)">
            <summary>
            Determines whether two <see cref="T:Microsoft.CodeAnalysis.Text.LinePosition"/> are the same.
            </summary>
            <param name="obj">The object to compare.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.LinePosition.GetHashCode">
            <summary>
            Provides a hash function for <see cref="T:LinePosition"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.LinePosition.ToString">
            <summary>
            Provides a string representation for <see cref="T:Microsoft.CodeAnalysis.Text.LinePosition"/>.
            </summary>
            <example>0,10</example>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.LinePositionSpan">
            <summary>
            Immutable span represented by a pair of line number and index within the line.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.LinePositionSpan.#ctor(Microsoft.CodeAnalysis.Text.LinePosition,Microsoft.CodeAnalysis.Text.LinePosition)">
            <summary>
            Creates <see cref="T:Microsoft.CodeAnalysis.Text.LinePositionSpan"/>.
            </summary>
            <param name="start">Start position.</param>
            <param name="end">End position.</param>
            <exception cref="T:System.ArgumentException"><paramref name="end"/> preceeds <paramref name="start"/>.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.LinePositionSpan.Start">
            <summary>
            Gets the start position of the span.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.LinePositionSpan.End">
            <summary>
            Gets the end position of the span.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.LinePositionSpan.ToString">
            <summary>
            Provides a string representation for <see cref="T:Microsoft.CodeAnalysis.Text.LinePositionSpan"/>.
            </summary>
            <example>(0,0)-(5,6)</example>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.SourceText">
            <summary>
            An abstraction of source text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.From(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Constructs a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from text in a string.
            </summary>
            <param name="text">Text.</param>
            <param name="checksum">
            SHA1 checksum of the binary representation of the text. 
            Used by the compiler to produce debug information for the corresponding document.
            The document won't be debuggable if checksum is not specified.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.From(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Constructs a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from stream content.
            </summary>
            <param name="stream">Stream.</param>
            <param name="encoding">
            Data encoding to use unless the stream starts with Byte Order Mark specifying the encoding.
            UTF8 if not specified.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="stream"/> doesn't support reading or seeking.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
            <remarks>
            Reads from the beginning of the stream. Leaves the stream open.
            Attaches SHA1 checksum of the binary content to the <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>. 
            This information is used by the compiler to produce debug information for the document.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.SourceText.Length">
            <summary>
            The length of the text in characters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.SourceText.Item(System.Int32)">
            <summary>
            Returns a character at given position.
            </summary>
            <param name="position">The position to get the character from.</param>
            <returns>The character.</returns>
            <exception cref="T:ArgumentOutOfRangeException">When position is negative or 
            greater than <see cref="T:"/> length.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
            <summary>
            Copy a range of characters from this SourceText to a destination array.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.SourceText.Container">
            <summary>
            The container of this <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.GetSubText(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> that contains the characters in the specified span of this text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.GetSubText(System.Int32)">
            <summary>
            Returns a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> that has the contents of this text including and after the start position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.Write(System.IO.TextWriter)">
            <summary>
            Write this <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> to a text writer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.Write(System.IO.TextWriter,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Write a span of text to a text writer.
            </summary>
            <param name="writer"></param>
            <param name="span"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.GetSha1ChecksumImpl">
            <summary>
            Computes SHA1 hash of the text binary representation.
            </summary>
            <remarks>
            Returns <see cref="F:System.Collections.Immutable.ImmutableArray`1.Empty"/> if the binary representation is not available.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.ToString">
            <summary>
            Provides a string representation of the SourceText.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.ToString(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Gets a string containing the characters in specified span.
            </summary>
            <exception cref="T:ArgumentOutOfRangeException">When given span is outside of the text range.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.WithChanges(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextChange})">
            <summary>
            Constructs a new SourceText from this text with the specified changes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.WithChanges(Microsoft.CodeAnalysis.Text.TextChange[])">
            <summary>
            Constructs a new SourceText from this text with the specified changes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.Replace(Microsoft.CodeAnalysis.Text.TextSpan,System.String)">
            <summary>
            Returns a new SourceText with the specified span of characters replaced by the new text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.Replace(System.Int32,System.Int32,System.String)">
            <summary>
            Returns a new SourceText with the specified range of characters replaced by the new text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.GetChangeRanges(Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Gets the set of <see cref="T:Microsoft.CodeAnalysis.Text.TextChangeRange"/> that describe how the text changed
            between this text an older version. This may be multiple detailed changes
            or a single change encompassing the entire text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.GetTextChanges(Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Gets the set of <see cref="T:TextChange"/> that describe how the text changed
            between this text and an older version. This may be multiple detailed changes 
            or a single change encompassing the entire text.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.SourceText.Lines">
            <summary>
            The collection of individual text lines.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.SourceTextContainer">
            <summary>
            An object that contains an instance of an SourceText and raises events when its current instance
            changes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.SourceTextContainer.CurrentText">
            <summary>
            The current text instance.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Text.SourceTextContainer.TextChanged">
            <summary>
            Raised when the current text instance changes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.StringBuilderText">
            <summary>
            Implementation of SourceText based on a <see cref="T:System.String"/> input
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Text.StringBuilderText.builder">
            <summary>
            Underlying string on which this SourceText instance is based
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.StringBuilderText.Builder">
            <summary>
            Underlying string which is the source of this SourceText instance
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.StringBuilderText.Length">
            <summary>
            The length of the text represented by <see cref="T:StringText"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.StringBuilderText.Item(System.Int32)">
            <summary>
            Returns a character at given position.
            </summary>
            <param name="position">The position to get the character from.</param>
            <returns>The character.</returns>
            <exception cref="T:ArgumentOutOfRangeException">When position is negative or 
            greater than <see cref="T:"/> length.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.StringBuilderText.ToString(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Provides a string representation of the StringBuilderText located within given span.
            </summary>
            <exception cref="T:ArgumentOutOfRangeException">When given span is outside of the text range.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.StringText">
            <summary>
            Implementation of SourceText based on a <see cref="T:System.String"/> input
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.StringText.Source">
            <summary>
            Underlying string which is the source of this SourceText instance
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.StringText.Length">
            <summary>
            The length of the text represented by <see cref="T:StringText"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.StringText.Item(System.Int32)">
            <summary>
            Returns a character at given position.
            </summary>
            <param name="position">The position to get the character from.</param>
            <returns>The character.</returns>
            <exception cref="T:ArgumentOutOfRangeException">When position is negative or 
            greater than <see cref="T:"/> length.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.StringText.ToString(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Provides a string representation of the StringText located within given span.
            </summary>
            <exception cref="T:ArgumentOutOfRangeException">When given span is outside of the text range.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.SubText">
            <summary>
            An SourceText that represents a subrange of another SourceText.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.TextChange">
            <summary>
            Describes a single change when a particular span is replaced with a new text.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextChange.Span">
            <summary>
            The original span of the changed text. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextChange.NewText">
            <summary>
            The new text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextChange.#ctor(Microsoft.CodeAnalysis.Text.TextSpan,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:TextChange"/>
            </summary>
            <param name="span">The original span of the changed text.</param>
            <param name="newText">The new text.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextChange.ToString">
            <summary>
            Provides a string representation for <see cref="T:TextChange"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextChange.op_Implicit(Microsoft.CodeAnalysis.Text.TextChange)~Microsoft.CodeAnalysis.Text.TextChangeRange">
            <summary>
            Converts a <see cref="T:Microsoft.CodeAnalysis.Text.TextChange"/> to a <see cref="T:Microsoft.CodeAnalysis.Text.TextChangeRange"/>.
            </summary>
            <param name="change"></param>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Text.TextChange.NoChanges">
            <summary>
            An empty set of changes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.TextChangeEventArgs">
            <summary>
            Represents state for a TextChanged event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextChangeEventArgs.#ctor(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Text.SourceText,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextChangeRange})">
            <summary>
            Initializes an instance of <see cref="T:Microsoft.CodeAnalysis.Text.TextChangeEventArgs"/>.
            </summary>
            <param name="oldText">The text before the change.</param>
            <param name="newText">The text after the change.</param>
            <param name="changes">A non-empty set of ranges for the change.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextChangeEventArgs.#ctor(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Text.TextChangeRange[])">
            <summary>
            Initializes an instance of <see cref="T:Microsoft.CodeAnalysis.Text.TextChangeEventArgs"/>.
            </summary>
            <param name="oldText">The text before the change.</param>
            <param name="newText">The text after the change.</param>
            <param name="changes">A non-empty set of ranges for the change.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextChangeEventArgs.OldText">
            <summary>
            Gets the text before the change.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextChangeEventArgs.NewText">
            <summary>
            Gets the text after the change.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextChangeEventArgs.Changes">
            <summary>
            Gets the set of ranges for the change.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.TextChangeRange">
            <summary>
            Represents the change to a span of text.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextChangeRange.Span">
            <summary>
            The span of text before the edit which is being changed
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextChangeRange.NewLength">
            <summary>
            Width of the span after the edit.  A 0 here would represent a delete
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextChangeRange.#ctor(Microsoft.CodeAnalysis.Text.TextSpan,System.Int32)">
            <summary>
            Initializes a new instance of <see cref="T:TextChangeRange"/>.
            </summary>
            <param name="span"></param>
            <param name="newLength"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextChangeRange.Equals(Microsoft.CodeAnalysis.Text.TextChangeRange)">
            <summary>
            Compares current instance of <see cref="T:TextChangeRange"/> to another.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextChangeRange.Equals(System.Object)">
            <summary>
            Compares current instance of <see cref="T:TextChangeRange"/> to another.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextChangeRange.GetHashCode">
            <summary>
            Provides hash code for current instnce of <see cref="T:TextChangeRange"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextChangeRange.op_Equality(Microsoft.CodeAnalysis.Text.TextChangeRange,Microsoft.CodeAnalysis.Text.TextChangeRange)">
            <summary>
            Determines if two instances of <see cref="T:TextChangeRange"/> are same.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextChangeRange.op_Inequality(Microsoft.CodeAnalysis.Text.TextChangeRange,Microsoft.CodeAnalysis.Text.TextChangeRange)">
            <summary>
            Determines if two instances of <see cref="T:TextChangeRange"/> are different.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Text.TextChangeRange.NoChanges">
            <summary>
            An empty set of changes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextChangeRange.Collapse(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextChangeRange})">
            <summary>
            Collapse a set of <see cref="T:Microsoft.CodeAnalysis.Text.TextChangeRange"/>s into a single encompassing range.  If
            the set of ranges provided is empty, an empty range is returned.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.TextLine">
            <summary>
            Information about the character boundaries of a single line of text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextLine.FromSpan(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.Text.TextLine"/> instance.
            </summary>
            <param name="text">The source text.</param>
            <param name="span">The span of the line.</param>
            <returns>An instance of <see cref="T:Microsoft.CodeAnalysis.Text.TextLine"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The span does not represent a text line.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextLine.Text">
            <summary>
            Gets the source text.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextLine.LineNumber">
            <summary>
            Gets the zero-based line number.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextLine.Start">
            <summary>
            Gets the start position of the line.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextLine.End">
            <summary>
            Gets the end position of the line not including the line break.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextLine.EndIncludingLineBreak">
            <summary>
            Gets the end position of the line including the line break.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextLine.Span">
            <summary>
            Gets the line span not including the line break.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextLine.SpanIncludingLineBreak">
            <summary>
            Gets the line span including the line break.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.TextLineCollection">
            <summary>
            Abstract base class for <see cref="T:Microsoft.CodeAnalysis.Text.TextLine"/> collections.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextLineCollection.Count">
            <summary>
            The count of <see cref="T:Microsoft.CodeAnalysis.Text.TextLine"/> items in the collection
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextLineCollection.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Text.TextLine"/> item at the specified index.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextLineCollection.IndexOf(System.Int32)">
            <summary>
            The index of the TextLine that encompasses the character position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextLineCollection.GetLineFromPosition(System.Int32)">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.Text.TextLine"/> that encompasses the character position.
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextLineCollection.GetLinePosition(System.Int32)">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.Text.LinePosition"/> corresponding to a character position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextLineCollection.GetLinePositionSpan(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Convert a <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> to a <see cref="T:Microsoft.CodeAnalysis.Text.LinePositionSpan"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextLineCollection.GetPosition(Microsoft.CodeAnalysis.Text.LinePosition)">
            <summary>
            Convert a <see cref="T:Microsoft.CodeAnalysis.Text.LinePosition"/> to a position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextLineCollection.GetTextSpan(Microsoft.CodeAnalysis.Text.LinePositionSpan)">
            <summary>
            Convert a <see cref="T:Microsoft.CodeAnalysis.Text.LinePositionSpan"/> to <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.TextSpan">
            <summary>
            Immutable abstract representation of a span of text.  For example, in an error diagnostic that reports a
            location, it could come from a parsed string, text from a tool editor buffer, etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a TextSpan instance beginning with the position Start and having the Length
            specified with length.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextSpan.Start">
            <summary>
            Start point of the Span.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextSpan.End">
            <summary>
            End of the span.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextSpan.Length">
            <summary>
            Length of the span.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextSpan.IsEmpty">
            <summary>
            Determines whether or not the span is empty.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.Contains(System.Int32)">
            <summary>
            Determines whether the position lies within the span.
            </summary>
            <param name="position">
            The position to check.
            </param>
            <returns>
            <c>true</c> if the position is greater than or equal to Start and strictly less 
            than End, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.Contains(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Determines whether <paramref name="span"/> falls completely within this span.
            </summary>
            <param name="span">
            The span to check.
            </param>
            <returns>
            <c>true</c> if the specified span falls completely within this span, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.OverlapsWith(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Determines whether <paramref name="span"/> overlaps this span. Two spans are considered to overlap 
            if they have positions in common and neither is empty. Empty spans do not overlap with any 
            other span.
            </summary>
            <param name="span">
            The span to check.
            </param>
            <returns>
            <c>true</c> if the spans overlap, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.Overlap(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Returns the overlap with the given span, or null if there is no overlap.
            </summary>
            <param name="span">
            The span to check.
            </param>
            <returns>
            The overlap of the spans, or null if the overlap is empty.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.IntersectsWith(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Determines whether <paramref name="span"/> intersects this span. Two spans are considered to 
            intersect if they have positions in common or the end of one span 
            coincides with the start of the other span.
            </summary>
            <param name="span">
            The span to check.
            </param>
            <returns>
            <c>true</c> if the spans intersect, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.IntersectsWith(System.Int32)">
            <summary>
            Determines whether <paramref name="position"/> intersects this span. 
            A position is considered to intersect if it is between the start and
            end positions (inclusive) of this span.
            </summary>
            <param name="position">
            The position to check.
            </param>
            <returns>
            <c>true</c> if the position intersects, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.Intersection(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Returns the intersection with the given span, or null if there is no intersection.
            </summary>
            <param name="span">
            The span to check.
            </param>
            <returns>
            The intersection of the spans, or null if the intersection is empty.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.FromBounds(System.Int32,System.Int32)">
            <summary>
            Creates a new <see cref="T:TextSpan"/> from <param name="start" /> and <param
            name="end"/> positions as opposed to a position and length.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.op_Equality(Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Determines if two instances of <see cref="T:TextSpan"/> are the same.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.op_Inequality(Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Determines if two instances of <see cref="T:TextSpan"/> are different.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.Equals(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Determines if current instance of <see cref="T:TextSpan"/> is equal to another.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.Equals(System.Object)">
            <summary>
            Determines if current instance of <see cref="T:TextSpan"/> is equal to another.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.GetHashCode">
            <summary>
            Produces a hash code for <see cref="T:TextSpan"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.ToString">
            <summary>
            Provides a string representation for <see cref="T:TextSpan"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.CompareTo(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Compares current instance of <see cref="T:TextSpan"/> with another.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.TextUtilities">
            <summary>
            Holder for common Text Utility functions and values
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextUtilities.Create(System.Action{System.IO.TextWriter})">
            <summary>
            Create a new SourceText instance from a function that writes to a TextWriter
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextUtilities.GetStartAndLengthOfLineBreakEndingAt(Microsoft.CodeAnalysis.Text.SourceText,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Return startLineBreak = index-1, lengthLineBreak = 2   if there is a \r\n at index-1
            Return startLineBreak = index,   lengthLineBreak = 1   if there is a 1-char newline at index
            Return startLineBreak = index+1, lengthLineBreak = 0   if there is no newline at index.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextUtilities.IsAnyLineBreakCharacter(System.Char)">
            <summary>
            Determine if the character in question is any line break character
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataCache">
             <summary>
             Manages cache of the following information for Portable Executables loaded from files.
            
             For assemblies - a map from file name and timestamp to: 
                 1) A weak reference to the corresponding PEAssembly object;
                 2) A list of weak references to instances of VB/CS AssemblySymbols based on the PEAssembly object.
            
             For modules - a map from file name and timestamp to a weak reference to the corresponding PEModule object
             
             For analyzer assemblies - a map from file name and timestamp to a weak reference to the diagnostic analyzers defined in the assembly.
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataCache.assembliesFromFiles">
            <summary>
            Global cache for assemblies imported from files.
            The cache must be locked for the duration of read/write operations, see CacheLockObject property.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataCache.modulesFromFiles">
            <summary>
            Global cache for net-modules imported from files.
            The cache must be locked for the duration of read/write operations, see CacheLockObject property.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataCache.analyzersFromFiles">
            <summary>
            Global cache for diagnostic analyzers imported from analyzer assembly files.
            The cache must be locked for the duration of read/write operations, see CacheLockObject property.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataCache.compactTimer">
            <summary>
            Timer triggering compact operation for metadata cache.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataCache.compactTimerPeriod">
            <summary>
            Period at which the timer is firing (30 seconds).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataCache.compactInProgress">
            <summary>
            compactTimer's procedure is in progress.
            Used to prevent multiple instances running in parallel.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataCache.compactTimerIsOn">
            <summary>
            compactTimer is on, i.e. will fire.
            
            This field is changed to 'yes' only by EnableCompactTimer(),
            and is changed to 'no' only by CompactCache().
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataCache.compactCollectionCount">
            <summary>
            Collection count last time the cache was compacted.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataCache.Guard">
            <summary>
            Lock that must be acquired for the duration of read/write operations on MetadataCache.
            
            Internal for testing.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataCache.GetCollectionCount">
            <summary>
            Return amount of GC collections occurred so far.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataCache.CompactCache(System.Object)">
            <summary>
            Called by compactTimer to compact the cache.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataCache.EnableCompactTimer">
            <summary>
            Trigger timer every 30 seconds.
            Cache must be locked before calling this method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataCache.CompactTimerIsOn">
            <summary>
            For test purposes only.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataCache.TriggerCacheCompact">
            <summary>
            Trigger compact operation for the cache, meant to be used for test purpose only.
            Locking the cache prior to calling this method is a good way to get into a deadlock.
            
            For test purposes only!!!
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataCache.CompactCacheOfAssemblies">
            <summary>
            Called by compactTimer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataCache.CompactCacheOfModules">
            <summary>
            Called by compactTimer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataCache.CompactCacheOfAnalyzers">
            <summary>
            Called by compactTimer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataCache.AssembliesFromFiles">
            <summary>
            Global cache for assemblies imported from files.
            The cache must be locked for the duration of read/write operations, see CacheLockObject property.
            Internal accessibility is for test purpose only.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataCache.AssemblyKeys">
            <summary>
            For test purposes only.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataCache.ModulesFromFiles">
            <summary>
            Global cache for net-modules imported from files.
            The cache must be locked for the duration of read/write operations, see CacheLockObject property.
            Internal accessibility is for test purpose only.
            </summary>
            <remarks></remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataCache.ModuleKeys">
            <summary>
            For test purposes only.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataCache.AnalyzersFromFiles">
            <summary>
            Global cache for analyzers imported from files.
            The cache must be locked for the duration of read/write operations, see CacheLockObject property.
            Internal accessibility is for test purpose only.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataCache.AnalyzerAssemblyKeys">
            <summary>
            For test purposes only.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataCache.CleaningCacheLock">
            <summary>
            This class is meant to be used for test purpose only.
            It locks MetadataCache until the instance is disposed.
            Upon locking, the cache is swapped with an empty cache,
            original cache is restored before the cache is unlocked.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataCache.CleaningCacheLock.CleanCaches">
            <summary>
            Clean global metadata caches, meant to be used for test purpose only.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataCache.GetOrCreateFromFile(System.String,Microsoft.CodeAnalysis.MetadataImageKind)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataCache.GetOrCreateAssemblyFromFile(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataCache.GetOrCreateModuleFromFile(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataFileReference">
            <summary>
            Represents metadata stored in a file.
            </summary>
            <remarks>
            Metadata image is read from the file, owned by the reference, and doesn't change 
            since the reference is accessed by the compiler until the reference object is garbage collected.
            During this time the file is open and its content is read-only.
            
            If you need to manage the lifetime of the metadata (and the file stream) explicitly use <see cref="T:Microsoft.CodeAnalysis.MetadataImageReference"/> or 
            implement a custom subclass of <see cref="T:Microsoft.CodeAnalysis.PortableExecutableReference"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataFileReference.GetMetadataImpl">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataFileReferenceProvider">
            <summary>
            An extensible mechanism for providing <see cref="T:Microsoft.CodeAnalysis.PortableExecutableReference"/>
            to services that require them.
            </summary>
            <remarks>Used to create <see cref="T:Microsoft.CodeAnalysis.PortableExecutableReference"/> when 
            processing interactive code directives that load .NET metadata.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataFileReferenceProvider.GetReference(System.String,Microsoft.CodeAnalysis.MetadataReferenceProperties)">
            <summary>
            Maps "metadata about .NET metadata" to <see cref="T:Microsoft.CodeAnalysis.PortableExecutableReference"/>. 
            </summary>
            <param name="resolvedPath">Path returned by <see cref="M:Microsoft.CodeAnalysis.MetadataReferenceResolver.ResolveReference(System.String,System.String)"/>.</param>
            <param name="properties">Metadata reference properties.</param>
            <returns>A <see cref="T:Microsoft.CodeAnalysis.PortableExecutableReference"/> corresponding to the <paramref name="resolvedPath"/> and
            <paramref name="properties"/> parameters.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataFileReferenceResolver">
            <summary>
            Resolves metadata references specified in source code (#r directives).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataFileReferenceResolver.#ctor(System.Collections.Immutable.ImmutableArray{System.String},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.MetadataFileReferenceResolver"/> class.
            </summary>
            <param name="searchPaths">An ordered set of fully qualified 
            paths which are searched when resolving assembly names.</param>
            <param name="baseDirectory">Directory used when resolving relative paths.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataFileReferenceResolver.#ctor(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.MetadataFileReferenceResolver"/> class.
            </summary>
            <param name="searchPaths">An ordered set of fully qualified 
            paths which are searched when resolving assembly names.</param>
            <param name="baseDirectory">Directory used when resolving relative paths.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataFileReferenceResolver.SearchPaths">
            <summary>
            Search paths used when resolving metadata references.
            </summary>
            <remarks>
            All search paths are absolute.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataFileReferenceResolver.BaseDirectory">
            <summary>
            Directory used for resolution of relative paths.
            A full directory path or null if not available.
            </summary>
            <remarks>
            This directory is only used if the base directory isn't implied by the context within which the path is being resolved.
            
            It is used, for example, when resolving a strong name key file specified in <see cref="T:System.Reflection.AssemblyKeyFileAttribute"/>,
            or a metadata file path specified in <see cref="T:Microsoft.CodeAnalysis.MetadataFileReference"/>.
            
            Resolution of a relative path that needs the base directory fails if the base directory is null.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataFileReferenceResolver.ResolveReference(System.String,System.String)">
            <summary>
            Resolves a metadata reference that is a path or an assembly name.
            </summary>
            <param name="reference">Reference path.</param>
            <param name="baseFilePath">
            The base file path to use to resolve relative paths against.
            Null to use the <see cref="P:Microsoft.CodeAnalysis.MetadataFileReferenceResolver.BaseDirectory"/> as a base for relative paths.
            </param>
            <returns>
            Normalized absolute path to the referenced file or null if it can't be resolved.
            </returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SourceFileResolver">
            <summary>
            Resolves references to source files specified in source code.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.XmlFileResolver">
            <summary>
            Resolves references to XML files specified in the source.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.XmlFileResolver.ResolveReference(System.String,System.String)">
            <summary>
            Resolves XML document file path.
            </summary>
            <param name="path">
            Value of the "file" attribute of an &lt;include&gt; documentation comment element.
            </param>
            <param name="baseFilePath">
            Path of the source file (<see cref="P:Microsoft.CodeAnalysis.SyntaxTree.FilePath"/>) or XML document that contains the <paramref name="path"/>.
            If not null used as a base path of <paramref name="path"/>, if <paramref name="path"/> is relative.
            If <paramref name="baseFilePath"/> is relative <see cref="P:Microsoft.CodeAnalysis.XmlFileResolver.BaseDirectory"/> is used as the base path of <paramref name="baseFilePath"/>.
            </param>
            <returns>Normalized XML document file path or null if not found.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Optional`1">
            <summary>
            Represents a value type that can be assigned null.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Optional`1.#ctor(`0)">
            <summary>
            Initializes a new instance to the specified value.
            </summary>
            <param name="value"></param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Optional`1.HasValue">
            <summary>
            Gets a value indicating whether the current object has a value.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Optional`1.Value">
            <summary>
            Gets the value of the current object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Optional`1.op_Implicit(`0)~Microsoft.CodeAnalysis.Optional{`0}">
            <summary>
            Creates a new object initialized to a specified value. 
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.OutputKind">
            <summary>
            Specifies output assembly knids generated by compiler.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OutputKind.ConsoleApplication">
            <summary>
            An .exe with an entry point and a console.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OutputKind.WindowsApplication">
            <summary>
            An .exe with an entry point but no console.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OutputKind.DynamicallyLinkedLibrary">
            <summary>
            A .dll file.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OutputKind.NetModule">
            <summary>
            A .netmodule file.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OutputKind.WindowsRuntimeMetadata">
            <summary>
            A .winmdobj file.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OutputKind.WindowsRuntimeApplication">
            <summary>
            An .exe that can run in an app container.
            </summary>
            <remarks>
            Equivalent to a WindowsApplication, but with an extra bit set in the Portable Executable file
            so that the application can only be run in an app container.
            Also known as a "Windows Store app".
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonReferenceManager`2">
            <summary>
            The base class for language specific assembly managers.
            </summary>
            <typeparam name="TCompilation">Language specific representation for a compilation</typeparam>
            <typeparam name="TAssemblySymbol">Language specific representation for an assembly symbol.</typeparam>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyData">
            <summary>
            Information about an assembly, used as an input for the Binder class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyData.Identity">
            <summary>
            Identity of the assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyData.AssemblyReferences">
            <summary>
            Identity of assemblies referenced by this assembly.
            References should always be returned in the same order.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyData.AvailableSymbols">
            <summary>
            The sequence of AssemblySymbols the Binder can choose from.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyData.IsMatchingAssembly(`1)">
            <summary>
            Check if provided AssemblySymbol is created for assembly described by this instance. 
            This method is expected to return true for every AssemblySymbol returned by 
            AvailableSymbols property.
            </summary>
            <param name="assembly">
            The AssemblySymbol to check.
            </param>
            <returns>Boolean.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyData.BindAssemblyReferences(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CommonReferenceManager{`0,`1}.AssemblyData},Microsoft.CodeAnalysis.AssemblyIdentityComparer)">
            <summary>
            Resolve assembly references against assemblies described by provided AssemblyData objects. 
            In other words, match assembly identities returned by AssemblyReferences property against 
            assemblies described by provided AssemblyData objects.
            </summary>
            <param name="assemblies">An array of AssemblyData objects to match against.</param>
            <param name="assemblyIdentityComparer">Used to compare assembly identities.</param>
            <returns>
            For each assembly referenced by this assembly (<see cref="P:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyData.AssemblyReferences"/>) 
            a description of how it binds to one of the input assemblies.
            </returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyReferenceBinding">
            <summary>
            Result of binding an AssemblyRef to an AssemblyDef. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyReferenceBinding.#ctor(Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            Failed binding.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyReferenceBinding.#ctor(Microsoft.CodeAnalysis.AssemblyIdentity,System.Int32,System.Int32)">
            <summary>
            Successful binding.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyReferenceBinding.BoundToAssemblyBeingBuilt">
            <summary>
            Returns true if the reference was matched with the identity of the assembly being built.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyReferenceBinding.IsBound">
            <summary>
            True if the definition index is available (reference was successfully matched with the definition).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyReferenceBinding.VersionDifference">
            <summary>
             0 if the reference is equivalent to the definition.
            -1 if version of the matched definition is lower than version of the reference, but the reference otherwise matches the definition.
            +1 if version of the matched definition is higher than version of the reference, but the reference otherwise matches the definition.
              
            Undefined unless <see cref="P:IsBound"/> is true.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyReferenceBinding.DefinitionIndex">
            <summary>
            Index into assembly definition list.
            Undefined unless <see cref="P:IsBound"/> is true.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyReferenceCandidate">
            <summary>
            Private helper class to capture information about AssemblySymbol instance we 
            should check for suitability. Used by the Bind method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyReferenceCandidate.DefinitionIndex">
            <summary>
            An index of the AssemblyData object in the input array. AssemblySymbol instance should 
            be checked for suitability against assembly described by that object, taking into account 
            assemblies described by other AssemblyData objects in the input array.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyReferenceCandidate.AssemblySymbol">
            <summary>
            AssemblySymbol instance to check for suitability.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyReferenceCandidate.#ctor(System.Int32,`1)">
            <summary>
            Convenience constructor to initialize fields of this structure.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonReferenceManager`2.BoundInputAssembly">
            <summary>
            Result of binding an input assembly and its references. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.BoundInputAssembly.AssemblySymbol">
            <summary>
            Suitable AssemblySymbol instance for the corresponding assembly, 
            null reference if none is available/found.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.BoundInputAssembly.ReferenceBinding">
            <summary>
            For each AssemblyRef of this AssemblyDef specifies which AssemblyDef matches the reference.
            </summary>
            <remarks>
            Result of resolving assembly references of the corresponding assembly 
            against provided set of assemblies. Essentially, this is an array returned by
            AssemblyData.BindAssemblyReferences method. 
            
            Each element describes the assembly the corresponding reference of the input assembly 
            is bound to.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.Bind(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CommonReferenceManager{`0,`1}.AssemblyData},System.Boolean@,System.Int32@)">
             <summary>
             For the given set of AssemblyData objects, do the following:
                1) Resolve references from each assembly against other assemblies in the set.
                2) Choose suitable AssemblySymbol instance for each AssemblyData object.
            
             The first element (index==0) of the assemblies array represents the assembly being built.
             One can think about the rest of the items in assemblies array as assembly references given to the compiler to
             
             build executable for the assembly being built. 
             
             </summary>
             
             <param name="assemblies">
             The set of AssemblyData objects describing assemblies, for which this method should
             resolve references and find suitable AssemblySymbols. This array is not modified by the
             method.
             </param>
             <param name="hasCircularReference">
             True if the assembly being compiled is indirectly referenced thru some of its own references.
             </param>
             <param name="corLibraryIndex">
             The definition index of the COR library.
             </param>
             <returns>
             An array of Binding structures describing the result. It has the same amount of items as
             the input assemblies array, Binding structure for each input AssemblyData object resides
             at the same position.
             
             Each Binding structure contains the following data:
             
             -    Suitable AssemblySymbol instance for the corresponding assembly, 
                 null reference if none is available/found. Always null for the first element, which corresponds to the assembly being built.
            
             -    Result of resolving assembly references of the corresponding assembly 
                 against provided set of assembly definitions. Essentially, this is an array returned by
                 AssemblyData.BindAssemblyReferences method.
             </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.InternalsMayBeVisibleToAssemblyBeingCompiled(System.String,Microsoft.CodeAnalysis.PEAssembly)">
            <summary>
            Determines if it is possible that <paramref name="assembly"/> gives internals
            access to assembly <paramref name="compilationName"/>. It does not make a conclusive
            determination of visibility because the compilation's strong name key is not supplied.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.GetActualBoundReferencesUsedBy(`1)">
            <summary>
            Return AssemblySymbols referenced by the input AssemblySymbol. The AssemblySymbols must correspond 
            to the AssemblyNames returned by AssemblyData.AssemblyReferences property. If reference is not 
            resolved, null reference should be returned in the corresponding item. 
            </summary>
            <param name="assemblySymbol"></param>
            The target AssemblySymbol instance.
            <returns>
            An array of AssemblySymbols referenced by the input AssemblySymbol.
            Implementers may return cached array, Binder does not mutate it.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.GetNoPiaResolutionAssemblies(`1)">
            <summary>
            Return collection of assemblies involved in canonical type resolution of
            NoPia local types defined within target assembly. In other words, all 
            references used by previous compilation referencing the target assembly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.IsLinked(`1)">
            <summary>
            Assembly is /l-ed by compilation that is using it as a reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.GetCorLibrary(`1)">
            <summary>
            Get Assembly used as COR library for the candidate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.CheckPropertiesConsistency(Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Checks if the properties of <paramref name="duplicateReference"/> are compatible with properties of <paramref name="primaryReference"/>.
            Reports inconsistencies to the given diagnostic bag.
            </summary>
            <returns>True if the properties are compatible and hence merged, false if the duplicate reference should not merge it's properties with primary reference.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.WeakIdentityPropertiesEquivalent(Microsoft.CodeAnalysis.AssemblyIdentity,Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            Called to compare two weakly named identities with the same name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.ResolveMetadataReferences(`0,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.MetadataReference}@,System.Collections.Generic.IDictionary{System.String,Microsoft.CodeAnalysis.MetadataReference}@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.MetadataReference}@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CommonReferenceManager{`0,`1}.AssemblyData}@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.PEModule}@,Microsoft.CodeAnalysis.DiagnosticBag)">
             <summary>
             Resolves given metadata references to assemblies and modules.
             </summary>
             <param name="compilation">The compilation whose references are being resolved.</param>
             <param name="references">List where to store resolved references. References from #r directives will follow references passed to the compilation constructor.</param>
             <param name="boundReferenceDirectiveMap">Maps #r values to successuflly resolved metadata references. Does not contain values that failed to resolve.</param>
             <param name="boundReferenceDirectives">Unique metadata references resolved from #r directives.</param>
             <param name="assemblies">List where to store information about resolved assemblies to.</param>
             <param name="modules">List where to store information about resolved modules to.</param>
             <param name="diagnostics">Diagnostic bag where to report resolution errors.</param>
             <returns>
             Maps index to <paramref name="references"/> to an index of a resolved assembly or module in <paramref name="assemblies"/> or <paramref name="modules"/>, respectively.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.GetMetadata(Microsoft.CodeAnalysis.PortableExecutableReference,Microsoft.CodeAnalysis.CommonMessageProvider,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Creates or gets metadata for PE reference.
            </summary>
            <remarks>
            If any of the following exceptions: <see cref="T:System.BadImageFormatException"/>, <see cref="T:System.IO.FileNotFoundException"/>, <see cref="T:System.IO.IOException"/>,
            are thrown while reading the metadata file, the exception is caught and an appropriate diagnostic stored in <paramref name="diagnostics"/>.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonReferenceManager`2.MetadataReferenceEqualityComparer">
            <summary>
            Decides whether 2 references are interchangeable when used in the same compilation.
            PE references are interchangeable if they have the same non-null full path, compilation references if they refer to the same compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.MergeReferenceProperties(Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.DiagnosticBag,System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.ArrayBuilder{System.String}}@)">
            <summary>
            Merges aliases of the first observed reference (<paramref name="primaryReference"/>) with aliases specified for an equivalent reference (<paramref name="newReference"/>).
            Empty alias list is considered to be the same as a list containing "global", since in both cases C# allows unqualified access to the symbols.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.AddAssembly(Microsoft.CodeAnalysis.CommonReferenceManager{`0,`1}.AssemblyData,System.Int32,Microsoft.CodeAnalysis.CommonReferenceManager{`0,`1}.ResolvedReference[],Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CommonReferenceManager{`0,`1}.AssemblyData}@)">
            <remarks>
            Caller is responsible for freeing any allocated ArrayBuilders.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.AddModule(Microsoft.CodeAnalysis.PEModule,System.Int32,Microsoft.CodeAnalysis.CommonReferenceManager{`0,`1}.ResolvedReference[],Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.PEModule}@)">
            <remarks>
            Caller is responsible for freeing any allocated ArrayBuilders.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.ResolveReferenceDirective(System.String,Microsoft.CodeAnalysis.Location,`0)">
            <summary>
            For each given directive return a bound PE reference, or null if the binding fails.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.ResolveReferencedAssembly(Microsoft.CodeAnalysis.AssemblyIdentity,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CommonReferenceManager{`0,`1}.AssemblyData},Microsoft.CodeAnalysis.AssemblyIdentityComparer,System.Boolean)">
            <summary>
            Used to match AssemblyRef with AssemblyDef.
            </summary>
            <param name="definitions">Array of definition identities to match against.</param>
            <param name="reference">Reference identity to resolve.</param>
            <param name="assemblyIdentityComparer">Assembly identity comparer.</param>
            <param name="okToResolveAgainstCompilationBeingCreated"> Is it Ok to resolve reference against the compilation we are creating?</param>
            <returns>
            Returns an index the reference is bound.
            </returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.SimpleAssemblyName">
            <summary>
            If the compilation being built represents an assembly its assembly name.
            If the compilation being built represents a module, the name of the 
            containing assembly or <see cref="F:Compilation.UnspecifiedModuleAssemblyName"/>
            if not specified (/moduleassemblyname command line option).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.IdentityComparer">
            <summary>
            Used to compares assembly identities. 
            May implement unification and portability policies specific to the target platform.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.ObservedMetadata">
            <summary>
            Metadata observed by the compiler.
            May be shared accoss multiple Reference Managers.
            Access only under lock(<see cref="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.ObservedMetadata"/>).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.isBound">
            <summary>
            Once this is non-zero the state of the manager is fully initialized and immutable.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.lazyHasCircularReference">
            <summary>
            True if the compilation has a reference that refers back to the assembly being compiled.
            </summary>
            <remarks>
            If we have a circular reference the bound references can't be shared with other compilations.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.lazyReferencedAssembliesMap">
            <summary>
            A map from a metadata reference to an AssemblySymbol used for it. Do not access
            directly, use <see cref="P:Microsoft.CodeAnalysis.CommonReferenceManager`2.ReferencedAssembliesMap"/> property instead.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.lazyReferencedModuleIndexMap">
            <summary>
            A map from a net-module metadata reference to the index of the corresponding module
            symbol in the source assembly symbol for the current compilation.
            </summary>
            <remarks>
            Subtract one from the index (for the manifest module) to find the corresponding elements
            of lazyReferencedModules and lazyReferencedModulesReferences.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.lazyReferenceDirectiveMap">
            <summary>
            Maps reference string used in #r directive to a resolved metadata reference.
            If multiple #r's use the same value as a reference the resolved metadata reference is the same as well.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.lazyDirectiveReferences">
            <summary>
            Array of unique bound #r references.
            </summary>
            <remarks>
            The references are in the order they appear in syntax trees. This order is currently preserved 
            as syntax trees are added or removed, but we might decide to share reference manager between compilations
            with different order of #r's. It doesn't seem this would be an issue since all #r's within the compilation
            has the same "priority" with respect to each other.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.lazyDiagnostics">
            <summary>
            Diagnostics produced during reference resolution and binding.
            </summary>
            <remarks>
            When reporting diagnostics be sure not to include any information that can't be shared among 
            compilations that share the same reference manager (such as full identity of the compilation, 
            simple assembly name is ok).
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.lazyCorLibraryOpt">
            <summary>
            COR library symbol, or null if the compilation itself is the COR library.
            </summary>
            <remarks>
            If the compilation being built is the COR library we don't want to store its source assembly symbol 
            here since we wouldn't be able to share the state among subsequent compilations that are derived from it
            (each of them has its own source assembly symbol).
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.lazyReferencedModules">
            <summary>
            Standalone modules referenced by the compilation (doesn't include the manifest module of the compilation).
            </summary>
            <remarks>
            lazyReferencedModules[i] corresponds to lazyReferencedModulesReferences[i].
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.lazyReferencedModulesReferences">
            <summary>
            References of standalone modules referenced by the compilation (doesn't include the manifest module of the compilation).
            </summary>
            <remarks>
            lazyReferencedModules[i] corresponds to lazyReferencedModulesReferences[i].
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.lazyReferencedAssemblies">
            <summary>
            Assemblies referenced directly by the source module of the compilation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.lazyUnifiedAssemblies">
            <summary>
            Unified assemblies referenced directly by the source module of the compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssertUnbound">
            <summary>
            Call only while holding <see cref="P:SymbolCacheAndReferenceManagerStateGuard"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.InitializeNoLock(System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.CommonReferenceManager{`0,`1}.ReferencedAssembly},System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.MetadataReference,System.Int32},System.Collections.Generic.IDictionary{System.String,Microsoft.CodeAnalysis.MetadataReference},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.MetadataReference},System.Boolean,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic},`1,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.PEModule},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ModuleReferences{`1}},System.Collections.Immutable.ImmutableArray{`1},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.UnifiedAssembly{`1}})">
            <summary>
            Call only while holding <see cref="P:SymbolCacheAndReferenceManagerStateGuard"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager.SymbolCacheAndReferenceManagerStateGuard">
            <summary>
            Must be acquired whenever the following data are about to be modified:
            - Compilation.lazyAssemblySymbol
            - Compilation.referenceManager
            - ReferenceManager state
            - <see cref="F:Microsoft.CodeAnalysis.AssemblyMetadata.CachedSymbols"/>
            - <see cref="F:Compilation.retargetingAssemblySymbols"/>
            
            All the above data should be updated at once while holding this lock.
            Once lazyAssemblySymbol is set the Compilation.referenceManager field and ReferenceManager
            state should not change.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager.GetReferencedAssemblies">
            <summary>
            Enumerates all referenced assemblies.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ModuleReferences`1">
            <summary>
            A record of the assemblies referenced by a module (their identities, symbols, and unification).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ModuleReferences`1.Names">
            <summary>
            Identities of referenced assemblies (those that are or will be emitted to metadada).
            </summary>
            <remarks>
            Names[i] is the identity of assembly Symbols[i].
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ModuleReferences`1.Symbols">
            <summary>
            Assembly symbols that the identities are resolved against.
            </summary>
            <remarks>
            Names[i] is the identity of assembly Symbols[i].
            Unresolved references are represented as MissingAssemblySymbols.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ModuleReferences`1.UnifiedAssemblies">
            <summary>
            A subset of <see cref="F:Microsoft.CodeAnalysis.ModuleReferences`1.Symbols"/> that correspond to references with non-matching (unified) 
            version along with unification details.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UnifiedAssembly`1">
            <summary>
            Assembly symbol referenced by a AssemblyRef for which we couldn't find a matching 
            compilation reference but we found one that differs in version. 
            Created only for assemblies that require runtime binding redirection policy,
            i.e. not for Framework assemblies.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.UnifiedAssembly`1.OriginalReference">
            <summary>
            Original reference that was unified to the identity of the <see cref="P:TargetAssembly"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ResourceDescription">
            <summary>
            Representation of a resource whose contents are to be embedded in the output assembly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ResourceDescription.#ctor(System.String,System.Func{System.IO.Stream},System.Boolean)">
            <summary>
            Creates a representation of a resource whose contents are to be embedded in the output assembly.
            </summary>
            <param name="resourceName">Resource name.</param>
            <param name="dataProvider">The callers will dispose the result after use.
            This allows the resources to be opened and read one at a time.
            </param>
            <param name="isPublic">True if the resource is public.</param>
            <remarks>
            Returns a stream of the data to embed.
            </remarks> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.ResourceDescription.#ctor(System.String,System.String,System.Func{System.IO.Stream},System.Boolean)">
            <summary>
            Creates a representation of a resource whose file name will be recorded in the assembly.
            </summary>
            <param name="resourceName">Resource name.</param>
            <param name="fileName">File name with an extension to be stored in metadata.</param>
            <param name="dataProvider">The callers will dispose the result after use.
            This allows the resources to be opened and read one at a time.
            </param>
            <param name="isPublic">True if the resource is public.</param>
            <remarks>
            Function returning a stream of the recource content (used to calculate hash).
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SourceCodeKind">
            <summary>
            Specifies the C# or VB source code kind.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SourceCodeKind.Regular">
            <summary>
            No scripting. Used for .cs/.vb file parsing.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SourceCodeKind.Script">
            <summary>
            Allows top-level statements and declarations. Used for .csx/.vbx file parsing.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SourceCodeKind.Interactive">
            <summary>
            Allows top-level expressions and optional semicolon.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SpecialType">
            <summary>
            Specifies the Ids of special runtime types.
            </summary>
            <remarks>
            Only types explicitly mentioned in "Co-located core types" spec 
            (http://devdiv/sites/docs/Dev11/CLR/Specs/CoreFx/Co-located%20core%20types.docx)
            can be in this enum.
            The following things should be in sync:
                1) SpecialType enum
                2) names in SpecialTypes.EmittedNames array.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.None">
            <summary>
            OIndicated Non-sepecial type (default value).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Object">
            <summary>
            Indicates that the type is <see cref="T:System.Object"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Enum">
            <summary>
            Indicates that the type is <see cref="T:System.Enum"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_MulticastDelegate">
            <summary>
            Indicates that the type is <see cref="T:System.MulticastDelegate"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Delegate">
            <summary>
            Indicates that the type is <see cref="T:System.Delegate"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_ValueType">
            <summary>
            Indicates that the type is <see cref="T:System.ValueType"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Void">
            <summary>
            Indicates that the type is <see cref="T:System.Void"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Boolean">
            <summary>
            Indicates that the type is <see cref="T:System.Boolean"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Char">
            <summary>
            Indicates that the type is <see cref="T:System.Char"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_SByte">
            <summary>
            Indicates that the type is <see cref="T:System.SByte"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Byte">
            <summary>
            Indicates that the type is <see cref="T:System.Byte"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Int16">
            <summary>
            Indicates that the type is <see cref="T:System.Int16"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_UInt16">
            <summary>
            Indicates that the type is <see cref="T:System.UInt16"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Int32">
            <summary>
            Indicates that the type is <see cref="T:System.Int32"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_UInt32">
            <summary>
            Indicates that the type is <see cref="T:System.UInt32"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Int64">
            <summary>
            Indicates that the type is <see cref="T:System.Int64"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_UInt64">
            <summary>
            Indicates that the type is <see cref="T:System.UInt64"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Decimal">
            <summary>
            Indicates that the type is <see cref="T:System.Decimal"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Single">
            <summary>
            Indicates that the type is <see cref="T:System.Single"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Double">
            <summary>
            Indicates that the type is <see cref="T:System.Double"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_String">
            <summary>
            Indicates that the type is <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_IntPtr">
            <summary>
            Indicates that the type is <see cref="T:System.IntPtr" />.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_UIntPtr">
            <summary>
            Indicates that the type is <see cref="T:System.UIntPtr"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Array">
            <summary>
            Indicates that the type is <see cref="T:System.Array"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Collections_IEnumerable">
            <summary>
            Indicates that the type is <see cref="T:System.Collections.IEnumerable"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Collections_Generic_IEnumerable_T">
            <summary>
            Indicates that the type is <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Collections_Generic_IList_T">
            <summary>
            Indicates that the type is <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Collections_Generic_ICollection_T">
            <summary>
            Indicates that the type is <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Collections_IEnumerator">
            <summary>
            Indicates that the type is <see cref="T:System.Collections.IEnumerator"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Collections_Generic_IEnumerator_T">
            <summary>
            Indicates that the type is <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Collections_Generic_IReadOnlyList_T">
            <summary>
            Indicates that the type is <see cref="T:System.Collections.Generic.IReadOnlyList`1"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Collections_Generic_IReadOnlyCollection_T">
            <summary>
            Indicates that the type is <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Nullable_T">
            <summary>
            Indicates that the type is <see cref="T:System.Nullable`1"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_DateTime">
            <summary>
            Indicates that the type is <see cref="T:System.DateTime"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Runtime_CompilerServices_IsVolatile">
            <summary>
            Indicates that the type is <see cref="T:System.Runtime.CompilerServices.IsVolatile"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_IDisposable">
            <summary>
            Indicates that the type is <see cref="T:System.IDisposable"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_TypedReference">
            <summary>
            Indicates that the type is <see cref="T:System.TypedReference"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_ArgIterator">
            <summary>
            Indicates that the type is <see cref="T:System.ArgIterator"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_RuntimeArgumentHandle">
            <summary>
            Indicates that the type is <see cref="T:System.RuntimeArgumentHandle"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_RuntimeFieldHandle">
            <summary>
            Indicates that the type is <see cref="T:System.RuntimeFieldHandle"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_RuntimeMethodHandle">
            <summary>
            Indicates that the type is <see cref="T:System.RuntimeMethodHandle"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_RuntimeTypeHandle">
            <summary>
            Indicates that the type is <see cref="T:System.RuntimeTypeHandle"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_IAsyncResult">
            <summary>
            Indicates that the type is <see cref="T:System.IAsyncResult"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_AsyncCallback">
            <summary>
            Indicates that the type is <see cref="T:System.AsyncCallback"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.Count">
            <summary>
            Count of special types. This is not a count of enum members.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SpecialTypeExtensions.IsClrInteger(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Checks if a type is considered a "built-in integral" by CLR.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SpecialTypeExtensions.IsBlittable(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Checks if a type is a primitive of a fixed size.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SpecialTypeExtensions.IsPrimitiveRecursiveStruct(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            These special types are structs that contain fields of the same type
            (e.g. System.Int32 contains a field of type System.Int32).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialTypes.emittedNames">
            <summary>
            Array of names for types from Cor Libraray.
            The names should correspond to ids from TypeId enum so
            that we could use ids to index into the array
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SpecialTypes.GetMetadataName(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Gets the name of the special type as it would appear in metadata.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.StrongNameKeys.KeyPair">
            <summary>
            The strong name key associated with the identity of this assembly. 
            This contains the contents of the user-supplied key file exactly as extracted.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.StrongNameKeys.PublicKey">
            <summary>
            Determines source assembly identity.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.StrongNameKeys.DiagnosticOpt">
            <summary>
            A diagnostic created in the process of determining the key.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.StrongNameKeys.KeyContainer">
            <summary>
            The CSP key container containing the public key used to produce the key,
            or null if the key was retrieved from <see cref="F:Microsoft.CodeAnalysis.StrongNameKeys.KeyFilePath"/>.
            </summary>
            <remarks>
            The original value as specified by <see cref="T:System.Reflection.AssemblyKeyNameAttribute"/> or 
            <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.CryptoKeyContainer"/>.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.StrongNameKeys.KeyFilePath">
            <summary>
            Original key file path, or null if the key is provided by the <see cref="F:Microsoft.CodeAnalysis.StrongNameKeys.KeyContainer"/>.
            </summary>
            <remarks>
            The original value as specified by <see cref="T:System.Reflection.AssemblyKeyFileAttribute"/> or 
            <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.CryptoKeyFile"/>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.StrongNameProvider">
            <summary>
            Provides strong name and signs source assemblies.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SwitchConstantValueHelper">
            <summary>
            Contains helper methods for switch statement label constants
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SwitchConstantValueHelper.CompareSwitchCaseLabelConstants(Microsoft.CodeAnalysis.ConstantValue,Microsoft.CodeAnalysis.ConstantValue)">
            <summary>
            Method used to compare ConstantValues for switch statement case labels
            </summary>
            <param name="first"></param>
            <param name="second"></param>
            <returns>A value that indicates the relative order of the objects being compared. The return value has these meanings:
            Less than zero:     first instance precedes second in the sort order.
            Zero:               first instance occurs in the same position in the sort order as second.
            Greater than zero:  first instance follows second in the sort order.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplay.AbstractSymbolDisplayVisitor`1.AddNonNullConstantValue(Microsoft.CodeAnalysis.ITypeSymbol,System.Object,System.Boolean)">
            <summary>
            Append a default argument (i.e. the default argument of an optional parameter).
            Assumed to be non-null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplay.AbstractSymbolDisplayVisitor`1.IsFlagsEnum(Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Check if the given type is an enum with System.FlagsAttribute.
            </summary>
            <remarks>
            TODO: Can/should this be done using WellKnownAttributes?
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FormattedSymbol">
            <summary>
            This class associates a symbol with particular format for display.
            It can be passed as an argument for an error message in place where symbol display should go, 
            which allows to defer building strings and doing many other things (like loading metadata) 
            associated with that until the error message is actually requested.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions.UseMetadataMethodNames">
            <summary>
            ".ctor" instead of "Foo"
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions.UseArityForGenericTypes">
            <summary>
            "List`1" instead of "List&lt;T&gt;" ("List(of T)" in VB). Overrides GenericsOptions on
            types.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions.FlagMissingMetadataTypes">
            <summary>
            Append "[Missing]" to missing Metadata types (for testing).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions.IncludeScriptType">
            <summary>
            Include the Script type when qualifying type names.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions.IncludeCustomModifiers">
            <summary>
            Include custom modifiers (e.g. modopt([mscorlib]System.Runtime.CompilerServices.IsConst)) on
            the member (return) type and parameters.
            </summary>
            <remarks>
            CONSIDER: custom modifiers are part of the public API, so we might want to move this to SymbolDisplayMemberOptions.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions.ReverseArrayRankSpecifiers">
            <summary>
            For a type written as "int[][,]" in C#, then
              a) setting this option will produce "int[,][]", and
              b) not setting this option will produce "int[][,]".
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayDelegateStyle">
            <summary>
            Specifies how to display delegates (just the name or the name with the signature).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayDelegateStyle.NameOnly">
            <summary>
            Shows only the name of the delegate (e.g. "SomeDelegate").
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayDelegateStyle.NameAndParameters">
            <summary>
            Shows the name and the parameters of the delegate (e.g. "SomeDelegate(int x)").  
            </summary>
            <remarks>
            The format of the parameters will be determined by the other flags passed.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayDelegateStyle.NameAndSignature">
            <summary>
            Shows the name and the signature of the delegate (e.g. "void SomeDelegate(int x)").  
            </summary>
            <remarks>
            The format of the signature will be determined by the other flags passed.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayExtensionMethodStyle">
            <summary>
            Specifies how how to display extension methods.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayExtensionMethodStyle.StaticMethod">
            <summary>
            Displays the extension method as a static method. 
            For example, Enumerable.ElementAt&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, int index).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayExtensionMethodStyle.InstanceMethod">
            <summary>
            Displays the extension method in the form of an instance method. 
            For example, IEnumerable&lt;TSource&gt;.ElementAt&lt;TSource&gt;(int index).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayExtensions">
            <summary>
            Exposes extension methods for displaying symbol descriptions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayExtensions.ToDisplayString(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SymbolDisplayPart})">
            <summary>
            Converts an immutable array of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayPart"/>s to a string.
            </summary>
            <param name="parts">The array of parts.</param>
            <returns>The concatenation of the parts into a single string.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayExtensions.IncludesOption(Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions,Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions)">
            <summary>
            Determines if a flag is set on the <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions"/> enum.
            </summary>
            <param name="options">The value to check.</param>
            <param name="flag">An enum field that specifies the flag.</param>
            <returns>Whether the <paramref name="flag"/> is set on the <paramref name="options"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayExtensions.IncludesOption(Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions,Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions)">
            <summary>
            Determines if a flag is set on the <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions"/> enum.
            </summary>
            <param name="options">The value to check.</param>
            <param name="flag">An enum field that specifies the flag.</param>
            <returns>Whether the <paramref name="flag"/> is set on the <paramref name="options"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayExtensions.IncludesOption(Microsoft.CodeAnalysis.SymbolDisplayMemberOptions,Microsoft.CodeAnalysis.SymbolDisplayMemberOptions)">
            <summary>
            Determines if a flag is set on the <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions"/> enum.
            </summary>
            <param name="options">The value to check.</param>
            <param name="flag">An enum field that specifies the flag.</param>
            <returns>Whether the <paramref name="flag"/> is set on the <paramref name="options"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayExtensions.IncludesOption(Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions,Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions)">
            <summary>
            Determines if a flag is set on the <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions"/> enum.
            </summary>
            <param name="options">The value to check.</param>
            <param name="flag">An enum field that specifies the flag.</param>
            <returns>Whether the <paramref name="flag"/> is set on the <paramref name="options"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayExtensions.IncludesOption(Microsoft.CodeAnalysis.SymbolDisplayParameterOptions,Microsoft.CodeAnalysis.SymbolDisplayParameterOptions)">
            <summary>
            Determines if a flag is set on the <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions"/> enum.
            </summary>
            <param name="options">The value to check.</param>
            <param name="flag">An enum field that specifies the flag.</param>
            <returns>Whether the <paramref name="flag"/> is set on the <paramref name="options"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayExtensions.IncludesOption(Microsoft.CodeAnalysis.SymbolDisplayKindOptions,Microsoft.CodeAnalysis.SymbolDisplayKindOptions)">
            <summary>
            Determines if a flag is set on the <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayKindOptions"/> enum.
            </summary>
            <param name="options">The value to check.</param>
            <param name="flag">An enum field that specifies the flag.</param>
            <returns>Whether the <paramref name="flag"/> is set on the <paramref name="options"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayExtensions.IncludesOption(Microsoft.CodeAnalysis.SymbolDisplayLocalOptions,Microsoft.CodeAnalysis.SymbolDisplayLocalOptions)">
            <summary>
            Determines if a flag is set on the <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayLocalOptions"/> enum.
            </summary>
            <param name="options">The value to check.</param>
            <param name="flag">An enum field that specifies the flag.</param>
            <returns>Whether the <paramref name="flag"/> is set on the <paramref name="options"/>.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayFormat">
            <summary>
            Describes the formatting rules that should be used when displaying symbols.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayFormat.CSharpErrorMessageFormat">
            <summary>
            Formats a symbol description as in a C# compiler error message.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayFormat.VisualBasicErrorMessageFormat">
            <summary>
            Formats a symbol description as in a Visual Basic compiler error message.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayFormat.FullyQualifiedFormat">
            <summary>
            Formats the names of all types and namespaces in a fully qualified style (including the global alias).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayFormat.MinimallyQualifiedFormat">
            <summary>
            Formats a symbol description in a form that suits <see cref="M:Microsoft.CodeAnalysis.ISymbol.ToMinimalDisplayString(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SymbolDisplayFormat)"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayFormat.TestFormat">
            <summary>
            A verbose format for displaying symbols (useful for testing).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayFormat.QualifiedNameOnlyFormat">
            <summary>
            this.QualifiedNameOnly = containingSymbol.QualifiedNameOnly + "." + this.Name
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayFormat.QualifiedNameArityFormat">
            <summary>
            this.QualifiedNameArity = containingSymbol.QualifiedNameArity + "." + this.Name + "`" + this.Arity
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayFormat.ShortFormat">
            <summary>
            A succinct format for displaying symbols.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayFormat.ILVisualizationFormat">
            <summary>
            The format used for displaying symbols when visualizing IL.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayFormat.ExplicitInterfaceImplementationFormat">
            <summary>
            Used to normalize explicit interface implementation member names.
            Only expected to be applied to interface types (and their type arguments).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.GlobalNamespaceStyle">
            <summary>
            Determines how the global namespace is displayed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.TypeQualificationStyle">
            <summary>
            Determines how types are qualified (e.g. Nested vs Containing.Nested vs Namespace.Containing.Nested).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.GenericsOptions">
            <summary>
            Determines how generics (on types and methods) should be described (i.e. the level of detail).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.MemberOptions">
            <summary>
            Determines how fields, properties, events, and methods are displayed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.ParameterOptions">
            <summary>
            Determines how parameters (of methods, properties/indexers, and delegates) are displayed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.DelegateStyle">
            <summary>
            Determines how delegates are displayed (e.g. name vs full signature).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.ExtensionMethodStyle">
            <summary>
            Determines how extension methods are displayed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.PropertyStyle">
            <summary>
            Determines how properties are displayed. 
            For example, "Prop" vs "Prop { get; set; }" in C# or "Prop" vs. "ReadOnly Prop" in Visual Basic.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.LocalOptions">
            <summary>
            Determines how local variables are displayed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.KindOptions">
            <summary>
            Determines which kind keywords should be included when displaying symbols.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.MiscellaneousOptions">
            <summary>
            Determines other characteristics of how symbols are displayed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.CompilerInternalOptions">
            <summary>
            Flags that can only be set within the compiler.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.#ctor(Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle,Microsoft.CodeAnalysis.SymbolDisplayTypeQualificationStyle,Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions,Microsoft.CodeAnalysis.SymbolDisplayMemberOptions,Microsoft.CodeAnalysis.SymbolDisplayDelegateStyle,Microsoft.CodeAnalysis.SymbolDisplayExtensionMethodStyle,Microsoft.CodeAnalysis.SymbolDisplayParameterOptions,Microsoft.CodeAnalysis.SymbolDisplayPropertyStyle,Microsoft.CodeAnalysis.SymbolDisplayLocalOptions,Microsoft.CodeAnalysis.SymbolDisplayKindOptions,Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions)">
            <summary>
            Constructs a new instance of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayFormat"/> accepting a variety of optional parameters.
            </summary>
            <param name="globalNamespaceStyle">
            The settings that determine how the global namespace is displayed.
            </param>
            <param name="typeQualificationStyle">
            The settings that determine how types are qualified (e.g. Nested vs Containing.Nested vs Namespace.Containing.Nested).
            </param>
            <param name="genericsOptions">
            The settings that determine how generics (on types and methods) should be described (i.e. the level of detail).
            </param>
            <param name="memberOptions">
            The settings that determine how fields, properties, events, and methods are displayed.
            </param>
            <param name="delegateStyle">
            The settings that determine how delegates are displayed (e.g. name vs full signature).
            </param>
            <param name="extensionMethodStyle">
            The settings that determine how extension methods are displayed.
            </param>
            <param name="parameterOptions">
            The settings that determine how parameters (of methods, properties/indexers, and delegates) are displayed.
            </param>
            <param name="propertyStyle">
            The settings that determine how properties are displayed. 
            For eaxmple, "Prop" vs "Prop { get; set; }" in C# or "Prop" vs. "ReadOnly Prop" in Visual Basic.
            </param>
            <param name="localOptions">
            The settings that determine how local variables are displayed.
            </param>
            <param name="kindOptions">
            The settings that determine which kind keywords should be included when displaying symbols.
            </param>
            <param name="miscellaneousOptions">
            The settings that determine other characteristics of how symbols are displayed.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.#ctor(Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions,Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle,Microsoft.CodeAnalysis.SymbolDisplayTypeQualificationStyle,Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions,Microsoft.CodeAnalysis.SymbolDisplayMemberOptions,Microsoft.CodeAnalysis.SymbolDisplayParameterOptions,Microsoft.CodeAnalysis.SymbolDisplayDelegateStyle,Microsoft.CodeAnalysis.SymbolDisplayExtensionMethodStyle,Microsoft.CodeAnalysis.SymbolDisplayPropertyStyle,Microsoft.CodeAnalysis.SymbolDisplayLocalOptions,Microsoft.CodeAnalysis.SymbolDisplayKindOptions,Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions)">
            <summary>
            This version also accepts <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithMiscellaneousOptions(Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with replaced set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions"/>.
            </summary>
            <param name="options">
            An object representing how miscellaneous symbols will be formatted.
            </param>
            <returns>A duplicate of the SymbolDisplayFormat, with a replaced set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddMiscellaneousOptions(Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with an additional set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions"/>.
            </summary>
            <param name="options">
            An object specifying additional parameters for how miscellaneous symbols will be formatted.
            </param>
            <returns>A duplicate of the SymbolDisplayFormat, with an additional set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithGenericsOptions(Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with replaced set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions"/>.
            </summary>
            <param name="options">
            An object specifying how generic symbols will be formatted.
            </param>
            <returns>A duplicate of the SymbolDisplayFormat, with a replaced set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddGenericsOptions(Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with an additional set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions"/>.
            </summary>
            <param name="options">
            An object specifying additional parameters for how generic symbols will be formatted.
            </param>
            <returns>A duplicate of the SymbolDisplayFormat, with an additional set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithMemberOptions(Microsoft.CodeAnalysis.SymbolDisplayMemberOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with replaced set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions"/>.
            </summary>
            <param name="options">
            An object specifying how members will be formatted.
            </param>
            <returns>A duplicate of the SymbolDisplayFormat, with a replaced set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddMemberOptions(Microsoft.CodeAnalysis.SymbolDisplayMemberOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with an additional set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions"/>.
            </summary>
            <param name="options">
            An object specifying additional parameters for how members will be formatted.
            </param>
            <returns>
            A duplicate of the SymbolDisplayFormat, with an additional set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions"/>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.RemoveMemberOptions(Microsoft.CodeAnalysis.SymbolDisplayMemberOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with a set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions"/> stripped away from the original object.
            </summary>
            <param name="options">
            An object specifying which parameters should not be applied to how members will be formatted.
            </param>
            <returns>
            A duplicate of the SymbolDisplayFormat, with a set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions"/> stripped away from the original object.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithKindOptions(Microsoft.CodeAnalysis.SymbolDisplayKindOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with replaced set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayKindOptions"/>.
            </summary>
            <param name="options">
            An object specifying parameters with which symbols belonging to kind keywords should be formatted.
            </param>
            <returns>
            A duplicate of the SymbolDisplayFormat, with a replaced set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayKindOptions"/>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddKindOptions(Microsoft.CodeAnalysis.SymbolDisplayKindOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with an additional set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayKindOptions"/>.
            </summary>
            <param name="options">
            An object specifying additional parameters with which symbols belonging to kind keywords should be formatted.
            </param>
            <returns>
            A duplicate of the SymbolDisplayFormat, with an additional set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayKindOptions"/>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.RemoveKindOptions(Microsoft.CodeAnalysis.SymbolDisplayKindOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with a set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayKindOptions"/> stripped away from the original object.
            </summary>
            <param name="options">
            The settings that determine other characteristics of how symbols are displayed.
            </param>
            <returns>
            A duplicate of the SymbolDisplayFormat, with a set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayKindOptions"/> stripped away from the original object.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithParameterOptions(Microsoft.CodeAnalysis.SymbolDisplayParameterOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with replaced set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions"/>.
            </summary>
            <param name="options">
            An object specifying how parameters should be formatted.
            </param>
            <returns>A duplicate of the SymbolDisplayFormat, with a replaced set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddParameterOptions(Microsoft.CodeAnalysis.SymbolDisplayParameterOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with an additional set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions"/>.
            </summary>
            <param name="options">
            An object specifying additional parameters on how parameters should be formatted.
            </param>
            <returns>
            A duplicate of the SymbolDisplayFormat, with an additional set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions"/>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.RemoveParameterOptions(Microsoft.CodeAnalysis.SymbolDisplayParameterOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with a set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions"/> stripped away from the original object.
            </summary>
            <param name="options">
            An object specifying parameters that should not be applied when formatting parameters.
            </param>
            <returns>
            A duplicate of the SymbolDisplayFormat, with a set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions"/> stripped away from the original object.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithGlobalNamespaceStyle(Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with replaced <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle"/>.
            </summary>
            <param name="style">
            An object specifying paramers on how namespace symbols should be formatted.
            </param>
            <returns>A duplicate of the SymbolDisplayFormat, with a replaced set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithLocalOptions(Microsoft.CodeAnalysis.SymbolDisplayLocalOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with replaced set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayLocalOptions"/>.
            </summary>
            <param name="options">
            An object specifying parameters on how symbols belonging to locals should be formatted.
            </param>
            <returns>A duplicate of the SymbolDisplayFormat, with a replaced set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayLocalOptions"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddLocalOptions(Microsoft.CodeAnalysis.SymbolDisplayLocalOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with an additional set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions"/>.
            </summary>
            <param name="options">
            An object specifying additional parameters on how symbols belonging to locals should be formatted.
            </param>
            <returns>
            A duplicate of the SymbolDisplayFormat, with an additional set of <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions"/>.
            </returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions">
            <summary>
            Specifies the options for how generics are displayed in the description of a symbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions.None">
            <summary>
            Omits the type parameter list entirely.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions.IncludeTypeParameters">
            <summary>
            Includes the type parameters. 
            For example, "Foo&lt;T&gt;" in C# or "Foo(Of T)" in Visual Basic.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions.IncludeTypeConstraints">
            <summary>
            Includes type parameters and constraints.
            For example, "where T : new()" in C# or "Of T as New" in Visual Basic.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions.IncludeVariance">
            <summary>
            Includes <c>in</c> or <c>out</c> keywords before variant type parameters.
            For example, "Foo&lt;out T&gt;" in C# or (Foo Of Out T" in Visual Basic.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle">
            <summary>
            Specifies the options for how to display the global namespace in the description of a symbol.
            </summary>
            <remarks>
            Any of these styles may be overridden by <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayTypeQualificationStyle"/>.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle.Omitted">
            <summary>
            Omits the global namespace, unconditionally.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle.OmittedAsContaining">
            <summary>
            Omits the global namespace if it is being displayed as a containing symbol (i.e. not on its own).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle.Included">
            <summary>
            Include the global namespace, unconditionally.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayKindOptions">
            <summary>
            Specifies which kind keywords should be included when displaying symbols.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayKindOptions.None">
            <summary>
            Omits all kind keywords.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayKindOptions.IncludeNamespaceKeyword">
            <summary>
            Includes the <c>namespace</c> keyword before namespaces.
            For example, "namespace System", rather than "System".
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayKindOptions.IncludeTypeKeyword">
            <summary>
            Includes the type keyword before types.
            For example, "class C" in C# or "Structure S" in Visual Basic.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayKindOptions.IncludeMemberKeyword">
            <summary>
            Include the member keyword before members (if one exists).
            For example, "event D E" in C# or "Function MyFun()" in Visual Basic.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayLocalOptions">
            <summary>
            Specifies the options for how locals are displayed in the description of a symbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayLocalOptions.None">
            <summary>
            Shows only the name of the local.
            For example, "x".
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayLocalOptions.IncludeType">
            <summary>
            Shows the type of the local in addition to its name.
            For example, "int x" in C# or "x As Integer" in Visual Basic.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayLocalOptions.IncludeConstantValue">
            <summary>
            Shows the constant value of the local, if there is one, in addition to its name.
            For example "x = 1".
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions">
            <summary>
            Specifies the options for how members are displayed in the description of a symbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions.None">
            <summary>
            Includes only the name of the member.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions.IncludeType">
            <summary>
            Includes the (return) type of the method/field/property/event.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions.IncludeModifiers">
            <summary>
            Includes the modifiers of the member.
            For example, "static readonly" in C# or "Shared ReadOnly" in Visual Basic.
            </summary>
            <remarks>
            Accessibility modifiers are controlled separately by <see cref="F:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions.IncludeAccessibility"/>.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions.IncludeAccessibility">
            <summary>
            Includes the accessibility modifiers of the member.
            For example, "public" in C# or "Public" in Visual Basic.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions.IncludeExplicitInterface">
            <summary>
            Includes the name of corresponding interface on members that explicitly implement
            interface members.
            For example, "IFoo.Bar { get; }".
            </summary>
            <remarks>
            This option has no effect in Visual Basic.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions.IncludeParameters">
            <summary>
            Includes the parameters of methods and properties/indexers.
            </summary>
            <remarks>
            See <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions"/> for finer-grained settings.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions.IncludeContainingType">
            <summary>
            Includes the name of the type containing the member.
            </summary>
            <remarks>
            The format of the containing type is determined by <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayTypeQualificationStyle"/>.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions.IncludeConstantValue">
            <summary>
            Includes the value of the member if is a constant.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions">
            <summary>
            Specifies miscellaneous options about the format of symbol descriptions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions.None">
            <summary>
            Specifies that no miscellaneous options should be applied.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions.UseSpecialTypes">
            <summary>
            Uses keywords for predefined types. 
            For example, "int" instead of "System.Int32" in C#
            or "Integer" instead of "System.Integer" in Visual Basic.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers">
            <summary>
            Escapes identifiers that are also keywords.
            For example, "@true" instead of "true" in C# or
            "[True]" instead of "True" in Visual Basic.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions.UseAsterisksInMultiDimensionalArrays">
            <summary>
            Displays asterisks between commas in multi-dimensional arrays.
            For example, "int[][*,*]" instead of "int[][,]" in C# or
            "Integer()(*,*)" instead of "Integer()(*,*) in Visual Basic.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions.UseErrorTypeSymbolName">
            <summary>
            Displays "?" for erroneous types that lack names (perhaps due to faulty metadata).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions.RemoveAttributeSuffix">
            <summary>
            Displays attributes names without the "Attribute" suffix, if possible.
            </summary>
            <remarks>
            Has no effect outside <see cref="M:Microsoft.CodeAnalysis.ISymbol.ToMinimalDisplayString(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SymbolDisplayFormat)"/> and only applies
            if the context location is one where an attribute ca be referenced without the suffix.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions.ExpandNullable">
            <summary>
            Displays <see cref="T:System.Nullable`1"/> as a normal generic type, rather than with
            the special question mark syntax.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions">
            <summary>
            Specifies how parameters are displayed in the description of a (member, property/indexer, or delegate) symbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions.None">
            <summary>
            Omits parameters from symbol descriptions.
            </summary>
            <remarks>
            If this option is combined with <see cref="F:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions.IncludeParameters"/>, then only
            the parentheses will be shown (e.g. M()).
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions.IncludeExtensionThis">
            <summary>
            Includes the <c>this</c> keyword before the first parameter of an extension method in C#. 
            </summary>
            <remarks>
            This option has no effect in Visual Basic.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions.IncludeParamsRefOut">
            <summary>
            Includes the <c>params</c>, <c>ref</c>, <c>out</c>, <c>ByRef</c>, <c>ByVal</c> keywords before parameters.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions.IncludeType">
            <summary>
            Includes parameter types in symbol descriptions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions.IncludeName">
            <summary>
            Includes parameter names in symbol descriptions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions.IncludeDefaultValue">
            <summary>
            Includes parameter default values in symbol descriptions.
            </summary>
            <remarks>Ignored if <see cref="F:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions.IncludeName"/> is not set.</remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions.IncludeOptionalBrackets">
            <summary>
            Includes square brackets around optional parameters.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayPart">
            <summary>
            A single element of a symbol description.  For example, a keyword, a punctuation character or
            a class name.
            </summary>
            <seealso cref="M:Microsoft.CodeAnalysis.ISymbol.ToDisplayParts(Microsoft.CodeAnalysis.SymbolDisplayFormat)"/>
            <seealso cref="M:Microsoft.CodeAnalysis.ISymbol.ToMinimalDisplayParts(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SymbolDisplayFormat)"/>
            <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayPartKind"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayPart.Kind">
            <summary>
            Gets the kind of this display part.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayPart.Symbol">
            <summary>
            Gets the symbol associated with this display part, if there is one.
            For example, the <see cref="T:Microsoft.CodeAnalysis.ITypeSymbol"/> associated with a class name.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayPart.#ctor(Microsoft.CodeAnalysis.SymbolDisplayPartKind,Microsoft.CodeAnalysis.ISymbol,System.String)">
            <summary>
            Construct a non-formattable <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayPart"/> (i.e. with a fixed string value).
            </summary>
            <param name="kind">The kind of the display part.</param>
            <param name="symbol">An optional associated symbol.</param>
            <param name="text">The fixed string value of the part.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayPart.ToString">
            <summary>
            Returns the string value of this symbol display part.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayPartKind">
            <summary>
            Specifies the kinds of a piece of classified text (SymbolDisplayPart).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.AliasName">
            <summary>The name of an alias.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.AssemblyName">
            <summary>The name of an assembly.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.ClassName">
            <summary>The name of a class.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.DelegateName">
            <summary>The name of a delegate.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.EnumName">
            <summary>The name of an enum.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.ErrorTypeName">
            <summary>The name of an error type.</summary>
            <seealso cref="T:Microsoft.CodeAnalysis.IErrorTypeSymbol"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.EventName">
            <summary>The name of an event.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.FieldName">
            <summary>The name of a field.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.InterfaceName">
            <summary>The name of an interface.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.Keyword">
            <summary>A language keyword.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.LabelName">
            <summary>The name of a label.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.LineBreak">
            <summary>A line-break (i.e. whitespace).</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.NumericLiteral">
            <summary>A numeric literal.</summary>
            <remarks>Typically for the default values of parameters and the constant values of fields.</remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.StringLiteral">
            <summary>A string literal.</summary>
            <remarks>Typically for the default values of parameters and the constant values of fields.</remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.LocalName">
            <summary>The name of a local.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.MethodName">
            <summary>The name of a method.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.ModuleName">
            <summary>The name of a module.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.NamespaceName">
            <summary>The name of a namespace.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.Operator">
            <summary>The symbol of an operator (e.g. "+").</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.ParameterName">
            <summary>The name of a parameter.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.PropertyName">
            <summary>The name of a property.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.Punctuation">
            <summary>A punctuation character (e.g. "(", ".", ",") other than an <see cref="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.Operator"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.Space">
            <summary>A single space character.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.StructName">
            <summary>The name of a struct (structure in Visual Basic).</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.AnonymousTypeIndicator">
            <summary>A keyword-like part for anonymous types (not actually a keyword).</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.Text">
            <summary>An unclassified part.</summary>
            <remarks>Never returned - only set in user-constructed parts.</remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.TypeParameterName">
            <summary>The name of a type parameter.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.RangeVariableName">
            <summary>The name of a query range variable..</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayPropertyStyle">
            <summary>
            Specifies the options for how properties are displayed in symbol descriptions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPropertyStyle.NameOnly">
            <summary>
            Shows only the names of properties.
            <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPropertyStyle.ShowReadWriteDescriptor">
            <summary>
            Indicates whether the property is readable and/or writable.
            In C#, this is accomplished by including accessors.
            In Visual Basic, this is accomplished by including the <c>ReadOnly</c> or <c>WriteOnly</c>
            keyword, as appropriate.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayTypeQualificationStyle">
            <summary>
            Specifies how much qualification is used in symbol descriptions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayTypeQualificationStyle.NameOnly">
            <summary>
            Shows only the name of the symbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayTypeQualificationStyle.NameAndContainingTypes">
            <summary>
            Shows the name of the symbol and the names of all containing types.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces">
            <summary>
            Shows the name of the symbol the names of all containing types and namespaces.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Accessibility">
            <summary>
            Enumeration for common accessibility combinations.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Accessibility.NotApplicable">
            <summary>
            No accessibility specified.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Symbols.CommonAnonymousTypeManager.templatesSealed">
            <summary>
            We should not see new anonymous types from source after we finished emit phase. 
            If this field is true, the collection is sealed; in DEBUG it also is used to check the assertion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.CommonAnonymousTypeManager.AreTemplatesSealed">
            <summary>
            Collection of anonymous type templates is sealed 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AttributeUsageInfo.Default">
            <summary>
            Default attribute usage for attribute types:
            (a) Valid targets: AttributeTargets.All
            (b) AllowMultiple: false
            (c) Inherited: true
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonAssemblyWellKnownAttributeData`1">
            <summary>
            Information decoded from well-known custom attributes applied on an assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonAssemblyWellKnownAttributeData`1.SecurityInformation">
            <summary>
            Returns data decoded from security attributes or null if there are no security attributes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AttributeData.AttributeClass">
            <summary>
            The attribute class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AttributeData.AttributeConstructor">
            <summary>
            The constructor on the attribute class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AttributeData.ConstructorArguments">
            <summary>
            Constructor arguments on the attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AttributeData.NamedArguments">
            <summary>
            Named (property value) arguments on the attribute. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AttributeData.IsConditionallyOmitted">
            <summary>
            Attribute is conditionally omitted if it is a source attribute and both the following are true:
            (a) It has at least one applied conditional attribute AND
            (b) None of conditional symbols are true at the attribute source location.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AttributeData.IsTargetEarlyAttribute(Microsoft.CodeAnalysis.INamedTypeSymbol,System.Int32,Microsoft.CodeAnalysis.AttributeDescription)">
            <summary>
            Checks if an applied attribute with the given attributeType matches the namespace name and type name of the given early attribute's description
            and the attribute description has a signature with parameter count equal to the given attributeArgCount.
            NOTE: We don't allow early decoded attributes to have optional parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AttributeData.GetConstructorArgument``1(System.Int32,Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Returns the value of a constructor argument as type <typeparamref name="T"/>.
            Throws if no constructor argument exists or the argument cannot be converted to the type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AttributeData.DecodeNamedArgument``1(System.String,Microsoft.CodeAnalysis.SpecialType,``0)">
            <summary>
            Returns named attribute argument with the given <paramref name="name"/> as type <typeparamref name="T"/>.
            If there is more than one named argument with this name, it returns the last one.
            If no named argument is found then the <paramref name="defaultValue"/> is returned.
            </summary>
            <param name="name">The metadata property or field name. This name is case sensitive (both VB and C#).</param>
            <param name="specialType">SpecialType of the named argument.</param>
            <param name="defaultValue">Default value for the named argument.</param>
            <remarks>
            For user defined attributes VB allows duplicate named arguments and uses the last value.
            Dev11 reports an error for pseudo-custom attributes when emitting metadata. We don't.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AttributeData.DecodeObsoleteAttribute">
            <summary>
            Decode the arguments to ObsoleteAttribute. ObsoleteAttribute can have 0,1 or 2 arguments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AttributeData.DecodeDeprecatedAttribute">
            <summary>
            Decode the arguments to DeprecatedAttribute. DeprecatedAttribute can have 3 or 4 arguments.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonAttributeDataComparer">
            <summary>
            Used to determine if two <see cref="T:Microsoft.CodeAnalysis.AttributeData"/> instances are identical,
            i.e. they have the same attribute type, attribute constructor and have identical arguments.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonEventEarlyWellKnownAttributeData">
            <summary>
            Information decoded from early well-known custom attributes applied on an event.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonEventWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on an event.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonFieldEarlyWellKnownAttributeData">
            <summary>
            Information decoded from early well-known custom attributes applied on a field.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonFieldWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a field.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonFieldWellKnownAttributeData.MarshallingInformation">
            <summary>
            Returns marshalling data or null of MarshalAs attribute isn't applied on the field.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonMethodEarlyWellKnownAttributeData">
            <summary>
            Information decoded from early well-known custom attributes applied on a method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonMethodWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonMethodWellKnownAttributeData.SecurityInformation">
            <summary>
            Returns data decoded from security attributes or null if there are no security attributes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonModuleWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a module.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonParameterEarlyWellKnownAttributeData">
            <summary>
            Information decoded from early well-known custom attributes applied on a parameter.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonParameterWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonParameterWellKnownAttributeData.MarshallingInformation">
            <summary>
            Returns marshalling data or null of MarshalAs attribute isn't applied on the parameter.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonPropertyEarlyWellKnownAttributeData">
            <summary>
            Information decoded from early well-known custom attributes applied on a property.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonPropertyWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a property.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonReturnTypeWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a method return value.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonReturnTypeWellKnownAttributeData.MarshallingInformation">
            <summary>
            Returns marshalling data or null of MarshalAs attribute isn't applied on the return value.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonTypeEarlyWellKnownAttributeData">
            <summary>
            Information decoded from early well-known custom attributes applied on a type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonTypeWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonTypeWellKnownAttributeData.SecurityInformation">
            <summary>
            Returns data decoded from security attributes or null if there are no security attributes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CustomAttributesBag`1">
            <summary>
            Represents a bag of custom attributes and the associated decoded well-known attribute data.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CustomAttributesBag`1.Empty">
            <summary>
            Instance representing sealed custom attribute bag with no attributes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CustomAttributesBag`1.WithEmptyData">
            <summary>
            Returns a non-sealed custom attribute bag with null initialized <see cref="F:Microsoft.CodeAnalysis.CustomAttributesBag`1.earlyDecodedWellKnownAttributeData"/>, null initialized <see cref="F:Microsoft.CodeAnalysis.CustomAttributesBag`1.decodedWellKnownAttributeData"/> and uninitialized <see cref="F:Microsoft.CodeAnalysis.CustomAttributesBag`1.customAttributes"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CustomAttributesBag`1.SetEarlyDecodedWellKnownAttributeData(Microsoft.CodeAnalysis.EarlyWellKnownAttributeData)">
            <summary>
            Sets the early decoded well-known attribute data on the bag in a thread safe manner.
            Stored early decoded data is immutable and cannot be updated further.
            </summary>
            <returns>Returns true if early decoded data were stored into the bag on this thread.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CustomAttributesBag`1.SetDecodedWellKnownAttributeData(Microsoft.CodeAnalysis.WellKnownAttributeData)">
            <summary>
            Sets the decoded well-known attribute data (except the early data) on the bag in a thread safe manner. 
            Stored decoded data is immutable and cannot be updated further.
            </summary>
            <returns>Returns true if decoded data were stored into the bag on this thread.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CustomAttributesBag`1.SetAttributes(System.Collections.Immutable.ImmutableArray{`0})">
            <summary>
            Sets the bound attributes on the bag in a thread safe manner.
            If store succeeds, it seals the bag and makes the bag immutable.
            </summary>
            <returns>Returns true if bound attributes were stored into the bag on this thread.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CustomAttributesBag`1.Attributes">
            <summary>
            Gets the stored bound attributes in the bag.
            </summary>
            <remarks>This property can only be accessed on a sealed bag.</remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CustomAttributesBag`1.DecodedWellKnownAttributeData">
            <summary>
            Gets the decoded well-known attribute data (except the early data) in the bag. 
            </summary>
            <remarks>This property can only be accessed on the bag after <see cref="M:Microsoft.CodeAnalysis.CustomAttributesBag`1.SetDecodedWellKnownAttributeData(Microsoft.CodeAnalysis.WellKnownAttributeData)"/> has been invoked.</remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CustomAttributesBag`1.EarlyDecodedWellKnownAttributeData">
            <summary>
            Gets the early decoded well-known attribute data in the bag. 
            </summary>
            <remarks>This property can only be accessed on the bag after <see cref="M:Microsoft.CodeAnalysis.CustomAttributesBag`1.SetEarlyDecodedWellKnownAttributeData(Microsoft.CodeAnalysis.EarlyWellKnownAttributeData)"/> has been invoked.</remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CustomAttributesBag`1.IsEarlyDecodedWellKnownAttributeDataComputed">
            <summary>
            Return whether early decoded attribute data has been computed and stored on the bag and it is safe to access <see cref="P:Microsoft.CodeAnalysis.CustomAttributesBag`1.EarlyDecodedWellKnownAttributeData"/> from this bag.
            Return value of true doesn't guarantee that bound attributes or remaining decoded attribute data has also been initialized.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CustomAttributesBag`1.IsDecodedWellKnownAttributeDataComputed">
            <summary>
            Return whether all decoded attribute data has been computed and stored on the bag and it is safe to access <see cref="P:Microsoft.CodeAnalysis.CustomAttributesBag`1.DecodedWellKnownAttributeData"/> from this bag.
            Return value of true doesn't guarantee that bound attributes have also been initialized.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CustomAttributesBag`1.CustomAttributeBagCompletionPart">
            <summary>
            Enum representing the current state of attribute binding/decoding for a corresponding CustomAttributeBag.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CustomAttributesBag`1.CustomAttributeBagCompletionPart.None">
            <summary>
            Bag has been created, but no decoded data or attributes have been stored.
            CustomAttributeBag is in this state during early decoding phase.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CustomAttributesBag`1.CustomAttributeBagCompletionPart.EarlyDecodedWellKnownAttributeData">
            <summary>
            Early decoded attribute data has been computed and stored on the bag, but bound attributes or remaining decoded attribute data is not stored.
            Only <see cref="F:Microsoft.CodeAnalysis.CustomAttributesBag`1.CustomAttributeBagCompletionPart.EarlyDecodedWellKnownAttributeData"/> can be accessed from this bag.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CustomAttributesBag`1.CustomAttributeBagCompletionPart.DecodedWellKnownAttributeData">
            <summary>
            All decoded attribute data has been computed and stored on the bag, but bound attributes are not yet stored.
            Both <see cref="F:Microsoft.CodeAnalysis.CustomAttributesBag`1.CustomAttributeBagCompletionPart.EarlyDecodedWellKnownAttributeData"/> and <see cref="F:Microsoft.CodeAnalysis.CustomAttributesBag`1.CustomAttributeBagCompletionPart.DecodedWellKnownAttributeData"/> can be accessed from this bag.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CustomAttributesBag`1.CustomAttributeBagCompletionPart.Attributes">
            <summary>
            Bound attributes have been computed and stored on this bag.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CustomAttributesBag`1.CustomAttributeBagCompletionPart.All">
            <summary>
            CustomAttributeBag is completely initialized and immutable.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments`3">
            <summary>
            Contains common arguments to Symbol.DecodeWellKnownAttribute method in both the language compilers.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments`3.lazyDecodeData">
            <summary>
            Object to store the decoded data from bound well-known attributes.
            Created lazily only when some decoded data needs to be stored, null otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments`3.GetOrCreateData``1">
            <summary>
            Gets or creates the decoded data object.
            </summary>
            <remarks>
            This method must be called only when some decoded data will be stored into it subsequently.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments`3.HasDecodedData">
            <summary>
            Returns true if some decoded data has been stored into <see cref="F:Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments`3.lazyDecodeData"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments`3.DecodedData">
            <summary>
            Gets the stored decoded data.
            </summary>
            <remarks>
            Assumes <see cref="P:Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments`3.HasDecodedData"/> is true.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments`3.AttributeSyntaxOpt">
            <summary>
            Syntax of the attribute to decode. Might be null when the attribute information is not coming 
            from syntax. For example, an assembly attribute propagated from added module to the resulting assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments`3.Attribute">
            <summary>
            Bound attribute to decode.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments`3.Index">
            <summary>
            The index of the attribute in the list of attributes to decode.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments`3.AttributesCount">
            <summary>
            Total count of attributes to decode.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments`3.Diagnostics">
            <summary>
            Diagnostic bag.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments`3.SymbolPart">
            <summary>
            Specific part of the symbol to which the attributes apply, or AttributeLocation.None if the attributes apply to the symbol itself.
            Used e.g. for return type attributes of a method symbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EarlyDecodeWellKnownAttributeArguments`4">
            <summary>
            Contains common arguments to Symbol.EarlyDecodeWellKnownAttribute method in both the language compilers.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EarlyDecodeWellKnownAttributeArguments`4.lazyDecodeData">
            <summary>
            Object to store the decoded data from early bound well-known attributes.
            Created lazily only when some decoded data needs to be stored, null otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EarlyDecodeWellKnownAttributeArguments`4.GetOrCreateData``1">
            <summary>
            Gets or creates the decoded data object.
            </summary>
            <remarks>
            This method must be called only when some decoded data will be stored into it subsequently.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EarlyDecodeWellKnownAttributeArguments`4.HasDecodedData">
            <summary>
            Returns true if some decoded data has been stored into <see cref="F:Microsoft.CodeAnalysis.EarlyDecodeWellKnownAttributeArguments`4.lazyDecodeData"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EarlyDecodeWellKnownAttributeArguments`4.DecodedData">
            <summary>
            Gets the stored decoded data.
            </summary>
            <remarks>
            Assumes <see cref="P:Microsoft.CodeAnalysis.EarlyDecodeWellKnownAttributeArguments`4.HasDecodedData"/> is true.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EarlyDecodeWellKnownAttributeArguments`4.Binder">
            <summary>
            Binder to bind early well-known attributes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EarlyDecodeWellKnownAttributeArguments`4.AttributeType">
            <summary>
            Bound type of the attribute to decode.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EarlyDecodeWellKnownAttributeArguments`4.AttributeSyntax">
            <summary>
            Syntax of the attribute to decode.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EarlyDecodeWellKnownAttributeArguments`4.SymbolPart">
            <summary>
            Specific part of the symbol to which the attributes apply, or AttributeLocation.None if the attributes apply to the symbol itself.
            Used e.g. for return type attributes of a method symbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EarlyWellKnownAttributeData">
            <summary>
            Base class for storing information decoded from early well-known custom attributes.
            </summary>
            <remarks>
            CONSIDER: Should we remove this class and let the sub-classes derived from WellKnownAttributeData?
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MarshalPseudoCustomAttributeData">
            <summary>
            Information decoded from <see cref="T:System.Runtime.InteropServices.MarshalAsAttribute"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MarshalPseudoCustomAttributeData.WithTranslatedTypes``2(System.Func{``0,``1,``0},``1)">
            <summary>
            Returns an instance of <see cref="T:Microsoft.CodeAnalysis.MarshalPseudoCustomAttributeData"/> with all types replaced by types returned by specified translator.
            Returns this instance if it doesn't hold on any types.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ObsoleteAttributeData">
            <summary>
            Information decoded from <see cref="T:System.ObsoleteAttribute"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ObsoleteAttributeData.IsError">
            <summary>
            True if an error should be thrown for the <see cref="T:System.ObsoleteAttribute"/>. Default is false in which case
            a warning is thrown.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ObsoleteAttributeData.Message">
            <summary>
            The message that will be shown when an error/warning is created for <see cref="T:System.ObsoleteAttribute"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SecurityWellKnownAttributeData">
            <summary>
            Information decoded from security attributes, i.e. attributes derived from well-known SecurityAttribute, applied on a method/type/assembly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SecurityWellKnownAttributeData.GetSecurityAttributes``1(System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Used for retreiving applied source security attributes, i.e. attributes derived from well-known SecurityAttribute.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.WellKnownAttributeData">
            <summary>
            Base class for storing information decoded from well-known custom attributes.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownAttributeData.StringMissingValue">
            <summary>
            Used to distinguish cases when attribute is applied with null value and when attribute is not applied.
            For some well-known attributes, the latter case will return string stored in <see cref="F:Microsoft.CodeAnalysis.WellKnownAttributeData.StringMissingValue"/>
            field.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CustomModifier.IsOptional">
            <summary>
            If true, a language may use the modified storage location without 
            being aware of the meaning of the modification, modopt vs. modreq. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CustomModifier.Modifier">
            <summary>
            A type used as a tag that indicates which type of modification applies.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IAliasSymbol">
            <summary>
            Represents a using alias (Imports alias in Visual Basic).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IAliasSymbol.Target">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.INamespaceOrTypeSymbol"/> for the
            namespace or type referenced by the alias.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IArrayTypeSymbol">
            <summary>
            Represents an array.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IArrayTypeSymbol.Rank">
            <summary>
            Gets the number of dimensions of this array. A regular single-dimensional array
            has rank 1, a two-dimensional array has rank 2, etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IArrayTypeSymbol.ElementType">
            <summary>
            Gets the type of the elements stored in the array.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IArrayTypeSymbol.CustomModifiers">
            <summary>
            Gets the list of custom modifiers associated with the array.
            Returns an empty list if there are no custom modifiers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IAssemblySymbol">
            <summary>
            Represents a .NET assembly, consisting of one or more modules.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IAssemblySymbol.IsInteractive">
            <summary>
            True if the assembly contains interactive code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IAssemblySymbol.Identity">
            <summary>
            Gets the name of this assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IAssemblySymbol.GlobalNamespace">
            <summary>
            Gets the merged root namespace that contains all namespaces and types defined in the modules
            of this assembly. If there is just one module in this assembly, this property just returns the 
            GlobalNamespace of that module.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IAssemblySymbol.Modules">
            <summary>
            Gets the modules in this assembly. (There must be at least one.) The first one is the main module
            that holds the assembly manifest.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IAssemblySymbol.TypeNames">
            <summary>
            Gets the set of type identifiers from this assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IAssemblySymbol.NamespaceNames">
            <summary>
            Gets the set of namespace names from this assembly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IAssemblySymbol.GivesAccessTo(Microsoft.CodeAnalysis.IAssemblySymbol)">
            <summary>
            Gets a value indicating whether this assembly gives 
            <paramref name="toAssembly"/> access to internal symbols</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IAssemblySymbol.GetTypeByMetadataName(System.String)">
            <summary>
            Lookup a type within the assembly using the canonical CLR metadata name of the type.
            </summary>
            <param name="fullyQualifiedMetadataName">Type name.</param>
            <returns>Symbol for the type or null if type cannot be found or is ambiguous. </returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IAssemblySymbol.MightContainExtensionMethods">
            <summary>
            Determines if the assembly might contain extension methods.
            If false, the assembly does not contain extension methods.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IAssemblySymbol.ResolveForwardedType(System.String)">
            <summary>
            Returns the type symbol for a forwarded type based its canonical CLR metadata name.
            The name should refer to a non-nested type. If type with this name is not forwarded,
            null is returned.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IDynamicTypeSymbol">
            <summary>
            Represents the 'dynamic' type in C#.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IErrorTypeSymbol">
            <summary>
            An IErrorTypeSymbol is used when the compiler cannot determine a symbol object to return because
            of an error. For example, if a field is declared "Foo x;", and the type "Foo" cannot be
            found, an IErrorTypeSymbol is returned when asking the field "x" what it's type is.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IErrorTypeSymbol.CandidateSymbols">
            <summary>
            When constructing this type, there may have been symbols that seemed to
            be what the user intended, but were unsuitable. For example, a type might have been
            inaccessible, or ambiguous. This property returns the possible symbols that the user
            might have intended. It will return no symbols if no possible symbols were found.
            See the CandidateReason property to understand why the symbols were unsuitable.
            </summary>
            <remarks>
            This only applies if this INamedTypeSymbol has TypeKind TypeKind.Error.
            If not, an empty ImmutableArray is returned.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IErrorTypeSymbol.CandidateReason">
            <summary>
             If CandidateSymbols returns one or more symbols, returns the reason that those
             symbols were not chosen. Otherwise, returns None.
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IEventSymbol">
            <summary>
            Represents an event.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IEventSymbol.Type">
            <summary>
            The type of the event. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IEventSymbol.IsWindowsRuntimeEvent">
            <summary>
            Returns true if the event is a WinRT type event.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IEventSymbol.AddMethod">
            <summary>
            The 'add' accessor of the event.  Null only in error scenarios.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IEventSymbol.RemoveMethod">
            <summary>
            The 'remove' accessor of the event.  Null only in error scenarios.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IEventSymbol.RaiseMethod">
            <summary>
            The 'raise' accessor of the event.  Null if there is no raise method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IEventSymbol.OriginalDefinition">
            <summary>
            The original definition of the event. If the event is constructed from another
            symbol by type substitution, OriginalDefinition gets the original symbol, as it was 
            defined in source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IEventSymbol.OverriddenEvent">
            <summary>
            Returns the overridden event, or null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IEventSymbol.ExplicitInterfaceImplementations">
            <summary>
            Returns interface properties explicitly implemented by this event.
            </summary>
            <remarks>
            Properties imported from metadata can explicitly implement more than one event.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IFieldSymbol">
            <summary>
            Represents a field in a class, struct or enum.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IFieldSymbol.AssociatedSymbol">
            <summary>
            If this field serves as a backing variable for an automatically generated
            property or a field-like event or a Primary Constructor parameter, returns that 
            property/event/parameter. Otherwise returns null.
            Note, the set of possible associated symbols might be expanded in the future to 
            reflect changes in the languages.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IFieldSymbol.IsConst">
            <summary>
            Returns true if this field was declared as "const" (i.e. is a constant declaration).
            Also returns true for an enum member.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IFieldSymbol.IsReadOnly">
            <summary>
            Returns true if this field was declared as "readonly". 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IFieldSymbol.IsVolatile">
            <summary>
            Returns true if this field was declared as "volatile". 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IFieldSymbol.Type">
            <summary>
            Gets the type of this field.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IFieldSymbol.HasConstantValue">
            <summary>
            Returns false if the field wasn't declared as "const", or constant value was omitted or errorneous.
            True otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IFieldSymbol.ConstantValue">
            <summary>
            Gets the constant value of this field
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IFieldSymbol.CustomModifiers">
            <summary>
            Gets the list of custom modifiers, if any, associated with the field.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IFieldSymbol.OriginalDefinition">
            <summary>
            Get the original definition of this symbol. If this symbol is derived from another
            symbol by (say) type substitution, this gets the original symbol, as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ILabelSymbol">
            <summary>
            Represents a label in method body
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ILabelSymbol.ContainingMethod">
            <summary>
            Gets the immediately containing <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/> of this <see cref="T:Microsoft.CodeAnalysis.ILocalSymbol"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ILocalSymbol">
            <summary>
            Represents a local variable in method body.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ILocalSymbol.Type">
            <summary>
            Gets the type of this local variable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ILocalSymbol.IsConst">
            <summary>
            Returns true if this local variable was declared as "const" (i.e. is a constant declaration).
            Also returns true for an enum member.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ILocalSymbol.HasConstantValue">
            <summary>
            Returns false if the local variable wasn't declared as "const", or constant value was omitted or erroneous.
            True otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ILocalSymbol.ConstantValue">
            <summary>
            Gets the constant value of this local variable.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IMethodSymbol">
            <summary>
            Represents a method or method-like symbol (including constructor,
            destructor, operator, or property/event accessor).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.MethodKind">
            <summary>
            Gets what kind of method this is. There are several different kinds of things in the
            C# language that are represented as methods. This property allow distinguishing those things
            without having to decode the name of the method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.Arity">
            <summary>
            Returns the arity of this method, or the number of type parameters it takes.
            A non-generic method has zero arity.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.IsGenericMethod">
            <summary>
            Returns whether this method is generic; i.e., does it have any type parameters?
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.IsExtensionMethod">
            <summary>
            Returns true if this method is an extension method. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.IsAsync">
            <summary>
            Returns true if this method is an async method
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.IsVararg">
             <summary>
             Returns whether this method is using CLI VARARG calling convention. This is used for
             C-style variable argument lists. This is used extremely rarely in C# code and is
             represented using the undocumented “__arglist” keyword.
            
             Note that methods with “params” on the last parameter are indicated with the “IsParams”
             property on ParameterSymbol, and are not represented with this property.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.IsCheckedBuiltin">
            <summary>
            Returns whether this built-in operator checks for integer overflow.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.HidesBaseMethodsByName">
            <summary>
            Returns true if this method hides base methods by name. This cannot be specified directly
            in the C# language, but can be true for methods defined in other languages imported from
            metadata. The equivalent of the "hidebyname" flag in metadata. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.ReturnsVoid">
            <summary>
            Returns true if this method has no return type; i.e., returns "void".
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.ReturnType">
            <summary>
            Gets the return type of the method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.TypeArguments">
            <summary>
            Returns the type arguments that have been substituted for the type parameters. 
            If nothing has been substituted for a given type parameter,
            then the type parameter itself is consider the type argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.TypeParameters">
            <summary>
            Get the type parameters on this method. If the method has not generic,
            returns an empty list.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.Parameters">
            <summary>
            Gets the parameters of this method. If this method has no parameters, returns
            an empty list.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.ConstructedFrom">
            <summary>
            Returns the method symbol that this method was constructed from. The resulting
            method symbol
            has the same containing type (if any), but has type arguments that are the same
            as the type parameters (although its containing type might not).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.OriginalDefinition">
            <summary>
            Get the original definition of this symbol. If this symbol is derived from another
            symbol by (say) type substitution, this gets the original symbol, as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.OverriddenMethod">
            <summary>
            If this method overrides another method (because it both had the override modifier
            and there correctly was a method to override), returns the overridden method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.ReceiverType">
            <summary>
            If this method can be applied to an object, returns the type of object it is applied to.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.ReducedFrom">
            <summary>
            If this method is a reduced extension method, returns the definition of extension
            method from which this was reduced. Otherwise, returns null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IMethodSymbol.GetTypeInferredDuringReduction(Microsoft.CodeAnalysis.ITypeParameterSymbol)">
            <summary>
            If this method is a reduced extension method, returns a type inferred during reduction process for the type parameter. 
            </summary>
            <param name="reducedFromTypeParameter">Type parameter of the corresponding <see cref="P:Microsoft.CodeAnalysis.IMethodSymbol.ReducedFrom"/> method.</param>
            <returns>Inferred type or Nothing if nothing was inferred.</returns>
            <exception cref="T:System.InvalidOperationException">If this is not a reduced extension method.</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="reducedFromTypeParameter"/> is null.</exception>
            <exception cref="T:System.ArgumentException">If <paramref name="reducedFromTypeParameter"/> doesn't belong to the corresponding <see cref="P:Microsoft.CodeAnalysis.IMethodSymbol.ReducedFrom"/> method.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IMethodSymbol.ReduceExtensionMethod(Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            If this is an extension method that can be applied to a receiver of the given type,
            returns a reduced extension method symbol thus formed. Otherwise, returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.ExplicitInterfaceImplementations">
            <summary>
            Returns interface methods explicitly implemented by this method.
            </summary>
            <remarks>
            Methods imported from metadata can explicitly implement more than one method, 
            that is why return type is ImmutableArray.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.ReturnTypeCustomModifiers">
            <summary>
            Returns the list of custom modifiers, if any, associated with the returned value. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IMethodSymbol.GetReturnTypeAttributes">
            <summary>
            Returns the list of custom attributes, if any, associated with the returned value. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.AssociatedSymbol">
            <summary>
            Returns a symbol (e.g. property, event, etc.) associated with the method.
            </summary>
            <remarks>
            If this method has <see cref="P:Microsoft.CodeAnalysis.IMethodSymbol.MethodKind"/> of <see cref="F:Microsoft.CodeAnalysis.MethodKind.PropertyGet"/> or <see cref="F:Microsoft.CodeAnalysis.MethodKind.PropertySet"/>,
            returns the property that this method is the getter or setter for.
            If this method has <see cref="P:Microsoft.CodeAnalysis.IMethodSymbol.MethodKind"/> of <see cref="F:Microsoft.CodeAnalysis.MethodKind.EventAdd"/> or <see cref="F:Microsoft.CodeAnalysis.MethodKind.EventRemove"/>,
            returns the event that this method is the adder or remover for.
            Note, the set of possible associated symbols might be expanded in the future to 
            reflect changes in the languages.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IMethodSymbol.Construct(Microsoft.CodeAnalysis.ITypeSymbol[])">
            <summary>
            Returns a constructed method given its type arguments.
            </summary>
            <param name="typeArguments">The immediate type arguments to be replaced for type
            parameters in the method.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.PartialDefinitionPart">
            <summary>
            If this is a partial method implementation part, returns the corresponding
            definition part.  Otherwise null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.PartialImplementationPart">
            <summary>
            If this is a partial method declaration without a body, and the method is
            implemented with a body, returns that implementing definition.  Otherwise
            null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IMethodSymbol.GetDllImportData">
            <summary>
            Platform invoke information, or null if the method isn't a P/Invoke.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.AssociatedAnonymousDelegate">
            <summary>
            If this method is a Lambda method (MethodKind = MethodKind.LambdaMethod) and 
            there is an anonymous delegate associated with it, returns this delegate.
            
            Returns null if the symbol is not a lambda or if it does not have an
            anonymous delegate associated with it.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IModuleSymbol">
            <summary>
            Represents a module within an assembly. Every assembly contains one or more modules.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IModuleSymbol.GlobalNamespace">
            <summary>
            Returns a NamespaceSymbol representing the global (root) namespace, with
            module extent, that can be used to browse all of the symbols defined in this module.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IModuleSymbol.GetModuleNamespace(Microsoft.CodeAnalysis.INamespaceSymbol)">
            <summary>
            Given a namespace symbol, returns the corresponding module specific namespace symbol
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IModuleSymbol.ReferencedAssemblies">
            <summary>
            Returns an array of assembly identities for assemblies referenced by this module.
            Items at the same position from ReferencedAssemblies and from ReferencedAssemblySymbols 
            correspond to each other.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IModuleSymbol.ReferencedAssemblySymbols">
            <summary>
            Returns an array of AssemblySymbol objects corresponding to assemblies referenced 
            by this module. Items at the same position from ReferencedAssemblies and 
            from ReferencedAssemblySymbols correspond to each other.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.INamedTypeSymbol">
            <summary>
            Represents a type other than an array, a pointer, a type parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.Arity">
            <summary>
            Returns the arity of this type, or the number of type parameters it takes.
            A non-generic type has zero arity.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.IsGenericType">
            <summary>
            True if this type or some containing type has type parameters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.IsUnboundGenericType">
            <summary>
            True if this is a reference to an <em>unbound</em> generic type. A generic type is
            considered <em>unbound</em> if all of the type argument lists in its fully qualified
            name are empty. Note that the type arguments of an unbound generic type will be
            returned as error types because they do not really have type arguments.  An unbound
            generic type yields null for its BaseType and an empty result for its Interfaces.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.IsScriptClass">
            <summary>
            Returns true if the type is a Script class. 
            It might be an interactive submission class or a Script class in a csx file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.IsImplicitClass">
            <summary>
            Returns true if the type is the implicit class that holds onto invalid global members (like methods or
            statements in a non script file).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.MemberNames">
            <summary>
            Returns collection of names of members declared within this type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.TypeParameters">
            <summary>
            Returns the type parameters that this type has. If this is a non-generic type,
            returns an empty ImmutableArray.  
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.TypeArguments">
            <summary>
            Returns the type arguments that have been substituted for the type parameters. 
            If nothing has been substituted for a give type parameters,
            then the type parameter itself is consider the type argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.OriginalDefinition">
            <summary>
            Get the original definition of this type symbol. If this symbol is derived from another
            symbol by (say) type substitution, this gets the original symbol, as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.DelegateInvokeMethod">
            <summary>
            For delegate types, gets the delegate's invoke method.  Returns null on
            all other kinds of types.  Note that is is possible to have an ill-formed
            delegate type imported from metadata which does not have an Invoke method.
            Such a type will be classified as a delegate but its DelegateInvokeMethod
            would be null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.EnumUnderlyingType">
            <summary>
            For enum types, gets the underlying type. Returns null on all other
            kinds of types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.ConstructedFrom">
            <summary>
            Returns the type symbol that this type was constructed from. This type symbol
            has the same containing type (if any), but has type arguments that are the same
            as the type parameters (although its containing type might not).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.INamedTypeSymbol.Construct(Microsoft.CodeAnalysis.ITypeSymbol[])">
            <summary>
            Returns a constructed type given its type arguments.
            </summary>
            <param name="typeArguments">The immediate type arguments to be replaced for type
            parameters in the type.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.INamedTypeSymbol.ConstructUnboundGenericType">
            <summary>
            Returns an unbound generic type of this named type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.InstanceConstructors">
            <summary>
            Get the instance constructors for this type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.StaticConstructors">
            <summary>
            Get the static constructors for this type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.Constructors">
            <summary>
            Get the both instance and static constructors for this type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.AssociatedSymbol">
            <summary>
            For implicitly declared delegate types returns the EventSymbol that caused this
            delegate type to be generated.
            For all other types returns null.
            Note, the set of possible associated symbols might be expanded in the future to 
            reflect changes in the languages.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.MightContainExtensionMethods">
            <summary>
            Determines if the symbol might contain extension methods. 
            If false, the symbol does not contain extension methods. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.INamespaceOrTypeSymbol">
            <summary>
            Represents either a namespace or a type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.INamespaceOrTypeSymbol.GetMembers">
            <summary>
            Get all the members of this symbol.
            </summary>
            <returns>An ImmutableArray containing all the members of this symbol. If this symbol has no members,
            returns an empty ImmutableArray. Never returns Null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.INamespaceOrTypeSymbol.GetMembers(System.String)">
            <summary>
            Get all the members of this symbol that have a particular name.
            </summary>
            <returns>An ImmutableArray containing all the members of this symbol with the given name. If there are
            no members with this name, returns an empty ImmutableArray. Never returns Null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.INamespaceOrTypeSymbol.GetTypeMembers">
            <summary>
            Get all the members of this symbol that are types.
            </summary>
            <returns>An ImmutableArray containing all the types that are members of this symbol. If this symbol has no type members,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.INamespaceOrTypeSymbol.GetTypeMembers(System.String)">
            <summary>
            Get all the members of this symbol that are types that have a particular name, of any arity.
            </summary>
            <returns>An ImmutableArray containing all the types that are members of this symbol with the given name.
            If this symbol has no type members with this name,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.INamespaceOrTypeSymbol.GetTypeMembers(System.String,System.Int32)">
            <summary>
            Get all the members of this symbol that are types that have a particular name and arity
            </summary>
            <returns>An ImmutableArray containing all the types that are members of this symbol with the given name and arity.
            If this symbol has no type members with this name and arity,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamespaceOrTypeSymbol.IsNamespace">
            <summary>
            Returns true if this symbol is a namespace. If it is not a namespace, it must be a type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamespaceOrTypeSymbol.IsType">
            <summary>
            Returns true if this symbols is a type. If it is not a type, it must be a namespace.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.INamespaceSymbol">
            <summary>
            Represents a namespace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.INamespaceSymbol.GetMembers">
            <summary>
            Get all the members of this symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.INamespaceSymbol.GetMembers(System.String)">
            <summary>
            Get all the members of this symbol that have a particular name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.INamespaceSymbol.GetNamespaceMembers">
            <summary>
            Get all the members of this symbol that are namespaces.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamespaceSymbol.IsGlobalNamespace">
            <summary>
            Returns whether this namespace is the unnamed, global namespace that is 
            at the root of all namespaces.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamespaceSymbol.NamespaceKind">
            <summary>
            The kind of namespace: Module, Assembly or Compilation.
            Module namespaces contain only members from the containing module that share the same namespace name.
            Assembly namespaces contain members for all modules in the containing assembly that share the same namespace name.
            Compilation namespaces contain all members, from source or referenced metadata (assemblies and modules) that share the same namespace name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamespaceSymbol.ContainingCompilation">
            <summary>
            The containing compilation for compilation namespaces.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamespaceSymbol.ConstituentNamespaces">
            <summary>
            If a namespace is an assembly or compilation namespace, it may be composed of multiple
            namespaces that are merged together. If so, ConstituentNamespaces returns
            all the namespaces that were merged. If this namespace was not merged, returns
            an array containing only this namespace.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IParameterSymbol">
            <summary>
            Represents a parameter of a method or property.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IParameterSymbol.RefKind">
            <summary>
            Whether the parameter passed by value or by reference.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IParameterSymbol.IsParams">
            <summary>
            Returns true if the parameter was declared as a parameter array. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IParameterSymbol.IsOptional">
            <summary>
            Returns true if the parameter is optional.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IParameterSymbol.IsThis">
            <summary>
            Returns true if the parameter is the hidden 'this' ('Me' in Visual Basic) parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IParameterSymbol.Type">
            <summary>
            Gets the type of the parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IParameterSymbol.CustomModifiers">
            <summary>
            The list of custom modifiers, if any, associated with the parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IParameterSymbol.Ordinal">
            <summary>
            Gets the ordinal position of the parameter. The first parameter has ordinal zero.
            The 'this' parameter ('Me' in Visual Basic) has ordinal -1.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IParameterSymbol.HasExplicitDefaultValue">
            <summary>
            Returns true if the parameter specifies a default value to be passed
            when no value is provided as an argument to a call. The default value
            can be obtained with the DefaultValue property.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IParameterSymbol.ExplicitDefaultValue">
            <summary>
            Returns the default value of the parameter. 
            </summary>
            <remarks>
            Returns null if the parameter type is a struct and the default value of the parameter
            is the default value of the struct type.
            </remarks>
            <exception cref="T:System.InvalidOperationException">The parameter has no default value.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IParameterSymbol.OriginalDefinition">
            <summary>
            Get the original definition of this symbol. If this symbol is derived from another
            symbol by (say) type substitution, this gets the original symbol, as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IPointerTypeSymbol">
            <summary>
            Represents a pointer type such as "int *". Pointer types
            are used only in unsafe code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPointerTypeSymbol.PointedAtType">
            <summary>
            Gets the type of the storage location that an instance of the pointer type points to.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPointerTypeSymbol.CustomModifiers">
            <summary>
            The list of custom modifiers, if any, associated with the pointer type.
            (Some managed languages may represent special information about the pointer type
            as a custom modifier on either the pointer type or the element type, or
            both.)
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IPreprocessingSymbol">
            <summary>
            Represents a preprocessing conditional compilation symbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IPropertySymbol">
            <summary>
            Represents a property or indexer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPropertySymbol.IsIndexer">
            <summary>
            Returns whether the property is really an indexer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPropertySymbol.IsReadOnly">
            <summary>
            True if this is a read-only property; that is, a property with no set accessor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPropertySymbol.IsWriteOnly">
            <summary>
            True if this is a write-only property; that is, a property with no get accessor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPropertySymbol.IsWithEvents">
            <summary>
            Returns true if this property is an auto-created WithEvents property that takes place of
            a field member when the field is marked as WithEvents.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPropertySymbol.Type">
            <summary>
            The type of the property. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPropertySymbol.Parameters">
            <summary>
            The parameters of this property. If this property has no parameters, returns
            an empty list. Parameters are only present on indexers, or on some properties
            imported from a COM interface.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPropertySymbol.GetMethod">
            <summary>
            The 'get' accessor of the property, or null if the property is write-only.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPropertySymbol.SetMethod">
            <summary>
            The 'set' accessor of the property, or null if the property is read-only.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPropertySymbol.OriginalDefinition">
            <summary>
            The original definition of the property. If the property is constructed from another
            symbol by type substitution, OriginalDefinition gets the original symbol, as it was 
            defined in source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPropertySymbol.OverriddenProperty">
            <summary>
            Returns the overridden property, or null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPropertySymbol.ExplicitInterfaceImplementations">
            <summary>
            Returns interface properties explicitly implemented by this property.
            </summary>
            <remarks>
            Properties imported from metadata can explicitly implement more than one property.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPropertySymbol.TypeCustomModifiers">
            <summary>
            The list of custom modifiers, if any, associated with the type of the property. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IRangeVariableSymbol">
            <summary>
            Represents a range variable in a query expression.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ISymbol">
            <summary>
            Represents a symbol (namespace, class, method, parameter, etc.)
            exposed by the compiler.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.Kind">
            <summary>
            Gets the <see cref="E:Microsoft.CodeAnalysis.SymbolKind"/> indicating what kind of symbol it is.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.Language">
            <summary>
            Gets the source language ("C#" or "Visual Basic").
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.Name">
            <summary>
            Gets the symbol name. Returns the empty string if unnamed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.MetadataName">
            <summary>
            Gets the name of a symbol as it appears in metadata. Most of the time, this
            is the same as the Name property, with the following exceptions:
            1) The metadata name of generic types includes the "`1", "`2" etc. suffix that
            indicates the number of type parameters (it does not include, however, names of
            containing types or namespaces).
            2) The metadata name of explicit interface names have spaces removed, compared to
            the name property.
            3) The length of names is limited to not exceed metadata restrictions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.ContainingSymbol">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> for the immediately containing symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.ContainingAssembly">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.IAssemblySymbol"/> for the containing assembly. Returns null if the
            symbol is shared across multiple assemblies.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.ContainingModule">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.IModuleSymbol"/> for the containing module. Returns null if the
            symbol is shared across multiple modules.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.ContainingType">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> for the containing type. Returns null if the
            symbol is not contained within a type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.ContainingNamespace">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.INamespaceSymbol"/> for the nearest enclosing namespace. Returns null if the
            symbol isn't contained in a namespace.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.IsDefinition">
            <summary>
            Gets a value indicating whether the symbol is the original definition. Returns false
            if the symbol is derived from another symbol, by type substitution for instance.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.IsStatic">
            <summary>
            Gets a value indicating whether the symbol is static.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.IsVirtual">
            <summary>
            Gets a value indicating whether the symbol is virtual.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.IsOverride">
            <summary>
            Gets a value indicating whether the symbol is an override of a base class symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.IsAbstract">
            <summary>
            Gets a value indicating whether the symbol is abstract.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.IsSealed">
            <summary>
            Gets a value indicating whether the symbol is sealed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.IsExtern">
            <summary>
            Gets a value indicating whether the symbol is defined externally.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.IsImplicitlyDeclared">
            <summary>
            Returns true if this symbol was automatically created by the compiler, and does not have
            an explicit corresponding source code declaration.  
            
            This is intended for symbols that are ordinary symbols in the language sense, and may be
            used by code, but that are simply declared implicitly rather than with explicit language
            syntax.
            
            Examples include (this list is not exhaustive):
              the default constructor for a class or struct that is created if one is not provided,
              the BeginInvoke/Invoke/EndInvoke methods for a delegate,
              the generated backing field for an auto property or a field-like event,
              the "this" parameter for non-static methods,
              the "value" parameter for a property setter,
              the parameters on indexer accessor methods (not on the indexer itself),
              methods in anonymous types
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.CanBeReferencedByName">
            <summary>
            Returns true if this symbol can be referenced by its name in code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.Locations">
            <summary>
            Gets the locations where the symbol was originally defined, either in source or
            metadata. Some symbols (for example, partial classes) may be defined in more than one
            location.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.DeclaringSyntaxReferences">
            <summary>
            Get the syntax node(s) where this symbol was declared in source. Some symbols (for example,
            partial classes) may be defined in more than one location. This property should return
            one or more syntax nodes only if the symbol was declared in source code and also was
            not implicitly declared (see the IsImplicitlyDeclared property). 
            
            Note that for namespace symbol, the declaring syntax might be declaring a nested namespace.
            For example, the declaring syntax node for N1 in "namespace N1.N2 {...}" is the entire
            NamespaceDeclarationSyntax for N1.N2. For the global namespace, the declaring syntax will
            be the CompilationUnitSyntax.
            </summary>
            <returns>
            The syntax node(s) that declared the symbol. If the symbol was declared in metadata
            or was implicitly declared, returns an empty read-only array.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ISymbol.GetAttributes">
            <summary>
            Gets the attributes for the symbol. Returns an empty <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            if there are no attributes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.DeclaredAccessibility">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.Accessibility"/> indicating the declared accessibility for the symbol.
            Returns NotApplicable if no accessibility is declared.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.OriginalDefinition">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> for the original definition of the symbol.
            If this symbol is derived from another symbol, by type substitution for instance,
            this gets the original symbol, as it was defined in source or metadata.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ISymbol.GetDocumentationCommentId">
            <summary>
            Returns the Documentation Comment ID for the symbol, or null if the symbol doesn't
            support documentation comments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ISymbol.GetDocumentationCommentXml(System.Globalization.CultureInfo,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Gets the XML (as text) for the comment associated with the symbol.
            </summary>
            <param name="preferredCulture">Preferred culture or null for the default.</param>
            <param name="expandIncludes">Optionally, expand &lt;include&gt; elements.  No impact on non-source documentation comments.</param>
            <param name="cancellationToken">Token allowing cancellation of request.</param>
            <returns>The XML that would be written to the documentation file for the symbol.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ISymbol.ToDisplayString(Microsoft.CodeAnalysis.SymbolDisplayFormat)">
            <summary>
            Converts the symbol to a string representation.
            </summary>
            <param name="format">Format or null for the default.</param>
            <returns>A formatted string representation of the symbol.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ISymbol.ToDisplayParts(Microsoft.CodeAnalysis.SymbolDisplayFormat)">
            <summary>
            Convert a symbol to an array of string parts, each of which has a kind. Useful for
            colorizing the display string.
            </summary>
            <param name="format">Formatting rules - null implies
            SymbolDisplayFormat.ErrorMessageFormat.</param>
            <returns>A read-only array of string parts.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ISymbol.ToMinimalDisplayString(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SymbolDisplayFormat)">
            <summary>
            Convert a symbol to a string that can be displayed to the user. May be tailored to a
            specific location in the source code.
            </summary>
            <param name="semanticModel">Binding information (for determining names appropriate to
            the context).</param>
            <param name="position">A position in the source code (context).</param>
            <param name="format">Formatting rules - null implies
            SymbolDisplayFormat.MinimallyQualifiedFormat.</param>
            <returns>A formatted string that can be displayed to the user.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ISymbol.ToMinimalDisplayParts(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SymbolDisplayFormat)">
            <summary>
            Convert a symbol to an array of string parts, each of which has a kind. May be tailored
            to a specific location in the source code. Useful for colorizing the display string.
            </summary>
            <param name="semanticModel">Binding information (for determining names appropriate to
            the context).</param>
            <param name="position">A position in the source code (context).</param>
            <param name="format">Formatting rules - null implies
            SymbolDisplayFormat.MinimallyQualifiedFormat.</param>
            <returns>A read-only array of string parts.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.HasUnsupportedMetadata">
            <summary>
            Indicates that this symbol uses metadata that cannot be supported by the language.
            
            Examples include:
               - Pointer types in VB
               - ByRef return type
               - Required custom modifiers
               
            This is distinguished from, for example, references to metadata symbols defined in assemblies that weren't referenced.
            Symbols where this returns true can never be used successfully, and thus should never appear in any IDE feature.
            
            This is set for metadata symbols, as follows:
            Type - if a type is unsupported (e.g., a pointer type, etc.)
            Method - parameter or return type is unsupported
            Field - type is unsupported
            Event - type is unsupported
            Property - type is unsupported
            Parameter - type is unsupported
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ISymbolExtensions.GetConstructedReducedFrom(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Returns the constructed form of the ReducedFrom property,
            including the type arguments that were either inferred during reduction or supplied at the call site.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol">
            <summary>
            Synthesized symbol that implements a method body feature (iterator, async, lambda, etc.)
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.Method">
            <summary>
            The symbol whose body lowering produced this synthesized symbol, 
            or null if the symbol is synthesized based on declaration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.HasMethodBodyDependency">
            <summary>
            True if this symbol body needs to be updated when the <see cref="P:Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.Method"/> body is updated.
            False if <see cref="P:Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.Method"/> is null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ITypeParameterSymbol">
            <summary>
            Represents a type parameter in a generic type or generic method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.Ordinal">
            <summary>
            The ordinal position of the type parameter in the parameter list which declares
            it. The first type parameter has ordinal zero.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.Variance">
            <summary>
            The variance annotation, if any, of the type parameter declaration. Type parameters may be 
            declared as covariant (<c>out</c>), contravariant (<c>in</c>), or neither.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.TypeParameterKind">
            <summary>
            The type parameter kind of this type parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.DeclaringMethod">
            <summary>
            The method that declares the type parameter, or null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.DeclaringType">
            <summary>
            The type that declares the type parameter, or null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.HasReferenceTypeConstraint">
            <summary>
            True if the reference type constraint (<c>class</c>) was specified for the type parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.HasValueTypeConstraint">
            <summary>
            True if the value type constraint (<c>struct</c>)was specified for the type parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.HasConstructorConstraint">
            <summary>
            True if the parameterless constructor constraint (<c>new()</c>) was specified for the type parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.ConstraintTypes">
            <summary>
            The types that were directly specified as constraints on the type parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.OriginalDefinition">
            <summary>
            Get the original definition of this type symbol. If this symbol is derived from another
            symbol by (say) type substitution, this gets the original symbol, as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.ReducedFrom">
            <summary>
            If this is a type parameter of a reduced extension method, gets the type parameter definition that
            this type parameter was reduced from. Otherwise, returns Nothing.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeSymbol.TypeKind">
            <summary>
            An enumerated value that identifies whether this type is an array, pointer, enum, and so on.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeSymbol.BaseType">
            <summary>
            The declared base type of this type, or null. The object type, interface types,
            and pointer types do not have a base type. The base type of a type parameter
            is its effective base class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeSymbol.Interfaces">
            <summary>
            Gets the set of interfaces that this type directly implements. This set does not include
            interfaces that are base interfaces of directly implemented interfaces. This does
            include the interfaces declared as constraints on type parameters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeSymbol.AllInterfaces">
            <summary>
            The list of all interfaces of which this type is a declared subtype, excluding this type
            itself. This includes all declared base interfaces, all declared base interfaces of base
            types, and all declared base interfaces of those results (recursively). This also is the effective
            interface set of a type parameter. Each result
            appears exactly once in the list. This list is topologically sorted by the inheritance
            relationship: if interface type A extends interface type B, then A precedes B in the
            list. This is not quite the same as "all interfaces of which this type is a proper
            subtype" because it does not take into account variance: AllInterfaces for
            <c><![CDATA[IEnumerable<string>]]></c> will not include <c><![CDATA[IEnumerable<object>]]></c>;
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeSymbol.IsReferenceType">
            <summary>
            True if this type is known to be a reference type. It is never the case that
            <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.IsReferenceType"/> and <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.IsValueType"/> both return true. However, for an unconstrained type
            parameter, <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.IsReferenceType"/> and <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.IsValueType"/> will both return false.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeSymbol.IsValueType">
            <summary>
            True if this type is known to be a value type. It is never the case that
            <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.IsReferenceType"/> and <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.IsValueType"/> both return true. However, for an unconstrained type
            parameter, <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.IsReferenceType"/> and <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.IsValueType"/> will both return false.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeSymbol.IsAnonymousType">
            <summary>
            Is this a symbol for an anonymous type (including anonymous VB delegate).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeSymbol.OriginalDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.OriginalDefinition"/> gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeSymbol.SpecialType">
            <summary>
            An enumerated value that identifies certain 'special' types such as <see cref="T:System.Object"/>. 
            Returns <see cref="F:Microsoft.CodeAnalysis.SpecialType.None"/> if the type is not special.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ITypeSymbol.FindImplementationForInterfaceMember(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns the corresponding symbol in this type or a base type that implements 
            interfaceMember (either implicitly or explicitly), or null if no such symbol exists
            (which might be either because this type doesn't implement the container of
            interfaceMember, or this type doesn't supply a member that successfully implements
            interfaceMember).
            </summary>
            <param name="interfaceMember">
            Must be a non-null interface property, method, or event.
            </param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageNames">
            <summary>
            A class that provides constants for common language names.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageNames.CSharp">
            <summary>
            The common name used from the C# language.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageNames.VisualBasic">
            <summary>
            The common name used for the Visual Basic language.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MethodKind">
            <summary>
            Enumeration for possible kinds of method symbols.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.AnonymousFunction">
            <summary>
            An anonymous method or lambda expression
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.Constructor">
            <summary>
            Method is a constructor.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.Conversion">
            <summary>
            Method is a conversion.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.DelegateInvoke">
            <summary>
            Method is a delegate invoke.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.Destructor">
            <summary>
            Method is a destructor.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.EventAdd">
            <summary>
            Method is an event add.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.EventRaise">
            <summary>
            Method is an event raise.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.EventRemove">
            <summary>
            Method is an event remove.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.ExplicitInterfaceImplementation">
            <summary>
            Method is an explicit interface implementation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.UserDefinedOperator">
            <summary>
            Method is an operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.Ordinary">
            <summary>
            Method is an ordinary method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.PropertyGet">
            <summary>
            Method is a property get.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.PropertySet">
            <summary>
            Method is a property set.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.ReducedExtension">
            <summary>
            An extension method with the "this" parameter removed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.StaticConstructor">
            <summary>
            Method is a static constructor.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.BuiltinOperator">
            <summary>
            A built-in operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.DeclareMethod">
            <summary>
            Declare Sub or Function.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.NamespaceKind">
            <summary>
            Describes the kind of the namespace extent.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DllImportData">
            <summary>
            Information that describes how a method from the underlying Platform is to be invoked.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DllImportData.ModuleName">
            <summary>
            Module name. Null if value specified in the attribute is not valid.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DllImportData.EntryPointName">
            <summary>
            Name of the native entry point or null if not specified (the effective name is the same as the name of the target method).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DllImportData.ExactSpelling">
            <summary>
            Controls whether the <see cref="P:CharacterSet"/> field causes the common language runtime 
            to search an unmanaged DLL for entry-point names other than the one specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DllImportData.CharacterSet">
            <summary>
            Indicates how to marshal string parameters and controls name mangling.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DllImportData.SetLastError">
            <summary>
            Indicates whether the callee calls the SetLastError Win32 API function before returning from the attributed method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DllImportData.CallingConvention">
            <summary>
            Indicates the calling convention of an entry point.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DllImportData.BestFitMapping">
            <summary>
            Enables or disables best-fit mapping behavior when converting Unicode characters to ANSI characters.
            Null if not specified (the setting for the containing type or assembly should be used, <see cref="T:System.Runtime.InteropServices.BestFitMappingAttribute"/>).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DllImportData.ThrowOnUnmappableCharacter">
            <summary>
            Enables or disables the throwing of an exception on an unmappable Unicode character that is converted to an ANSI "?" character.
            Null if not specified.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RefKind">
            <summary>
            Denotes the kind of reference parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RefKind.None">
            <summary>
            Indicates a "value" parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RefKind.Ref">
            <summary>
            Indicates a "ref" parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RefKind.Out">
            <summary>
            Indicates an "out" parameter.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolKind">
            <summary>
            Specifies the possible kinds of symbols.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.Alias">
            <summary>
            Symbol is an alias.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.ArrayType">
            <summary>
            Symbol is an array type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.Assembly">
            <summary>
            Symbol is an assembly.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.DynamicType">
            <summary>
            Symbol is a dynamic type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.ErrorType">
            <summary>
            Symbol that represents an error 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.Event">
            <summary>
            Symbol is an Event.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.Field">
            <summary>
            Symbol is a field.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.Label">
            <summary>
            Symbol is a label.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.Local">
            <summary>
            Symbol is a local.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.Method">
            <summary>
            Symbol is a method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.NetModule">
            <summary>
            Symbol is a netmodule.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.NamedType">
            <summary>
            Symbol is a named type (e.g. class).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.Namespace">
            <summary>
            Symbol is a namespace.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.Parameter">
            <summary>
            Symbol is a parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.PointerType">
            <summary>
            Symbol is a pointer type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.Property">
            <summary>
            Symbol is a property.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.RangeVariable">
            <summary>
            Symbol is a range variable of a query expression.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.TypeParameter">
            <summary>
            Symbol is a type parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.Preprocessing">
            <summary>
            Symbol is a preprocessing/conditional compilation constant.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TypedConstant">
            <summary>
            Represents a constant value used as an argument to a custom attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TypedConstant.Kind">
            <summary>
            The kind of the constant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TypedConstant.Type">
            <summary>
            Returns the <see cref="T:Microsoft.CodeAnalysis.ITypeSymbol"/> of the constant, 
            or null if the type can't be determined (error).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TypedConstant.IsNull">
            <summary>
            True if the constant represents a null reference.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TypedConstant.Value">
            <summary>
            The value for a non-array constant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TypedConstant.Values">
            <summary>
            The value for an <see cref="T:Microsoft.CodeAnalysis.TypedConstant"/> array. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TypedConstant.GetTypedConstantKind(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.Compilation)">
            <remarks>
            TypedConstant isn't computing its own kind from the type symbol because it doesn't
            have a way to recognize the well-known type System.Type.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TypedConstantKind">
            <summary>
            Represents the kind of a TypedConstant.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TypedConstantValue">
            <summary>
            Represents a simple value or a read-only array of <see cref="T:Microsoft.CodeAnalysis.TypedConstant"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TypedConstantValue.IsNull">
            <summary>
            True if the constant represents a null literal.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TypeKind">
            <summary>
            Enumeration for possible kinds of type symbols.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKind.Unknown">
            <summary>
            Type's kind is undefined.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKind.ArrayType">
            <summary>
            Type is an array type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKind.Class">
            <summary>
            Type is a class.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKind.Delegate">
            <summary>
            Type is a delegate.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKind.DynamicType">
            <summary>
            Type is dynamic.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKind.Enum">
            <summary>
            Type is an enumeration.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKind.Error">
            <summary>
            Type is an error type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKind.Interface">
            <summary>
            Type is an interface.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKind.Module">
            <summary>
            Type is a module.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKind.PointerType">
            <summary>
            Type is a pointer.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKind.Struct">
            <summary>
            Type is a C# struct or VB Structure
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKind.Structure">
            <summary>
            Type is a C# struct or VB Structure
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKind.TypeParameter">
            <summary>
            Type is a type parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKind.Submission">
            <summary>
            Type is an interactive submission.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TypeLayout">
            <summary>
            Type layout information.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TypeLayout.Kind">
            <summary>
            Layout kind (Layout flags in metadata).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TypeLayout.Alignment">
            <summary>
            Field alignment (PackingSize field in metadata).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TypeLayout.Size">
            <summary>
            Size of the type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TypeParameterKind">
            <summary>
            Represents the different kinds of type parameters.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeParameterKind.Type">
            <summary>
            Type parameter of a named type. For example: <c>T</c> in <c><![CDATA[List<T>]]></c>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeParameterKind.Method">
            <summary>
            Type parameter of a method. For example: <c>T</c> in <c><![CDATA[void M<T>()]]></c>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeParameterKind.Cref">
            <summary>
            Type parameter in a <c>cref</c> attribute in XML documentation comments. For example: <c>T</c> in <c><![CDATA[<see cref="List{T}"/>]]></c>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.VarianceKind">
            <summary>
            An enumeration declaring the kinds of variance supported for generic type parameters.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.VarianceKind.None">
            <summary>
            Invariant.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.VarianceKind.Out">
            <summary>
            Covariant (<c>out</c>).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.VarianceKind.In">
            <summary>
            Contravariant (<c>in</c>).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.WellKnownMemberNames">
            <summary>
            Specifies the member names known to the compiler (such as <c>.ctor</c> or <c>op_Explicit</c>).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.EnumBackingFieldName">
            <summary>
            Name of the enum backing field.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.InstanceConstructorName">
            <summary>
            The name assigned to an instance constructor.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.StaticConstructorName">
            <summary>
            The name assigned to the static constructor.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.Indexer">
            <summary>
            The symbol name assigned to all indexers, other than explicit interface implementations.
            </summary>
            <remarks>
            Will not correspond to the name that appears in metadata.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.DestructorName">
            <summary>
            The name assigned to the destructor.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.DelegateInvokeName">
            <summary>
            The name assigned to the delegate <c>Invoke</c> method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.DelegateBeginInvokeName">
            <summary>
            The name assigned to the delegate <c>BeginInvoke</c> method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.DelegateEndInvokeName">
            <summary>
            The name assigned to the delegate <c>EndInvoke</c> method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.EntryPointMethodName">
            <summary>
            The name of an entry point method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.DefaultScriptClassName">
            <summary>
            The default fully qualified name of a <c>Script</c> class.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.ObjectToString">
            <summary>
            The name assigned to <c>Object.ToString</c> method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.ObjectEquals">
            <summary>
            The name assigned to <c>Object.Equals</c> method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.ObjectGetHashCode">
            <summary>
            The name assigned to <c>Object.GetHashCode</c> method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.ImplicitConversionName">
            <summary>
            The name assigned to an implicit (widening) conversion.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.ExplicitConversionName">
            <summary>
            The name assigned to an explicit (narrowing) conversion.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.AdditionOperatorName">
            <summary>
            The name assigned to the Addition operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.BitwiseAndOperatorName">
            <summary>
            The name assigned to the BitwiseAnd operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.BitwiseOrOperatorName">
            <summary>
            The name assigned to the BitwiseOr operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.DecrementOperatorName">
            <summary>
            The name assigned to the Decrement operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.DivisionOperatorName">
            <summary>
            The name assigned to the Division operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.EqualityOperatorName">
            <summary>
            The name assigned to the Equality operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.ExclusiveOrOperatorName">
            <summary>
            The name assigned to the ExclusiveOr operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.FalseOperatorName">
            <summary>
            The name assigned to the False operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.GreaterThanOperatorName">
            <summary>
            The name assigned to the GreaterThan operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.GreaterThanOrEqualOperatorName">
            <summary>
            The name assigned to the GreaterThanOrEqual operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.IncrementOperatorName">
            <summary>
            The name assigned to the Increment operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.InequalityOperatorName">
            <summary>
            The name assigned to the Inequality operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.LeftShiftOperatorName">
            <summary>
            The name assigned to the LeftShift operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.UnsignedLeftShiftOperatorName">
            <summary>
            The name assigned to the UnsignedLeftShift operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.LessThanOperatorName">
            <summary>
            The name assigned to the LessThan operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.LessThanOrEqualOperatorName">
            <summary>
            The name assigned to the LessThanOrEqual operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.LogicalNotOperatorName">
            <summary>
            The name assigned to the LogicalNot operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.LogicalOrOperatorName">
            <summary>
            The name assigned to the LogicalOr operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.LogicalAndOperatorName">
            <summary>
            The name assigned to the LogicalAnd operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.ModulusOperatorName">
            <summary>
            The name assigned to the Modulus operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.MultiplyOperatorName">
            <summary>
            The name assigned to the Multiply operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.OnesComplementOperatorName">
            <summary>
            The name assigned to the OnesComplement operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.RightShiftOperatorName">
            <summary>
            The name assigned to the RightShift operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.UnsignedRightShiftOperatorName">
            <summary>
            The name assigned to the UnsignedRightShift operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.SubtractionOperatorName">
            <summary>
            The name assigned to the Subtraction operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.TrueOperatorName">
            <summary>
            The name assigned to the True operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.UnaryNegationOperatorName">
            <summary>
            The name assigned to the UnaryNegation operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.UnaryPlusOperatorName">
            <summary>
            The name assigned to the UnaryPlus operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.ConcatenateOperatorName">
            <summary>
            The name assigned to the Concatenate operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.ExponentOperatorName">
            <summary>
            The name assigned to the Exponent operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.IntegerDivisionOperatorName">
            <summary>
            The name assigned to the IntegerDivision operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.LikeOperatorName">
            <summary>
            The name assigned to the <c>Like</c> operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.GetEnumeratorMethodName">
            <summary>
            The required name for the <c>GetEnumerator</c> method used in a ForEach statement.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.MoveNextMethodName">
            <summary>
            The required name for the <c>MoveNext</c> method used in a ForEach statement.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.CurrentPropertyName">
            <summary>
            The required name for the <c>Current</c> property used in a ForEach statement.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.ValuePropertyName">
            <summary>
            The required name for the <see cref="P:System.Nullable`1.Value"/> property used in
            a ForEach statement when the collection is a nullable struct.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.CollectionInitializerAddMethodName">
            <summary>
            The name for the <c>Add</c> method to be invoked for each element in a collection initializer expression
            (see C# Specification, �7.6.10.3 Collection initializers).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.GetAwaiter">
            <summary>
            The required name for the <c>GetAwaiter</c> method used to obtain an awaiter for a task
            (see C# Specification, �7.7.7.1 Awaitable expressions).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.IsCompleted">
            <summary>
            The required name for the <c>IsCompleted</c> property used to determine if a task is already complete
            (see C# Specification, �7.7.7.1 Awaitable expressions).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.GetResult">
            <summary>
            The required name for the <c>GetResult</c> method used to obtain the outcome of a task once it is complete
            (see C# Specification, �7.7.7.1 Awaitable expressions).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.OnCompleted">
            <summary>
            The name of the <see cref="M:System.Runtime.CompilerServices.INotifyCompletion.OnCompleted(System.Action)"/> method used to register a resumption delegate
            (see C# Specification, �7.7.7.1 Awaitable expressions).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Syntax.AbstractWarningStateMap.GetWarningState(System.String,System.Int32)">
            <summary>
            Returns the reporting level of the given diagnostic id at the specified position
            in the associated syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Syntax.AbstractWarningStateMap.GetEntryAtOrBeforePosition(Microsoft.CodeAnalysis.Syntax.AbstractWarningStateMap.WarningStateMapEntry[],System.Int32)">
            <summary>
            Gets the position mapped entry in the provided sorted array with the largest position less than or equal to position
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Syntax.AbstractWarningStateMap.WarningStateMapEntry">
            <summary>
            Struct that represents an entry in the warning state map. Sorts by position in the associated syntax tree.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Syntax.TranslationSyntaxReference">
            <summary>
            This is a SyntaxReference implementation that lazily translates the result (SyntaxNode) of the
            original syntax reference to another one.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnnotationExtensions.WithAdditionalAnnotations``1(``0,Microsoft.CodeAnalysis.SyntaxAnnotation[])">
            <summary>
            Creates a new node identical to this node with the specified annotations attached.
            </summary>
            <param name="node">Original node.</param>
            <param name="annotations">Annotations to be added to the new node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnnotationExtensions.WithAdditionalAnnotations``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxAnnotation})">
            <summary>
            Creates a new node identical to this node with the specified annotations attached.
            </summary>
            <param name="node">Original node.</param>
            <param name="annotations">Annotations to be added to the new node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnnotationExtensions.WithoutAnnotations``1(``0,Microsoft.CodeAnalysis.SyntaxAnnotation[])">
            <summary>
            Creates a new node identical to this node with the specified annotations removed.
            </summary>
            <param name="node">Original node.</param>
            <param name="annotations">Annotations to be removed from the new node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnnotationExtensions.WithoutAnnotations``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxAnnotation})">
            <summary>
            Creates a new node identical to this node with the specified annotations removed.
            </summary>
            <param name="node">Original node.</param>
            <param name="annotations">Annotations to be removed from the new node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnnotationExtensions.WithoutAnnotations``1(``0,System.String)">
            <summary>
            Creates a new node identical to this node with the annotions of the specified kind removed.
            </summary>
            <param name="node">Original node.</param>
            <param name="annotationKind">The kind of annotation to remove.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ChildSyntaxList.Count">
            <summary>
            Gets the number of children contained in the <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ChildSyntaxList.Item(System.Int32)">
            <summary>Gets the child at the specified index.</summary>
            <param name="index">The zero-based index of the child to get.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
              <paramref name="index"/> is less than 0.-or-<paramref name="index" /> is equal to or greater than <see cref="P:Microsoft.CodeAnalysis.ChildSyntaxList.Count"/>. </exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.ItemInternal(Microsoft.CodeAnalysis.SyntaxNode,System.Int32)">
            <summary>
            internal indexer that does not verify index.
            Used when caller has already ensured that index is within bounds.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.ItemInternalAsNode(Microsoft.CodeAnalysis.SyntaxNode,System.Int32)">
            <summary>
            internal indexer that does not verify index.
            Used when caller has already ensured that index is within bounds.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.First">
            <summary>
            Returns the first child in the list.
            </summary>
            <returns>The first child in the list.</returns>
            <exception cref="T:System.InvalidOperationException">The list is empty.</exception>    
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.Last">
            <summary>
            Returns the last child in the list.
            </summary>
            <returns>The last child in the list.</returns>
            <exception cref="T:System.InvalidOperationException">The list is empty.</exception>    
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.Reverse">
            <summary>
            Returns a list which contains all children of <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList"/> in reversed order.
            </summary>
            <returns><see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList.Reversed"/> which contains all children of <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList"/> in reversed order</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.GetEnumerator">
            <summary>Returns an enumerator that iterates through the <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList"/>.</summary>
            <returns>A <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList.Enumerator"/> for the <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current instance.</summary>
            <returns>true if the specified object is a <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList" /> structure and is equal to the current instance; otherwise, false.</returns>
            <param name="obj">The object to be compared with the current instance.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.Equals(Microsoft.CodeAnalysis.ChildSyntaxList)">
            <summary>Determines whether the specified <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList" /> structure is equal to the current instance.</summary>
            <returns>true if the specified <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList" /> structure is equal to the current instance; otherwise, false.</returns>
            <param name="other">The <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList" /> structure to be compared with the current instance.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.GetHashCode">
            <summary>Returns the hash code for the current instance.</summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.op_Equality(Microsoft.CodeAnalysis.ChildSyntaxList,Microsoft.CodeAnalysis.ChildSyntaxList)">
            <summary>Indicates whether two <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList" /> structures are equal.</summary>
            <returns>true if <paramref name="list1" /> is equal to <paramref name="list2" />; otherwise, false.</returns>
            <param name="list1">The <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList" /> structure on the left side of the equality operator.</param>
            <param name="list2">The <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList" /> structure on the right side of the equality operator.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.op_Inequality(Microsoft.CodeAnalysis.ChildSyntaxList,Microsoft.CodeAnalysis.ChildSyntaxList)">
            <summary>Indicates whether two <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList" /> structures are unequal.</summary>
            <returns>true if <paramref name="list1" /> is equal to <paramref name="list2" />; otherwise, false.</returns>
            <param name="list1">The <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList" /> structure on the left side of the inequality operator.</param>
            <param name="list2">The <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList" /> structure on the right side of the inequality operator.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ChildSyntaxList.Enumerator">
            <summary>Enumerates the elements of a <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList" />.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.Enumerator.MoveNext">
            <summary>Advances the enumerator to the next element of the <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList" />.</summary>
            <returns>true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ChildSyntaxList.Enumerator.Current">
            <summary>Gets the element at the current position of the enumerator.</summary>
            <returns>The element in the <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList" /> at the current position of the enumerator.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.Enumerator.Reset">
            <summary>Sets the enumerator to its initial position, which is before the first element in the collection.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ChildSyntaxList.EnumeratorImpl.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
              </returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ChildSyntaxList.EnumeratorImpl.System#Collections#IEnumerator#Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
              </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.EnumeratorImpl.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.EnumeratorImpl.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.EnumeratorImpl.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ChildSyntaxList.Reversed.EnumeratorImpl.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
              </returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ChildSyntaxList.Reversed.EnumeratorImpl.System#Collections#IEnumerator#Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
              </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.Reversed.EnumeratorImpl.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.Reversed.EnumeratorImpl.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.Reversed.EnumeratorImpl.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IStructuredTriviaSyntax">
            <summary>
            Represents the root node of a structured trivia tree (for example, a preprocessor directive
            or a documentation comment). From this root node you can traverse back up to the containing
            trivia in the outer tree that contains it.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IStructuredTriviaSyntax.ParentTrivia">
            <summary>
            Returns the parent trivia syntax for this structured trivia syntax.
            </summary>
            <returns>The parent trivia syntax for this structured trivia syntax.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LineDirectiveMap`1">
            <summary>
            The LineDirectiveMap is created to enable translating positions, using the #line directives
            in a file. The basic implementation creates an ordered array of line mapping entries, one
            for each #line directive in the file (plus one at the beginning). If the file has no
            directives, then the array has just one element in in. To map line numbers, a binary search
            of the mapping entries is done and nearest line mapping is applied.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LineDirectiveMap`1.GetLineVisibility(Microsoft.CodeAnalysis.Text.SourceText,System.Int32)">
            <summary>
            Determines whether the position is considered to be hidden from the debugger or not.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LineDirectiveMap`1.TranslateSpanAndVisibility(Microsoft.CodeAnalysis.Text.SourceText,System.String,Microsoft.CodeAnalysis.Text.TextSpan,System.Boolean@)">
            <summary>
            Combines TranslateSpan and IsHiddenPosition to not search the entries twice when emitting sequence points
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LineDirectiveMap`1.HasAnyHiddenRegions">
            <summary>
            Are there any hidden regions in the map?
            </summary>
            <returns>True if there's at least one hidden region in the map.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LineDirectiveMap`1.PositionState">
            <summary>
            Enum that describes the state related to the #line or #externalsource directives at a position in source.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LineDirectiveMap`1.PositionState.Unknown">
            <summary>
            Used in VB when the position is not hidden, but it's not known yet that there is a (nonempty) #ExternalSource
            following.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LineDirectiveMap`1.PositionState.Unmapped">
            <summary>
            Used in C# for spans outside of #line directives
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LineDirectiveMap`1.PositionState.Remapped">
            <summary>
            Used in C# for spans inside of "#line linenumber" directive
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LineDirectiveMap`1.PositionState.RemappedAfterUnknown">
            <summary>
            Used in VB for spans inside of a "#ExternalSource" directive that followed an unknown span
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LineDirectiveMap`1.PositionState.RemappedAfterHidden">
            <summary>
            Used in VB for spans inside of a "#ExternalSource" directive that followed a hidden span
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LineDirectiveMap`1.PositionState.Hidden">
            <summary>
            Used in C# and VB for spans that are inside of #line hidden (C#) or outside of #ExternalSource (VB) 
            directives
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LineVisibility">
            <summary>
            The state of the visibility of a line.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LineVisibility.BeforeFirstLineDirective">
            <summary>
            The line is located before any #line directive and there is at least one #line directive present in this syntax tree.
            This enum value is used for C# only to enable the consumer to define how to interpret the lines before the first
            line directive. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LineVisibility.Hidden">
            <summary>
            The line is following a #line hidden directive.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LineVisibility.Visible">
            <summary>
            The line is following a #line default directive or a #line directive with at least a line number.
            If there is no line directive at all, Visible is returned for all lines.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.GetSeparator(System.Int32)">
            <summary>
            Gets the separator at the given index in this list.
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.GetSeparators">
            <summary>
            Returns the sequence of just the separator tokens.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.FullSpan">
            <summary>
            The absolute span of the list elements in characters, not including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.Span">
            <summary>
            The absolute span of the list elements in characters, including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.ToString">
            <summary>
            Returns the string representation of the nodes in this list including separators but not including 
            the first node's leading trivia and the last node or token's trailing trivia.
            </summary>
            <returns>
            The string representation of the nodes in this list including separators but not including 
            the first node's leading trivia and the last node or token's trailing trivia.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.ToFullString">
            <summary>
            Returns the full string representation of the nodes in this list including separators, 
            the first node's leading trivia, and the last node or token's trailing trivia.
            </summary>
            <returns>
            The full string representation of the nodes in this list including separators including separators,
            the first node's leading trivia, and the last node or token's trailing trivia.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.Add(`0)">
            <summary>
            Creates a new list with the specified node added to the end.
            </summary>
            <param name="node">The node to add.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new list with the specified nodes added to the end.
            </summary>
            <param name="nodes">The nodes to add.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.Insert(System.Int32,`0)">
            <summary>
            Creates a new list with the specified node inserted at the index.
            </summary>
            <param name="index">The index to insert at.</param>
            <param name="node">The node to insert.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new list with the specified nodes inserted at the index.
            </summary>
            <param name="index">The index to insert at.</param>
            <param name="nodes">The nodes to insert.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.RemoveAt(System.Int32)">
            <summary>
            Creates a new list with the element at the specified index removed.
            </summary>
            <param name="index">The index of the element to remove.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.Remove(`0)">
            <summary>
            Creates a new list with specified element removed.
            </summary>
            <param name="node">The element to remove.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.Replace(`0,`0)">
            <summary>
            Creates a new list with the specified element replaced by the new node.
            </summary>
            <param name="nodeInList">The element to replace.</param>
            <param name="newNode">The new node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.ReplaceRange(`0,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new list with the specified element replaced by the new nodes.
            </summary>
            <param name="nodeInList">The element to replace.</param>
            <param name="newNodes">The new nodes.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.ReplaceSeparator(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Creates a new list with the specified separator token replaced with the new separator.
            </summary>
            <param name="separatorToken">The separator token to be replaced.</param>
            <param name="newSeparator">The new separator token.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxAnnotation">
            <summary>
            A SynatxAnnotation is used to annotate syntax elements with additional information. 
            
            Since syntax elements are immutable, annotating them requires creating new instances of them
            with the annotations attached.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxAnnotation.ElasticAnnotation">
            <summary>
            A predefined syntax annotation that indicates whether the syntax element has elastic trivia.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxList`1">
            <summary>
            A list of <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxList`1.Count">
            <summary>
            The number of nodes in the list.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxList`1.Item(System.Int32)">
            <summary>
            Gets the node at the specified index.
            </summary>
            <param name="index">The zero-based index of the node to get or set.</param>
            <returns>The node at the specified index.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxList`1.FullSpan">
            <summary>
            The absolute span of the list elements in characters, not including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxList`1.Span">
            <summary>
            The absolute span of the list elements in characters, including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.ToString">
            <summary>
            Returns the string representation of the nodes in this list, not including 
            the first node's leading trivia and the last node's trailing trivia.
            </summary>
            <returns>
            The string representation of the nodes in this list, not including 
            the first node's leading trivia and the last node's trailing trivia.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.ToFullString">
            <summary>
            Returns the full string representation of the nodes in this list including 
            the first node's leading trivia and the last node's trailing trivia.
            </summary>
            <returns>
            The full string representation of the nodes in this list including 
            the first node's leading trivia and the last node's trailing trivia.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.Add(`0)">
            <summary>
            Creates a new list with the specified node added at the end.
            </summary>
            <param name="node">The node to add.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new list with the specified nodes added at the end.
            </summary>
            <param name="nodes">The nodes to add.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.Insert(System.Int32,`0)">
            <summary>
            Creates a new list with the specified node inserted at the index.
            </summary>
            <param name="index">The index to insert at.</param>
            <param name="node">The node to insert.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new list with the specified nodes inserted at the index.
            </summary>
            <param name="index">The index to insert at.</param>
            <param name="nodes">The nodes to insert.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.RemoveAt(System.Int32)">
            <summary>
            Creates a new list with the element at specified index removed.
            </summary>
            <param name="index">The index of the element to remove.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.Remove(`0)">
            <summary>
            Creates a new list with the element removed.
            </summary>
            <param name="node">The element to remove.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.Replace(`0,`0)">
            <summary>
            Creates a new list with the specified element replaced with the new node.
            </summary>
            <param name="nodeInList">The element to replace.</param>
            <param name="newNode">The new node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.ReplaceRange(`0,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new list with the specified element replaced with new nodes.
            </summary>
            <param name="nodeInList">The element to replace.</param>
            <param name="newNodes">The new nodes.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.First">
            <summary>
            The first node in the list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.FirstOrDefault">
            <summary>
            The first node in the list or default if the list is empty.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.Last">
            <summary>
            The last node in the list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.LastOrDefault">
            <summary>
            The last node in the list or default if the list is empty.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.Any">
            <summary>
            True if the list has at least one node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.GetEnumerator">
            <summary>
            Get's the enumerator for this list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.IndexOf(`0)">
            <summary>
            The index of the node in this list, or -1 if the node is not in the list.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxNode">
            <summary>
            Represents a non-terminal node in the syntax tree. This is the language agnostic equivalent of <see
            cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxNode"/> and <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxNode"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.#ctor(Microsoft.CodeAnalysis.GreenNode,System.Int32,Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Used by structured trivia which has "parent == null", and therefore must know its
            SyntaxTree explicitly when created.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.RawKind">
            <summary>
            An integer representing the language specific kind of this node.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.Language">
            <summary>
            The language name that this node is syntax of.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.SyntaxTree">
            <summary>
            Returns SyntaxTree that owns the node or null if node does not belong to a
            SyntaxTree
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.FullSpan">
            <summary>
            The absolute span of this node in characters, including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.Span">
            <summary>
            The absolute span of this node in characters, not including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.SpanStart">
            <summary>
            Same as accessing <see cref="P:Microsoft.CodeAnalysis.Text.TextSpan.Start"/> on <see cref="P:Microsoft.CodeAnalysis.SyntaxNode.Span"/>.
            </summary>
            <remarks>
            Slight performance improvement.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.Width">
            <summary>
            The width of the node in characters, not including leading and trailing trivia.
            </summary>
            <remarks>
            The Width property returns the same value as Span.Length, but is somewhat more efficient.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.FullWidth">
            <summary>
            The complete width of the node in characters, including leading and trailing trivia.
            </summary>
            <remarks>The FullWidth property returns the same value as FullSpan.Length, but is
            somewhat more efficient.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetRedElement(Microsoft.CodeAnalysis.SyntaxNode@,System.Int32)">
            <summary>
            This works the same as GetRed, but intended to be used in lists
            The only difference is that the public parent of the node is not the list, 
            but the list's parent. (element's grand parent).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetRedElementIfNotToken(Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            special cased helper for 2 and 3 children lists where child #1 may map to a token
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.ToString">
            <summary>
            Returns the string representation of this node, not including its leading and trailing trivia.
            </summary>
            <returns>The string representation of this node, not including its leading and trailing trivia.</returns>
            <remarks>The length of the returned string is always the same as Span.Length</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.ToFullString">
            <summary>
            Returns full string representation of this node including its leading and trailing trivia.
            </summary>
            <returns>The full string representation of this node including its leading and trailing trivia.</returns>
            <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.WriteTo(System.IO.TextWriter)">
            <summary>
            Writes the full text of this node to the specified TextWriter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetText">
            <summary>
            Gets the full text of this node as an new SourceText instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Determine whether this node is structurally equivalent to another.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.IsMissing">
            <summary>
            Determines whether the node represents a language construct that was actually parsed
            from the source code. Missing nodes are generated by the parser in error scenarios to
            represent constructs that should have been present in the source code in order to
            compile successfully but were actually missing.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.IsPartOfStructuredTrivia">
            <summary>
            Determines whether this node is a descendant of a structured trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.IsStructuredTrivia">
            <summary>
            Determines whether this node represents a structured trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.HasStructuredTrivia">
            <summary>
            Determines whether a descendant trivia of this node is structured.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.ContainsSkippedText">
            <summary>
            Determines whether this node has any descendant skipped text.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.ContainsDirectives">
            <summary>
            Determines whether this node has any descendant preprocessor directives.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.ContainsDiagnostics">
            <summary>
            Determines whether this node or any of its descendant nodes, tokens or trivia have any diagnostics on them. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.HasLeadingTrivia">
            <summary>
            Determines whether this node has any leading trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.HasTrailingTrivia">
            <summary>
            Determines whether this node has any trailing trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetCachedSlot(System.Int32)">
            <summary>
            Gets a node at given node index without forcing its creation.
            If node was not created it would return null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetChildPosition(System.Int32)">
            <summary>
            This function calculates the offset of a child at given position. It is very common that
            some children to the left of the given index already know their positions so we first
            check if that is the case. In a worst case the cost is O(n), but it is not generally an
            issue because number of children in regular nodes is fixed and small. In a case where
            the number of children could be large (lists) this function is overridden with more
            efficient implementations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetDiagnostics">
            <summary>
            Gets a list of all the diagnostics in the sub tree that has this node as its root.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetReference">
            <summary>
            Gets an SyntaxReference for this syntax node. CommonSyntaxReferences can be used to
            regain access to a syntax node without keeping the entire tree and source text in
            memory.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.Parent">
            <summary>
            The node that contains this node in its Children collection.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.ChildNodesAndTokens">
            <summary>
            The list of child nodes and tokens of this node, where each element is a SyntaxNodeOrToken instance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetNodeSlot(System.Int32)">
            <summary>
            Gets node at given node index. 
            This WILL force node creation if node has not yet been created.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes">
            <summary>
            Gets a list of the child nodes in prefix document order.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.Ancestors(System.Boolean)">
            <summary>
            Gets a list of ancestor nodes
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.AncestorsAndSelf(System.Boolean)">
            <summary>
            Gets a list of ancestor nodes (including this node) 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.FirstAncestorOrSelf``1(System.Func{``0,System.Boolean},System.Boolean)">
            <summary>
            Gets the first node of type TNode that matches the predicate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes(System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes in prefix document order.
            </summary>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes(Microsoft.CodeAnalysis.Text.TextSpan,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes in prefix document order.
            </summary>
            <param name="span">The span the node's full span must intersect.</param>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndSelf(System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes (including this node) in prefix document order.
            </summary>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndSelf(Microsoft.CodeAnalysis.Text.TextSpan,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes (including this node) in prefix document order.
            </summary>
            <param name="span">The span the node's full span must intersect.</param>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndTokens(System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes and tokens in prefix document order.
            </summary>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndTokens(Microsoft.CodeAnalysis.Text.TextSpan,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of the descendant nodes and tokens in prefix document order.
            </summary>
            <param name="span">The span the node's full span must intersect.</param>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndTokensAndSelf(System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes and tokens (including this node) in prefix document order.
            </summary>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndTokensAndSelf(Microsoft.CodeAnalysis.Text.TextSpan,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of the descendant nodes and tokens (including this node) in prefix document order.
            </summary>
            <param name="span">The span the node's full span must intersect.</param>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.FindNode(Microsoft.CodeAnalysis.Text.TextSpan,System.Boolean,System.Boolean)">
            <summary>
            Finds the node with the smallest <see cref="P:Microsoft.CodeAnalysis.SyntaxNode.FullSpan"/> that contains <paramref name="span"/>.
            <paramref name="getInnermostNodeForTie"/> is used to determine the behavior in case of a tie (i.e. a node having the same span as its parent).
            If <paramref name="getInnermostNodeForTie"/> is true, then it returns lowest descending node encompassing the given <paramref name="span"/>.
            Otherwise, it returns the outermost node encompassing the given <paramref name="span"/>.
            </summary>
            <remarks>
            TODO: This should probably be reimplemented with <see cref="M:Microsoft.CodeAnalysis.SyntaxNode.ChildThatContainsPosition(System.Int32)"/>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">This exception is thrown if <see cref="P:Microsoft.CodeAnalysis.SyntaxNode.FullSpan"/> doesn't contain the given span.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.FindToken(System.Int32,System.Boolean)">
            <summary>
            Finds a descendant token of this node whose span includes the supplied position. 
            </summary>
            <param name="position">The character position of the token relative to the beginning of the file.</param>
            <param name="findInsideTrivia">
            True to return tokens that are part of trivia. If false finds the token whose full span (including trivia)
            includes the position.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetFirstToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets the first token of the tree rooted by this node. Skips zero-width tokens.
            </summary>
            <returns>The first token or <c>default(SyntaxToken)</c> if it doesn't exist.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetLastToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets the last token of the tree rooted by this node. Skips zero-width tokens.
            </summary>
            <returns>The last token or <c>default(SyntaxToken)</c> if it doesn't exist.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.ChildTokens">
            <summary>
            Gets a list of the direct child tokens of this node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens(System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of all the tokens in the span of this node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens(Microsoft.CodeAnalysis.Text.TextSpan,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of all the tokens in the full span of this node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetLeadingTrivia">
            <summary>
            The list of trivia that appears before this node in the source code and are attached to a token that is a
            descendant of this node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetTrailingTrivia">
            <summary>
            The list of trivia that appears after this node in the source code and are attached to a token that is a
            descendant of this node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.FindTrivia(System.Int32,System.Boolean)">
            <summary>
            Finds a descendant trivia of this node whose span includes the supplied position.
            </summary>
            <param name="position">The character position of the trivia relative to the beginning of the file.</param>
            <param name="findInsideTrivia">
            True to return tokens that are part of trivia. If false finds the token whose full span (including trivia)
            includes the position.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia(System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Get a list of all the trivia associated with the descendant nodes and tokens.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia(Microsoft.CodeAnalysis.Text.TextSpan,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Get a list of all the trivia associated with the descendant nodes and tokens.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.ContainsAnnotations">
            <summary>
            Determines whether this node or any sub node, token or trivia has annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.HasAnnotations(System.String)">
            <summary>
            Determines whether this node has any annotations with the specific annotation kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.HasAnnotations(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Determines whether this node has any annotations with any of the specific annotation kinds.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.HasAnnotation(Microsoft.CodeAnalysis.SyntaxAnnotation)">
            <summary>
            Determines whether this node has the specific annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotations(System.String)">
            <summary>
            Gets all the annotations with the specified annotation kind. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotations(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets all the annotations with the specified annotation kinds. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodesAndTokens(System.String)">
            <summary>
            Gets all nodes and tokens with an annotation of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodesAndTokens(System.String[])">
            <summary>
            Gets all nodes and tokens with an annotation of the specified annotation kinds.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodesAndTokens(Microsoft.CodeAnalysis.SyntaxAnnotation)">
            <summary>
            Gets all nodes and tokens with the specified annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodes(Microsoft.CodeAnalysis.SyntaxAnnotation)">
            <summary>
            Gets all nodes with the specified annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodes(System.String)">
            <summary>
            Gets all nodes with the specified annotation kind.
            </summary>
            <param name="annotationKind"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTokens(Microsoft.CodeAnalysis.SyntaxAnnotation)">
            <summary>
            Gets all tokens with the specified annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTokens(System.String)">
            <summary>
            Gets all tokens with the specified annotation kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTrivia(System.String)">
            <summary>
            Gets all trivia with an annotation of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTrivia(System.String[])">
            <summary>
            Gets all trivia with an annotation of the specified annotation kinds.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTrivia(Microsoft.CodeAnalysis.SyntaxAnnotation)">
            <summary>
            Gets all trivia with the specified annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.CopyAnnotationsTo``1(``0)">
            <summary>
            Copies all SyntaxAnnotations, if any, from this SyntaxNode instance and attaches them to a new instance based on <paramref name="node" />.
            </summary>
            <remarks>
            <para>
            If no annotations are copied, just returns <paramref name="node" />.
            </para>
            <para>
            It can also be used manually to preserve annotations in a more complex tree
            modification, even if the type of a node changes.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Determines if two nodes are the same, disregarding trivia differences.
            </summary>
            <param name="node">The node to compare against.</param>
            <param name="topLevel"> If true then the nodes are equivalent if the contained nodes and
            tokens declaring metadata visible symbolic information are equivalent, ignoring any
            differences of nodes inside method bodies or initializer expressions, otherwise all
            nodes and tokens must be equivalent. 
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.EquivalentToCore(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Determine if this node is structurally equivalent to another.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.SyntaxTreeCore">
            <summary>
            Returns SyntaxTree that owns the node or null if node does not belong to a
            SyntaxTree
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.FindTokenCore(System.Int32,System.Boolean)">
            <summary>
            Finds a descendant token of this node whose span includes the supplied position. 
            </summary>
            <param name="position">The character position of the token relative to the beginning of the file.</param>
            <param name="findInsideTrivia">
            True to return tokens that are part of trivia.
            If false finds the token whose full span (including trivia) includes the position.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.FindTokenCore(System.Int32,System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,System.Boolean})">
            <summary>
            Finds a descendant token of this node whose span includes the supplied position. 
            </summary>
            <param name="position">The character position of the token relative to the beginning of the file.</param>
            <param name="stepInto">
            Applied on every structured trivia. Return false if the tokens included in the trivia should be skipped. 
            Pass null to skip all structured trivia.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.FindTriviaCore(System.Int32,System.Boolean)">
            <summary>
            Finds a descendant trivia of this node whose span includes the supplied position.
            </summary>
            <param name="position">The character position of the trivia relative to the beginning of the file.</param>
            <param name="findInsideTrivia">Whether to search inside structured trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.ReplaceCore``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Func{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new tree of nodes with the specified nodes, tokens or trivia replaced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.RemoveNodesCore(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.SyntaxRemoveOptions)">
            <summary>
            Creates a new tree of nodes with the specified node removed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.IsEquivalentToCore(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Determines if two nodes are the same, disregarding trivia differences.
            </summary>
            <param name="node">The node to compare against.</param>
            <param name="topLevel"> If true then the nodes are equivalent if the contained nodes and
            tokens declaring metadata visible symbolic information are equivalent, ignoring any
            differences of nodes inside method bodies or initializer expressions, otherwise all
            nodes and tokens must be equivalent. 
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceSyntax``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Func{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Func{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new tree of nodes with the specified nodes, tokens and trivia replaced.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="nodes">The nodes to be replaced.</param>
            <param name="computeReplacementNode">A function that computes a replacement node for the
            argument nodes. The first argument is the original node. The second argument is the same
            node potentially rewritten with replaced descendants.</param>
            <param name="tokens">The tokens to be replaced.</param>
            <param name="computeReplacementToken">A function that computes a replacement token for
            the argument tokens. The first argument is the original token. The second argument is
            the same token potentially rewritten with replaced trivia.</param>
            <param name="trivia">The trivia to be replaced.</param>
            <param name="computeReplacementTrivia">A function that computes replacement trivia for
            the specified arguments. The first argument is the original trivia. The second argument is
            the same trivia with potentially rewritten sub structure.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNodes``2(``0,System.Collections.Generic.IEnumerable{``1},System.Func{``1,``1,Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new tree of nodes with the specified old node replaced with a new node.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <typeparam name="TNode">The type of the nodes being replaced.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="nodes">The nodes to be replaced; descendants of the root node.</param>
            <param name="computeReplacementNode">A function that computes a replacement node for the
            argument nodes. The first argument is the original node. The second argument is the same
            node potentially rewritten with replaced descendants.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode``2(``0,``1,``1)">
            <summary>
            Creates a new tree of nodes with the specified old node replaced with a new node.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <typeparam name="TNode">The type of the replaced node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="oldNode">The node to be replaced; a descendant of the root node.</param>
            <param name="newNode">The new node to use in the new tree in place of the old node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode``2(``0,``1,System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Creates a new tree of nodes with specified old node replaced with a new nodes.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <typeparam name="TNode">The type of the replaced node.</typeparam>
            <param name="root">The root of the tree of nodes.</param>
            <param name="oldNode">The node to be replaced; a descendant of the root node and an element of a list member.</param>
            <param name="newNodes">A sequence of nodes to use in the tree in place of the old node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertNodesBefore``1(``0,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new tree of nodes with new nodes inserted before the specified node.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root of the tree of nodes.</param>
            <param name="nodeInList">The node to insert before; a descendant of the root node an element of a list member.</param>
            <param name="newNodes">A sequence of nodes to insert into the tree immediately before the specified node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertNodesAfter``1(``0,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new tree of nodes with new nodes inserted after the specified node.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root of the tree of nodes.</param>
            <param name="nodeInList">The node to insert after; a descendant of the root node an element of a list member.</param>
            <param name="newNodes">A sequence of nodes to insert into the tree immediately after the specified node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceToken``1(``0,Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a new tree of nodes with the specified old token replaced with new tokens.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root of the tree of nodes.</param>
            <param name="tokenInList">The token to be replaced; a descendant of the root node and an element of a list member.</param>
            <param name="newTokens">A sequence of tokens to use in the tree in place of the specified token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTokensBefore``1(``0,Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a new tree of nodes with new tokens inserted before the specified token.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root of the tree of nodes.</param>
            <param name="tokenInList">The token to insert before; a descendant of the root node and an element of a list member.</param>
            <param name="newTokens">A sequence of tokens to insert into the tree immediately before the specified token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTokensAfter``1(``0,Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a new tree of nodes with new tokens inserted after the specified token.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root of the tree of nodes.</param>
            <param name="tokenInList">The token to insert after; a descendant of the root node and an element of a list member.</param>
            <param name="newTokens">A sequence of tokens to insert into the tree immediately after the specified token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new tree of nodes with the specified old triva replaced with new trivia.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root of the tree of nodes.</param>
            <param name="oldTrivia">The trivia to be replaced; a descendant of the root node.</param>
            <param name="newTrivia">A sequence of trivia to use in the tree in place of the specified trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTriviaBefore``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new tree of nodes with new trivia inserted before the specified trivia.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root of the tree of nodes.</param>
            <param name="trivia">The trivia to insert before; a descendant of the root node.</param>
            <param name="newTrivia">A sequence of trivia to insert into the tree immediately before the specified trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTriviaAfter``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new tree of nodes with new trivia inserted after the specified trivia.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root of the tree of nodes.</param>
            <param name="trivia">The trivia to insert after; a descendant of the root node.</param>
            <param name="newTrivia">A sequence of trivia to insert into the tree immediately after the specified trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTokens``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Func{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a new tree of nodes with the specified old node replaced with a new node.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="tokens">The token to be replaced; descendants of the root node.</param>
            <param name="computeReplacementToken">A function that computes a replacement token for
            the argument tokens. The first argument is the original token. The second argument is
            the same token potentially rewritten with replaced trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceToken``1(``0,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Creates a new tree of nodes with the specified old token replaced with a new token.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="oldToken">The token to be replaced.</param>
            <param name="newToken">The new token to use in the new tree in place of the old
            token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTrivia``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new tree of nodes with the specified trivia replaced with new trivia.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="trivia">The trivia to be replaced; descendants of the root node.</param>
            <param name="computeReplacementTrivia">A function that computes replacement trivia for
            the specified arguments. The first argument is the original trivia. The second argument is
            the same trivia with potentially rewritten sub structure.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Creates a new tree of nodes with the specified trivia replaced with new trivia.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="trivia">The trivia to be replaced.</param>
            <param name="newTrivia">The new trivia to use in the new tree in place of the old trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.RemoveNode``1(``0,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxRemoveOptions)">
            <summary>
            Creates a new tree of nodes with the specified node removed.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node from which to remove a descendant node from.</param>
            <param name="node">The node to remove.</param>
            <param name="options">Options that determine how the node's trivia is treated.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.RemoveNodes``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.SyntaxRemoveOptions)">
            <summary>
            Creates a new tree of nodes with the specified nodes removed.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node from which to remove a descendant node from.</param>
            <param name="nodes">The nodes to remove.</param>
            <param name="options">Options that determine how the nodes' trivia is treated.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.NormalizeWhitespace``1(``0,System.String,System.Boolean)">
            <summary>
            Creates a new syntax node with all whitespace and end of line trivia replaced with
            regularly formatted trivia.
            </summary>
            <typeparam name="TNode">The type of the node.</typeparam>
            <param name="node">The node to format.</param>
            <param name="indentation">An optional sequence of whitespace characters that defines a
            single level of indentation.</param>
            <param name="elasticTrivia">If true the replaced trivia is elastic trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithLeadingTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a new node from this node with the leading trivia replaced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithLeadingTrivia``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new node from this node with the leading trivia replaced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithLeadingTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia[])">
            <summary>
            Creates a new node from this node with the leading trivia replaced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithTrailingTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a new node from this node with the trailing trivia replaced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithTrailingTrivia``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new node from this node with the trailing trivia replaced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithTrailingTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia[])">
            <summary>
            Creates a new node from this node with the trailing trivia replaced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.TrackNodes``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new tree of nodes with the specified nodes being tracked.
            
            Use GetCurrentNode on the subtree resulting from this operation, or any transformation of it,
            to get the current node corresponding to the original tracked node.
            </summary>
            <param name="root">The root of the subtree containing the nodes to be tracked.</param>
            <param name="nodes">One or more nodes that are descendants of the root node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.TrackNodes``1(``0,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a new tree of nodes with the specified nodes being tracked.
            
            Use GetCurrentNode on the subtree resulting from this operation, or any transformation of it,
            to get the current node corresponding to the original tracked node.
            </summary>
            <param name="root">The root of the subtree containing the nodes to be tracked.</param>
            <param name="nodes">One or more nodes that are descendants of the root node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.GetCurrentNodes``1(Microsoft.CodeAnalysis.SyntaxNode,``0)">
            <summary>
            Gets the nodes within the subtree corresponding to the original tracked node.
            Use TrackNodes to start tracking nodes.
            </summary>
            <param name="root">The root of the subtree containing the current node corresponding to the original tracked node.</param>
            <param name="node">The node instance originally tracked.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.GetCurrentNode``1(Microsoft.CodeAnalysis.SyntaxNode,``0)">
            <summary>
            Gets the node within the subtree corresponding to the original tracked node.
            Use TrackNodes to start tracking nodes.
            </summary>
            <param name="root">The root of the subtree containing the current node corresponding to the original tracked node.</param>
            <param name="node">The node instance originally tracked.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.GetCurrentNodes``1(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Gets the nodes within the subtree corresponding to the original tracked nodes.
            Use TrackNodes to start tracking nodes.
            </summary>
            <param name="root">The root of the subtree containing the current nodes corresponding to the original tracked nodes.</param>
            <param name="nodes">One or more node instances originally tracked.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken">
            <summary>
            A wrapper for either a syntax node (<see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>) or a syntax token (<see
            cref="T:Microsoft.CodeAnalysis.SyntaxToken"/>).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.RawKind">
            <summary>
            An integer representing the language specific kind of the underlying node or token.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.Language">
            <summary>
            The language name that this node or token is syntax of.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.IsMissing">
            <summary>
            Determines whether the underlying node or token represents a language construct that was actually parsed
            from source code. Missing nodes and tokens are typically generated by the parser in error scenarios to
            represent constructs that should have been present in the source code for the source code to compile
            successfully but were actually missing.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.Parent">
            <summary>
            The node that contains the underlying node or token in its Children collection.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.IsToken">
            <summary>
            Determines whether this <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> is wrapping a token.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.IsNode">
            <summary>
            Determines whether this <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> is wrapping a node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.AsToken">
            <summary>
            Returns the underlying token if this <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> is wrapping a
            token.
            </summary>
            <returns>
            The underlying token if this <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> is wrapping a token.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.AsNode">
            <summary>
            Returns the underlying node if this <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> is wrapping a
            node.
            </summary>
            <returns>
            The underlying node if this <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> is wrapping a node.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.ChildNodesAndTokens">
            <summary>
            The list of child nodes and tokens of the underlying node or token.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.Span">
            <summary>
            The absolute span of the underlying node or token in characters, not including its leading and trailing
            trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.SpanStart">
            <summary>
            Same as accessing <see cref="P:Microsoft.CodeAnalysis.Text.TextSpan.Start"/> on <see cref="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.Span"/>.
            </summary>
            <remarks>
            Slight performance improvement.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.FullSpan">
            <summary>
            The absolute span of the underlying node or token in characters, including its leading and trailing trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.ToString">
            <summary>
            Returns the string representation of this node or token, not including its leading and trailing
            trivia.
            </summary>
            <returns>The string representation of this node or token, not including its leading and trailing
            trivia.</returns>
            <remarks>The length of the returned string is always the same as Span.Length</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.ToFullString">
            <summary>
            Returns the full string representation of this node or token including its leading and trailing trivia.
            </summary>
            <returns>The full string representation of this node or token including its leading and trailing
            trivia.</returns>
            <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.WriteTo(System.IO.TextWriter)">
            <summary>
            Writes the full text of this node or token to the specified TextWriter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.HasLeadingTrivia">
            <summary>
            Determines whether the underlying node or token has any leading trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.GetLeadingTrivia">
            <summary>
            The list of trivia that appear before the underlying node or token in the source code and are attached to a
            token that is a descendant of the underlying node or token.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.HasTrailingTrivia">
            <summary>
            Determines whether the underlying node or token has any trailing trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.GetTrailingTrivia">
            <summary>
            The list of trivia that appear after the underlying node or token in the source code and are attached to a
            token that is a descendant of the underlying node or token.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.ContainsDiagnostics">
            <summary>
            Determines whether the underlying node or token or any of its descendant nodes, tokens or trivia have any
            diagnostics on them. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.GetDiagnostics">
            <summary>
            Gets a list of all the diagnostics in either the sub tree that has this node as its root or
            associated with this token and its related trivia. 
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.ContainsDirectives">
            <summary>
            Determines whether the underlying node or token has any descendant preprocessor directives.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.ContainsAnnotations">
            <summary>
            Determines whether this node or token (or any sub node, token or trivia) as annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.HasAnnotations(System.String)">
            <summary>
            Determines whether this node or token has annotations of the specified kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.HasAnnotations(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Determines whether this node or token has annotations of the specified kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.HasAnnotation(Microsoft.CodeAnalysis.SyntaxAnnotation)">
            <summary>
            Determines if this node or token has the specific annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.GetAnnotations(System.String)">
            <summary>
            Gets all annotations of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.GetAnnotations(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets all annotations of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.WithAdditionalAnnotations(Microsoft.CodeAnalysis.SyntaxAnnotation[])">
            <summary>
            Creates a new node or token identical to this one with the specified annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.WithAdditionalAnnotations(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxAnnotation})">
            <summary>
            Creates a new node or token identical to this one with the specified annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.WithoutAnnotations(Microsoft.CodeAnalysis.SyntaxAnnotation[])">
            <summary>
            Creates a new node or token identical to this one without the specified annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.WithoutAnnotations(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxAnnotation})">
            <summary>
            Creates a new node or token identical to this one without the specified annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.WithoutAnnotations(System.String)">
            <summary>
            Creates a new node or token identical to this one without annotations of the specified kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.Equals(Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Determines whether the supplied <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> is equal to this
            <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.op_Equality(Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Determines whether two <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>s are equal.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.op_Inequality(Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Determines whether two <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>s are unequal.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.Equals(System.Object)">
            <summary>
            Determines whether the supplied <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> is equal to this
            <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.GetHashCode">
            <summary>
            Serves as hash function for <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Determines if the two nodes or tokens are equivalent.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.op_Implicit(Microsoft.CodeAnalysis.SyntaxToken)~Microsoft.CodeAnalysis.SyntaxNodeOrToken">
            <summary>
            Returns a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> that wraps the supplied token.
            </summary>
            <param name="token">The input token.</param>
            <returns>
            A <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> that wraps the supplied token.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.op_Explicit(Microsoft.CodeAnalysis.SyntaxNodeOrToken)~Microsoft.CodeAnalysis.SyntaxToken">
            <summary>
            Returns the underlying token wrapped by the supplied <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>.
            </summary>
            <param name="nodeOrToken">
            The input <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>.
            </param>
            <returns>
            The underlying token wrapped by the supplied <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.op_Implicit(Microsoft.CodeAnalysis.SyntaxNode)~Microsoft.CodeAnalysis.SyntaxNodeOrToken">
            <summary>
            Returns a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> that wraps the supplied node.
            </summary>
            <param name="node">The input node.</param>
            <returns>
            A <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> that wraps the supplied node.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.op_Explicit(Microsoft.CodeAnalysis.SyntaxNodeOrToken)~Microsoft.CodeAnalysis.SyntaxNode">
            <summary>
            Returns the underlying node wrapped by the supplied <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>.
            </summary>
            <param name="nodeOrToken">
            The input <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>.
            </param>
            <returns>
            The underlying node wrapped by the supplied <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>.
            </returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.SyntaxTree">
            <summary>
            SyntaxTree which contains current SyntaxNodeOrToken.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.GetLocation">
            <summary>
            Get the location of this node or token.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList">
            <summary>
            A list of <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> structures.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.node">
            <summary>
            The underlying field
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.index">
            <summary>
            The index from the parent's children list of this node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.#ctor(Microsoft.CodeAnalysis.SyntaxNode,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/> structure.
            </summary>
            <param name="node">The underlying syntax node.</param>
            <param name="index">The index.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Node">
            <summary>
            Gets the underlying syntax node.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Count">
            <summary>
            Gets the count of nodes in this list
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> at the specified index. 
            </summary>
            
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="index"/> is out of range.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.FullSpan">
            <summary>
            The absolute span of the list elements in characters, not including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Span">
            <summary>
            The absolute span of the list elements in characters, including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.ToString">
            <summary>
            Returns the string representation of the nodes and tokens in this list, not including the first node or token's leading trivia 
            and the last node or token's trailing trivia.
            </summary>
            <returns>
            The string representation of the nodes and tokens in this list, not including the first node or token's leading trivia 
            and the last node or token's trailing trivia.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.ToFullString">
            <summary>
            Returns the full string representation of the nodes and tokens in this list including the first node or token's leading trivia 
            and the last node or token's trailing trivia.
            </summary>
            <returns>
            The full string representation of the nodes and tokens in this list including the first node or token's leading trivia 
            and the last node or token's trailing trivia.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.First">
            <summary>
            Gets the first SyntaxNodeOrToken structure from this list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.FirstOrDefault">
            <summary>
            Gets the first SyntaxNodeOrToken structure from this list if present, else default(SyntaxNodeOrToken).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Last">
            <summary>
            Gets the last SyntaxNodeOrToken structure from this list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.LastOrDefault">
            <summary>
            Gets the last SyntaxNodeOrToken structure from this list if present, else default(SyntaxNodeOrToken).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.IndexOf(Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Returns the index from the list for the given <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>.
            </summary>
            <param name="nodeOrToken">The node or token to search for in the list.</param>
            <returns>The index of the found nodeOrToken, or -1 if it wasn't found</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Any">
            <summary>
            Indicates whether there is any element in the list.
            </summary>
            <returns><c>true</c> if there are any elements in the list, else <c>false</c>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.CopyTo(System.Int32,Microsoft.CodeAnalysis.GreenNode[],System.Int32,System.Int32)">
            <summary>
            Copies a given count of elements into the given array at specified offsets.
            </summary>
            <param name="offset">The offset to start copying from.</param>
            <param name="array">The array to copy the elements into.</param>
            <param name="arrayOffset">The array offset to start writing to.</param>
            <param name="count">The count of elements to copy.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Add(Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/> with the specified node or token added to the end.
            </summary>
            <param name="nodeOrToken">The node or token to add.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.AddRange(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNodeOrToken})">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/> with the specified nodes or tokens added to the end.
            </summary>
            <param name="nodesOrTokens">The nodes or tokens to add.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Insert(System.Int32,Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/> with the specified node or token inserted at the index.
            </summary>
            <param name="index">The index to insert at.</param>
            <param name="nodeOrToken">The node or token to insert.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNodeOrToken})">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/> with the specified nodes or tokens inserted at the index.
            </summary>
            <param name="index">The index to insert at.</param>
            <param name="nodesAndTokens">The nodes or tokens to insert.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.RemoveAt(System.Int32)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/> with the element at the specified index removed.
            </summary>
            <param name="index">The index of the element to remove.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Remove(Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/> with the specified element removed.
            </summary>
            <param name="nodeOrTokenInList">The element to remove.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Replace(Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/> with the specified element replaced with a new node or token.
            </summary>
            <param name="nodeOrTokenInList">The element to replace.</param>
            <param name="newNodeOrToken">The new node or token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.ReplaceRange(Microsoft.CodeAnalysis.SyntaxNodeOrToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNodeOrToken})">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/> with the specified element replaced with a new nodes and tokens.
            </summary>
            <param name="nodeOrTokenInList">The element to replace.</param>
            <param name="newNodesAndTokens">The new nodes and tokens.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.GetEnumerator">
            <summary>
            Gets the enumerator.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.System#Collections#Generic#IEnumerable{Microsoft#CodeAnalysis#SyntaxNodeOrToken}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.op_Equality(Microsoft.CodeAnalysis.SyntaxNodeOrTokenList,Microsoft.CodeAnalysis.SyntaxNodeOrTokenList)">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="left">The left SyntaxNodeOrTokenList</param>
            <param name="right">The right SyntaxNodeOrTokenList</param>
            <returns>
            <c>true</c> if both lists equal, else <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.op_Inequality(Microsoft.CodeAnalysis.SyntaxNodeOrTokenList,Microsoft.CodeAnalysis.SyntaxNodeOrTokenList)">
            <summary>
            Implements the operator !=.
            </summary>
            <param name="left">The left SyntaxNodeOrTokenList</param>
            <param name="right">The right SyntaxNodeOrTokenList</param>
            <returns>
            <c>true</c> if both lists not equal, else <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Equals(Microsoft.CodeAnalysis.SyntaxNodeOrTokenList)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            <c>true</c> if the current object is equal to the <paramref name="other"/> parameter; otherwise,
            <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator">
            <summary>
            Enumerator for lists of SyntaxNodeOrToken structs.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator.Current">
            <summary>
            Gets the struct that this enumerator instance is currently pointing to.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the struct that this enumerator instance is currently pointing to.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator.System#Collections#IEnumerator#Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator.System#IDisposable#Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxReference">
            <summary>
            A reference to a syntax node.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxReference.SyntaxTree">
            <summary>
            The syntax tree that this references a node within.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxReference.Span">
            <summary>
            The span of the node referenced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxReference.GetSyntax(System.Threading.CancellationToken)">
            <summary>
            Retrieves the original referenced syntax node.  
            This action may cause a parse to happen to recover the syntax node.
            </summary>
            <returns>The original referenced syntax node.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxReference.GetSyntaxAsync(System.Threading.CancellationToken)">
            <summary>
            Retrieves the original referenced syntax node.  
            This action may cause a parse to happen to recover the syntax node.
            </summary>
            <returns>The original referenced syntax node.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxReference.GetLocation">
            <summary>
            The location of this syntax reference.
            </summary>
            <returns>The location of this syntax reference.</returns>
            <remarks>
            More performant than GetSyntax().GetLocation().
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxRemoveOptions.KeepNoTrivia">
            <summary>
            None of the trivia associated with the node or token is kept.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxRemoveOptions.KeepLeadingTrivia">
            <summary>
            The leading trivia associated with the node or token is kept.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxRemoveOptions.KeepTrailingTrivia">
            <summary>
            The trailing trivia associated with the node or token is kept.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxRemoveOptions.KeepExteriorTrivia">
            <summary>
            The leading and trailing trivia associated with the node or token is kept.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxRemoveOptions.KeepUnbalancedDirectives">
            <summary>
            Any directives that would become unbalanced are kept.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxRemoveOptions.KeepDirectives">
            <summary>
            All directives are kept
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxRemoveOptions.KeepEndOfLine">
            <summary>
            Ensure that at least one EndOfLine trivia is kept if one was present 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxToken">
            <summary>
            Represents a token in the syntax tree. This is the language agnostic equivalent of <see
            cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxToken"/> and <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxToken"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.RawKind">
            <summary>
            An integer representing the language specific kind of this token.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.Language">
            <summary>
            The language name that this token is syntax of.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.RawContextualKind">
            <summary>
            The kind of token, given its position in the syntax. This differs from <see
            cref="P:Microsoft.CodeAnalysis.SyntaxToken.RawKind"/> when a contextual keyword is used in a place in the syntax that gives it
            its keyword meaning.
            </summary>
            <remarks>
            The ContextualKind is relevant only on contextual keyword tokens. ContextualKind differs
            from Kind when a token is used in context where the token should be interpreted as a
            keyword.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.Parent">
            <summary>
            The node that contains this token in its Children collection.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.Width">
            <summary>
            The width of the token in characters, not including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.FullWidth">
            <summary>
            The complete width of the token in characters including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.Span">
            <summary>
            The absolute span of this token in characters, not including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.SpanStart">
            <summary>
            Same as accessing <see cref="P:Microsoft.CodeAnalysis.Text.TextSpan.Start"/> on <see cref="P:Microsoft.CodeAnalysis.SyntaxToken.Span"/>.
            </summary>
            <remarks>
            Slight performance improvement.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.FullSpan">
            <summary>
            The absolute span of this token in characters, including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.IsMissing">
            <summary>
            Determines whether this token represents a language construct that was actually parsed from source code.
            Missing tokens are typically generated by the parser in error scenarios to represent constructs that should
            have been present in the source code for the source code to compile successfully but were actually missing.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.Value">
            <summary>
            Returns the value of the token. For example, if the token represents an integer literal, then this property
            would return the actual integer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.ValueText">
            <summary>
            Returns the text representation of the value of the token. For example, if the token represents an integer
            literal, then this property would return a string representing the integer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.ToString">
            <summary>
            Returns the string representation of this token, not including its leading and trailing trivia.
            </summary>
            <returns>The string representation of this token, not including its leading and trailing trivia.</returns>
            <remarks>The length of the returned string is always the same as Span.Length</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.ToFullString">
            <summary>
            Returns the full string representation of this token including its leading and trailing trivia.
            </summary>
            <returns>The full string representation of this token including its leading and trailing trivia.</returns>
            <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.WriteTo(System.IO.TextWriter)">
            <summary>
            Writes the full text of this token to the specified TextWriter
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.WriteTo(System.IO.TextWriter,System.Boolean,System.Boolean)">
            <summary>
            Writes the text of this token to the specified TextWriter, optionally including trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.HasLeadingTrivia">
            <summary>
            Determines whether this token has any leading trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.HasTrailingTrivia">
            <summary>
            Determines whether this token has any trailing trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.LeadingWidth">
            <summary>
            Full width of the leading trivia of this token.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.TrailingWidth">
            <summary>
            Full width of the trailing trivia of this token.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.ContainsDiagnostics">
            <summary>
            Determines whether this token or any of its descendant trivia have any diagnostics on them. 
            </summary>>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.ContainsDirectives">
            <summary>
            Determines whether this token has any descendant preprocessor directives.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.IsPartOfStructuredTrivia">
            <summary>
            Determines whether this token is a descendant of a structured trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.HasStructuredTrivia">
            <summary>
            Determines whether any of this token's trivia is structured.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.ContainsAnnotations">
            <summary>
            True if this token or its trivia has any annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.HasAnnotations(System.String)">
            <summary>
            True if this token has annotations of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.HasAnnotations(System.String[])">
            <summary>
            True if this token has annotations of the specified annotation kinds.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.HasAnnotation(Microsoft.CodeAnalysis.SyntaxAnnotation)">
            <summary>
            True if this token has the specified annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.GetAnnotations(System.String)">
            <summary>
            Gets all the annotations of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.GetAnnotations(System.String[])">
            <summary>
            Gets all the annotations of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.GetAnnotations(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets all the annotations of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.WithAdditionalAnnotations(Microsoft.CodeAnalysis.SyntaxAnnotation[])">
            <summary>
            Adds this annotation to a given syntax token, creating a new syntax token of the same type with the
            annotation on it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.WithAdditionalAnnotations(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxAnnotation})">
            <summary>
            Adds this annotation to a given syntax token, creating a new syntax token of the same type with the
            annotation on it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.WithoutAnnotations(Microsoft.CodeAnalysis.SyntaxAnnotation[])">
            <summary>
            Creates a new syntax token identical to this one without the specified annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.WithoutAnnotations(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxAnnotation})">
            <summary>
            Creates a new syntax token identical to this one without the specified annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.WithoutAnnotations(System.String)">
            <summary>
            Creates a new syntax token identical to this one without annotations of the specified kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.CopyAnnotationsTo(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Copies all SyntaxAnnotations, if any, from this SyntaxToken instance and attaches them to a new instance based on <paramref name="token" />.
            </summary>
            <remarks>
            If no annotations are copied, just returns <paramref name="token" />.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia">
            <summary>
            The list of trivia that appear before this token in the source code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia">
            <summary>
            The list of trivia that appear after this token in the source code and are attached to this token or any of
            its descendants.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.WithLeadingTrivia(Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Clones the token and adds the <paramref name="trivia"/> as leading trivia.
            </summary>
            <param name="trivia">The <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> to add as leading trivia.</param>
            <returns>A new token with leading trivia.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.WithTrailingTrivia(Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Clones the token and adds the <paramref name="trivia"/> as trailing trivia.
            </summary>
            <param name="trivia">The <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> to add as trailing trivia.</param>
            <returns>A new token with trailing trivia.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.GetAllTrivia">
            <summary>
            Gets a list of all the trivia (both leading and trailing) for this token.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.op_Equality(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Determines whether two <see cref="T:Microsoft.CodeAnalysis.SyntaxToken"/>s are equal.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.op_Inequality(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Determines whether two <see cref="T:Microsoft.CodeAnalysis.SyntaxToken"/>s are unequal.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.Equals(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Determines whether the supplied <see cref="T:Microsoft.CodeAnalysis.SyntaxToken"/> is equal to this
            <see cref="T:Microsoft.CodeAnalysis.SyntaxToken"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.Equals(System.Object)">
            <summary>
            Determines whether the supplied <see cref="T:Microsoft.CodeAnalysis.SyntaxToken"/> is equal to this
            <see cref="T:Microsoft.CodeAnalysis.SyntaxToken"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.GetHashCode">
            <summary>
            Serves as hash function for <see cref="T:Microsoft.CodeAnalysis.SyntaxToken"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.GetNextToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets the token that follows this token in the syntax tree.
            </summary>
            <returns>The token that follows this token in the syntax tree.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.GetNextToken(System.Func{Microsoft.CodeAnalysis.SyntaxToken,System.Boolean},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,System.Boolean})">
            <summary>
            Returns the token after this token in the syntax tree.
            </summary>
            <param name="predicate">Delegate applied to each token.  The token is returned if the predicate returns
            true.</param>
            <param name="stepInto">Delegate applied to trivia.  If this delegate is present then trailing trivia is
            included in the search.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.GetPreviousToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets the token that precedes this token in the syntax tree.
            </summary>
            <returns>The next token that follows this token in the syntax tree.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.GetPreviousToken(System.Func{Microsoft.CodeAnalysis.SyntaxToken,System.Boolean},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,System.Boolean})">
            <summary>
            Returns the token before this token in the syntax tree.
            </summary>
            <param name="predicate">Delegate applied to each token.  The token is returned if the predicate returns
            true.</param>
            <param name="stepInto">Delegate applied to trivia.  If this delegate is present then trailing trivia is
            included in the search.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.SyntaxTree">
            <summary>
            SyntaxTree which contains current SyntaxToken.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.GetLocation">
            <summary>
            Gets the location for this token.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.GetDiagnostics">
            <summary>
            Gets a list of all the diagnostics associated with this token and any related trivia.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Determines if this token is equivalent to the specified token.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxTokenList">
            <summary>
             Represents a read-only list of <see cref="T:Microsoft.CodeAnalysis.SyntaxToken"/>.
            </summary>
            <summary>
             Represents a read-only list of <see cref="T:Microsoft.CodeAnalysis.SyntaxToken"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTokenList.Count">
            <summary>
            Returns the number of tokens in the list.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTokenList.Item(System.Int32)">
            <summary>
            Gets the token at the specified index.
            </summary>
            <param name="index">The zero-based index of the token to get.</param>
            <returns>The token at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
              <paramref name="index" /> is less than 0.-or-<paramref name="index" /> is equal to or greater than <see cref="P:Microsoft.CodeAnalysis.SyntaxTokenList.Count" />. </exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTokenList.FullSpan">
            <summary>
            The absolute span of the list elements in characters, not including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTokenList.Span">
            <summary>
            The absolute span of the list elements in characters, including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.ToString">
            <summary>
            Returns the string representation of the tokens in this list, not including 
            the first token's leading trivia and the last token's trailing trivia.
            </summary>
            <returns>
            The string representation of the tokens in this list, not including 
            the first token's leading trivia and the last token's trailing trivia.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.ToFullString">
            <summary>
            Returns the full string representation of the tokens in this list including 
            the first token's leading trivia and the last token's trailing trivia.
            </summary>
            <returns>
            The full string representation of the tokens in this list including 
            the first token's leading trivia and the last token's trailing trivia.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.First">
            <summary>
            Returns the first token in the list.
            </summary>
            <returns>The first token in the list.</returns>
            <exception cref="T:System.InvalidOperationException">The list is empty.</exception>        
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.Last">
            <summary>
            Returns the last token in the list.
            </summary>
            <returns> The last token in the list.</returns>
            <exception cref="T:System.InvalidOperationException">The list is empty.</exception>        
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.Any">
            <summary>
            Tests whether the list is non-empty.
            </summary>
            <returns>True if the list contains any tokens.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.Reverse">
            <summary>
            Returns a list which contains all elements of <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/> in reversed order.
            </summary>
            <returns><see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList.Reversed"/> which contains all elements of <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/> in reversed order</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.GetGreenNodeAt(System.Int32)">
            <summary>
            get the green node at the given slot
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.GetGreenNodeAt(Microsoft.CodeAnalysis.GreenNode,System.Int32)">
            <summary>
            get the green node at the given slot
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.Add(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/> with the specified token added to the end.
            </summary>
            <param name="token">The token to add.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.AddRange(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/> with the specified tokens added to the end.
            </summary>
            <param name="tokens">The tokens to add.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.Insert(System.Int32,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/> with the specified token insert at the index.
            </summary>
            <param name="index">The index to insert the new token.</param>
            <param name="token">The token to insert.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/> with the specified tokens insert at the index.
            </summary>
            <param name="index">The index to insert the new tokens.</param>
            <param name="tokens">The tokens to insert.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.RemoveAt(System.Int32)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/> with the token at the specified index removed.
            </summary>
            <param name="index">The index of the token to remove.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.Remove(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/> with the specified token removed.
            </summary>
            <param name="tokenInList">The token to remove.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.Replace(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/> with the specified token replaced with a new token.
            </summary>
            <param name="tokenInList">The token to replace.</param>
            <param name="newToken">The new token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.ReplaceRange(Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/> with the specified token replaced with new tokens.
            </summary>
            <param name="tokenInList">The token to replace.</param>
            <param name="newTokens">The new tokens.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.GetEnumerator">
            <summary>
            Returns an enumerator for the tokens in the <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.op_Equality(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxTokenList)">
            <summary>
            Compares <paramref name="left"/> and <paramref name="right"/> for equality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>True if the two <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/>s are equal.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.op_Inequality(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxTokenList)">
            <summary>
            Compares <paramref name="left"/> and <paramref name="right"/> for inequality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>True if the two <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/>s are not equal.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.Equals(System.Object)">
            <summary>
            Compares this <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/> with the <paramref name="obj"/> for equality.
            </summary>
            <returns>True if the two objects are equal.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.GetHashCode">
            <summary>
            Serves as a hash function for the <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.Create(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Create a new Token List
            </summary>
            <param name="token">Element of the return Token List</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxTokenList.Enumerator">
            <summary>
            A structure for enumerating the a <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next token in the collection.
            </summary>
            <returns>true if the enumerator was successfully advanced to the next element; false if the enumerator
            has passed the end of the collection.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTokenList.Enumerator.Current">
            <summary>
            Gets the current element in the collection.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxTokenList.Reversed">
            <summary>
            reversed enumerable
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxTree">
            <summary>
            The parsed representation of a source document.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTree.FilePath">
            <summary>
            The path of the source document file.
            </summary>
            <remarks>
            If this syntax tree is not associated with a file, this value can be empty.
            The path shall not be null.
            
            The file doesn't need to exist on disk. The path is opaque for the compiler.
            The only requirement on the path format is that the implementations of 
            <see cref="T:Microsoft.CodeAnalysis.SourceReferenceResolver"/>, <see cref="T:Microsoft.CodeAnalysis.XmlReferenceResolver"/> and <see cref="T:Microsoft.CodeAnalysis.MetadataReferenceResolver"/> 
            passed to the compilation that contains the tree understand it.
            
            Clients must also not assume that the values of this property are unique
            within a Compilation.
            
            The path is used as follows:
               - When debug information is emitted, this path is embedded in the debug information.
               - When resolving and normalizing relative paths in #r, #load, #line/#ExternalSource, 
                 #pragma checksum, #ExternalChecksum directives, XML doc comment include elements, etc.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTree.HasCompilationUnitRoot">
            <summary>
            Returns true if this syntax tree has a root with SyntaxKind "CompilationUnit".
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTree.Options">
            <summary>
            The options used by the parser to produce the syntax tree.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTree.OptionsCore">
            <summary>
            The options used by the parser to produce the syntax tree.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTree.Length">
            <summary>
            The length of the text of the syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.TryGetText(Microsoft.CodeAnalysis.Text.SourceText@)">
            <summary>
            Gets the syntax tree's text if it is available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetText(System.Threading.CancellationToken)">
            <summary>
            Gets the text of the source document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetTextAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the text of the source document asynchronously.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.TryGetRoot(Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            Gets the root of the syntax tree if it is available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.TryGetRootCore(Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            Gets the root of the syntax tree if it is available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetRoot(System.Threading.CancellationToken)">
            <summary>
            Gets the root node of the syntax tree, causing computation if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetRootCore(System.Threading.CancellationToken)">
            <summary>
            Gets the root node of the syntax tree, causing computation if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetRootAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the root node of the syntax tree asynchronously.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetRootAsyncCore(System.Threading.CancellationToken)">
            <summary>
            Gets the root node of the syntax tree asynchronously.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.WithChangedText(Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Create a new syntax tree based off this tree using a new source text.
            
            If the new source text is a minor change from the current source text an incremental
            parse will occur reusing most of the current syntax tree internal data.  Otherwise, a
            full parse will occur using the new source text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets a list of all the diagnostics in the syntax tree.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets a list of all the diagnostics in the sub tree that has the specified node as its root.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Gets a list of all the diagnostics associated with the token and any related trivia.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Gets a list of all the diagnostics associated with the trivia.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Gets a list of all the diagnostics in either the sub tree that has the specified node as its root or
            associated with the token and its related trivia. 
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetLineSpan(Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            Gets the location in terms of path, line and column for a given span.
            </summary>
            <param name="span">Span within the tree.</param>
            <param name="cancellationToken">Cancallation token.</param>
            <returns>
            A valid <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan"/> that contains path, line and column information.
            The values are not affected by line mapping directives (<code>#line</code>).
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetMappedLineSpan(Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            Gets the location in terms of path, line and column after applying source line mapping directives 
            (<code>#line</code> in C# or <code>#ExternalSource</code> in VB). 
            </summary>
            <param name="span">Span within the tree.</param>
            <param name="cancellationToken">Cancallation token.</param>
            <returns>
            A valid <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan"/> that contains path, line and column information.
            
            If the location path is mapped the resulting path is the path specified in the corresponding <code>#line</code>,
            otherwise it's <see cref="P:Microsoft.CodeAnalysis.SyntaxTree.FilePath"/>.
            
            A location path is considered mapped if the first <code>#line</code> directive that preceeds it and that 
            either specifies an explicit file path or is <code>#line default</code> exists and specifies an explicit path.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetLineVisibility(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Returns the visibility for the line at the given position.
            </summary>
            <param name="position">The position to check.</param>
            <param name="cancellationToken">The cancellation token.</param> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetMappedLineSpanAndVisibility(Microsoft.CodeAnalysis.Text.TextSpan,System.Boolean@)">
            <summary>
            Gets a FileLinePositionSpan for a TextSpan and the information whether this span is considered to be hidden or not. 
            FileLinePositionSpans are used primarily for diagnostics and source locations.
            This method combines a call to GetLineSpan and IsHiddenPosition.
            </summary>
            <param name="span"></param>
            <param name="isHiddenPosition">Returns a boolean indicating whether this span is considered hidden or not.</param>
            <remarks>This function is being called only in the context of sequence point creation and therefore interprets the 
            LineVisibility accordingly (BeforeFirstRemappingDirective -> Visible).</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetDisplayPath(Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.SourceReferenceResolver)">
            <summary>
            Returns a path for particular location in source that is presented to the user. 
            </summary>
            <remarks>
            Used for implementation of <see cref="T:System.Runtime.CompilerServices.CallerFilePathAttribute"/> 
            or for embedding source paths in error messages.
            
            Unlike Dev12 we do account for #line and #ExternalSource directives when determining value for 
            <see cref="T:System.Runtime.CompilerServices.CallerFilePathAttribute"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetDisplayLineNumber(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Returns a line number for particular location in source that is presented to the user. 
            </summary>
            <remarks>
            Used for implementation of <see cref="T:System.Runtime.CompilerServices.CallerLineNumberAttribute"/> 
            or for embedding source line numbers in error messages.
            
            Unlike Dev12 we do account for #line and #ExternalSource directives when determining value for 
            <see cref="T:System.Runtime.CompilerServices.CallerLineNumberAttribute"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.HasHiddenRegions">
            <summary>
            Are there any hidden regions in the tree?
            </summary>
            <returns>True if there is at least one hidden region.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetChangedSpans(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Returns a list of the changed regions between this tree and the specified tree. The list is conservative for
            performance reasons. It may return larger regions than what has actually changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetLocation(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Gets a location for the specified text span.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxTree,System.Boolean)">
            <summary>
            Determines if two trees are the same, disregarding trivia differences.
            </summary>
            <param name="tree">The tree to compare against.</param>
            <param name="topLevel"> If true then the trees are equivalent if the contained nodes and tokens declaring
            metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies
            or initializer expressions, otherwise all nodes and tokens must be equivalent. 
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetReference(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets a SyntaxReference for a specified syntax node. SyntaxReferences can be used to
            regain access to a syntax node without keeping the entire tree and source text in
            memory.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetChanges(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Gets a list of text changes that when applied to the old tree produce this tree.
            </summary>
            <param name="oldTree">The old tree.</param>
            <remarks>The list of changes may be different than the original changes that produced
            this tree.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTreeExtensions.VerifySource(Microsoft.CodeAnalysis.SyntaxTree,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextChangeRange})">
            <summary>
            Verify nodes match source.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTreeExtensions.FindFirstDifference(System.String,System.String)">
            <summary>
            Return the index of the first difference between
            the two strings, or -1 if the strings are the same.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxTrivia">
            <summary>
            Represents a trivia in the syntax tree. This is the language agnostic equivalent of <see
            cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxTrivia"/> and <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxTrivia"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTrivia.RawKind">
            <summary>
            An integer representing the language specific kind of this trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTrivia.Language">
            <summary>
            The language name that this trivia is syntax of.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTrivia.Token">
            <summary>
            The parent token that contains this token in its LeadingTrivia or TrailingTrivia collection.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTrivia.Width">
            <summary>
            The width of this trivia in characters. If this trivia is a structured trivia then the returned width will
            not include the widths of any leading or trailing trivia present on the child non-terminal node of this
            trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTrivia.FullWidth">
            <summary>
            The width of this trivia in characters. If this trivia is a structured trivia then the returned width will
            include the widths of any leading or trailing trivia present on the child non-terminal node of this trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTrivia.Span">
            <summary>
            The absolute span of this trivia in characters. If this trivia is a structured trivia then the returned span
            will not include spans of any leading or trailing trivia present on the child non-terminal node of this
            trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTrivia.SpanStart">
            <summary>
            Same as accessing <see cref="P:Microsoft.CodeAnalysis.Text.TextSpan.Start"/> on <see cref="P:Microsoft.CodeAnalysis.SyntaxTrivia.Span"/>.
            </summary>
            <remarks>
            Slight performance improvement.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTrivia.FullSpan">
            <summary>
            The absolute span of this trivia in characters. If this trivia is a structured trivia then the returned span
            will include spans of any leading or trailing trivia present on the child non-terminal node of this trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTrivia.ContainsDiagnostics">
            <summary>
            Determines whether this trivia has any diagnostics on it. If this trivia is a structured trivia then the
            returned value will indicate whether this trivia or any of its descendant nodes, tokens or trivia have any
            diagnostics on them.
            </summary>>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTrivia.HasStructure">
            <summary>
            Determines whether this trivia is a structured trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.IsPartOfStructuredTrivia">
            <summary>
            Determines whether this trivia is a descendant of a structured trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTrivia.ContainsAnnotations">
            <summary>
            Determines whether this trivia or any of its structure has annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.HasAnnotations(System.String)">
            <summary>
            Determines where this trivia has annotations of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.HasAnnotations(System.String[])">
            <summary>
            Determines where this trivia has any annotations of the specified annotation kinds.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.HasAnnotation(Microsoft.CodeAnalysis.SyntaxAnnotation)">
            <summary>
            Determines whether this trivia has the specific annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.GetAnnotations(System.String)">
            <summary>
            Get all the annotations of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.GetAnnotations(System.String[])">
            <summary>
            Get all the annotations of the specified annotation kinds.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTrivia.IsDirective">
            <summary>
            Determines whether this trivia represents a preprocessor directive.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.GetStructure">
            <summary>
            Returns the child non-terminal node representing the syntax tree structure under this structured trivia.
            </summary>
            <returns>The child non-terminal node representing the syntax tree structure under this structured
            trivia.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.ToString">
            <summary> 
            Returns the string representation of this trivia. If this trivia is structured trivia then the returned string
            will not include any leading or trailing trivia present on the StructuredTriviaSyntax node of this trivia.
            </summary>
            <returns>The string representation of this trivia.</returns>
            <remarks>The length of the returned string is always the same as Span.Length</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.ToFullString">
            <summary> 
            Returns the full string representation of this trivia. If this trivia is structured trivia then the returned string will
            include any leading or trailing trivia present on the StructuredTriviaSyntax node of this trivia.
            </summary>
            <returns>The full string representation of this trivia.</returns>
            <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.WriteTo(System.IO.TextWriter)">
            <summary>
            Writes the full text of this trivia to the specified TextWriter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.op_Equality(Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Determines whether two <see cref="T:Microsoft.CodeAnalysis.SyntaxTrivia"/>s are equal.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.op_Inequality(Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Determines whether two <see cref="T:Microsoft.CodeAnalysis.SyntaxTrivia"/>s are unequal.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.Equals(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Determines whether the supplied <see cref="T:Microsoft.CodeAnalysis.SyntaxTrivia"/> is equal to this
            <see cref="T:Microsoft.CodeAnalysis.SyntaxTrivia"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.Equals(System.Object)">
            <summary>
            Determines whether the supplied <see cref="T:Microsoft.CodeAnalysis.SyntaxTrivia"/> is equal to this
            <see cref="T:Microsoft.CodeAnalysis.SyntaxTrivia"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.GetHashCode">
            <summary>
            Serves as hash function for <see cref="T:Microsoft.CodeAnalysis.SyntaxTrivia"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.WithAdditionalAnnotations(Microsoft.CodeAnalysis.SyntaxAnnotation[])">
            <summary>
            Creates a new SyntaxTrivia with the specified annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.WithAdditionalAnnotations(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxAnnotation})">
            <summary>
            Creates a new SyntaxTrivia with the specified annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.WithoutAnnotations(Microsoft.CodeAnalysis.SyntaxAnnotation[])">
            <summary>
            Creates a new SyntaxTrivia without the specified annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.WithoutAnnotations(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxAnnotation})">
            <summary>
            Creates a new SyntaxTrivia without the specified annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.WithoutAnnotations(System.String)">
            <summary>
            Creates a new SyntaxTrivia without annotations of the specified kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.CopyAnnotationsTo(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Copies all SyntaxAnnotations, if any, from this SyntaxTrivia instance and attaches them to a new instance based on <paramref name="trivia" />.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTrivia.SyntaxTree">
            <summary>
            SyntaxTree which contains current SyntaxTrivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.GetLocation">
            <summary>
            Get the location of this trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.GetDiagnostics">
            <summary>
            Gets a list of all the diagnostics associated with this trivia.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Determines if this trivia is equivalent to the specified trivia.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxTriviaList">
            <summary>
             Represents a read-only list of <see cref="T:Microsoft.CodeAnalysis.SyntaxTrivia"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTriviaList.Item(System.Int32)">
            <summary>
            Gets the trivia at the specified index.
            </summary>
            <param name="index">The zero-based index of the trivia to get.</param>
            <returns>The token at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
              <paramref name="index" /> is less than 0.-or-<paramref name="index" /> is equal to or greater than <see cref="P:Microsoft.CodeAnalysis.SyntaxTriviaList.Count" />. </exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTriviaList.FullSpan">
            <summary>
            The absolute span of the list elements in characters, not including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTriviaList.Span">
            <summary>
            The absolute span of the list elements in characters, including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.First">
            <summary>
            Returns the first trivia in the list.
            </summary>
            <returns>The first trivia in the list.</returns>
            <exception cref="T:System.InvalidOperationException">The list is empty.</exception>        
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.Last">
            <summary>
            Returns the last trivia in the list.
            </summary>
            <returns>The last trivia in the list.</returns>
            <exception cref="T:System.InvalidOperationException">The list is empty.</exception>        
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.Any">
            <summary>
            Does this list have any items.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.Reverse">
            <summary>
            Returns a list which contains all elements of <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> in reversed order.
            </summary>
            <returns><see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList.Reversed"/> which contains all elements of <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> in reversed order</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.Add(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> with the specified trivia added to the end.
            </summary>
            <param name="trivia">The trivia to add.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.AddRange(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> with the specified trivia added to the end.
            </summary>
            <param name="trivia">The trivia to add.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.Insert(System.Int32,Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> with the specified trivia inserted at the index.
            </summary>
            <param name="index">The index in the list to insert the trivia at.</param>
            <param name="trivia">The trivia to insert.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> with the specified trivia inserted at the index.
            </summary>
            <param name="index">The index in the list to insert the trivia at.</param>
            <param name="trivia">The trivia to insert.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.RemoveAt(System.Int32)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> with the element at the specified index removed.
            </summary>
            <param name="index">The index identifying the element to remove.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.Remove(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> with the specified element removed.
            </summary>
            <param name="triviaInList">The trivia element to remove.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.Replace(Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> with the specified element replaced with new trivia.
            </summary>
            <param name="triviaInList">The trivia element to replace.</param>
            <param name="newTrivia">The trivia to replace the element with.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.ReplaceRange(Microsoft.CodeAnalysis.SyntaxTrivia,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> with the specified element replaced with new trivia.
            </summary>
            <param name="triviaInList">The trivia element to replace.</param>
            <param name="newTrivia">The trivia to replace the element with.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.GetGreenNodeAt(System.Int32)">
            <summary>
            get the green node at the specific slot
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.CopyTo(System.Int32,Microsoft.CodeAnalysis.SyntaxTrivia[],System.Int32,System.Int32)">
            <summary>
            Copy count number of items starting at offset from this list into array starting at arrayOffset.
            </summary>
            <param name="offset"></param>
            <param name="array"></param>
            <param name="arrayOffset"></param>
            <param name="count"></param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxTriviaList.Reversed">
            <summary>
            reversed enumerable
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxWalker">
            <summary>
            Walks the syntax tree, allowing subclasses to operate on all nodes, token and trivia.  The
            walker will perform a depth first walk of the tree.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxWalker.Depth">
            <summary>
            True if this walker will descend into structured trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxWalker.#ctor(Microsoft.CodeAnalysis.SyntaxWalkerDepth)">
            <summary>
            Creates a new walker instance.
            </summary>
            <param name="depth">specify how much this walker will descent into
            trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxWalker.Visit(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Called when the walker visits a node.  This method may be overridden if subclasses want
            to handle the node.  Overrides should call back into this base method if they want the
            children of this node to be visited.
            </summary>
            <param name="node">The current node that the walker is visiting.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxWalker.VisitToken(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Called when the walker visits a token.  This method may be overridden if subclasses want
            to handle the token.  Overrides should call back into this base method if they want the 
            trivia of this token to be visited.
            </summary>
            <param name="token">The current token that the walker is visiting.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxWalker.VisitTrivia(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Called when the walker visits a trivia syntax.  This method may be overridden if
            subclasses want to handle the token.  Overrides should call back into this base method if
            they want the children of this trivia syntax to be visited.
            </summary>
            <param name="trivia">The current trivia syntax that the walker is visiting.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxWalkerDepth">
            <summary>
            enum to specify how deep walker should decent into
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxWalkerDepth.Node">
            <summary>
            descend into only nodes
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxWalkerDepth.Token">
            <summary>
            descend into nodes and tokens
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxWalkerDepth.Trivia">
            <summary>
            descend into nodes, tokens and trivia
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxWalkerDepth.StructuredTrivia">
            <summary>
            descend into everything
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TreeDumper">
            <summary>
            This is ONLY used id BoundNode.cs Debug method - Dump()
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TreeDumperNode">
            <summary>
            This is ONLY used for debugging purpose
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.VbStringDisplay">
            <summary>
            Implements VB string escaping. Uses iterators and thus it's implemented in shared code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.VersionHelper.TryParse(System.String,System.Version@)">
            <summary>
            sets as many fields as it can.
            </summary>
            <param name="s"></param>
            <param name="version"></param>
            <returns>True when the input was entirely parsable.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.WellKnownMembers.IsSynthesizedAttributeOptional(Microsoft.CodeAnalysis.WellKnownMember)">
            <summary>
            This function defines whether an attribute is optional or not.
            </summary>
            <param name="attributeMember">The attribute member.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.WellKnownType">
            <summary>
            Ids of well known runtime types.
            Values should not intersect with SpecialType enum!
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownTypes.Count">
            <summary>
            Number of well known types in WellKnownType enum
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownTypes.metadataNames">
            <summary>
            Array of names for types.
            The names should correspond to ids from WellKnownType enum so
            that we could use ids to index into the array
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.XmlCharType">
            
            The XmlCharType class is used for quick character type recognition
            which is optimized for the first 127 ascii characters.
            
        </member>
        <member name="M:Microsoft.CodeAnalysis.XmlCharType.InRange(System.Char,System.Char,System.Char)">
            <summary>
            start &gt;= value &lt;= end
            </summary>
        </member>
        <member name="T:Microsoft.Runtime.Hosting.ClrRuntimeInfo">
            <summary>
            Managed abstraction of the functionality provided by ICLRRuntimeInfo.
            </summary>
        </member>
        <member name="M:Microsoft.Runtime.Hosting.ClrRuntimeInfo.#ctor(Microsoft.Runtime.Hosting.Interop.IClrRuntimeInfo)">
            <summary>
            Constructor that wraps an ICLRRuntimeInfo (used internally)
            </summary>
        </member>
        <member name="M:Microsoft.Runtime.Hosting.ClrRuntimeInfo.GetInterface``1(System.Guid)">
            <summary>
            Gets an interface provided by this runtime, such as ICLRRuntimeHost.
            </summary>
            <typeparam name="TInterface">The interface type to be returned.  This must be an RCW interface</typeparam>
            <param name="clsid">The CLSID to be created</param>
        </member>
        <member name="M:Microsoft.Cci.BinaryWriter.WriteBytes(System.Byte,System.Int32)">
            <summary>
            Writes the byte 'value' , 'count' number of times.
            </summary>
            <param name="value">value to be written</param>
            <param name="count">The number of times the value is going to be written</param>
        </member>
        <member name="T:Microsoft.Cci.IDefinition">
            <summary>
            An object corresponding to a metadata entity such as a type or a field.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IReference">
            <summary>
            An object corresponding to reference to a metadata entity such as a type or a field.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IReference.GetAttributes(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            A collection of metadata custom attributes that are associated with this definition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IReference.Dispatch(Microsoft.Cci.MetadataVisitor)">
            <summary>
            Calls the visitor.Visit(T) method where T is the most derived object model node interface type implemented by the concrete type
            of the object implementing IDefinition. The dispatch method does not invoke Dispatch on any child objects. If child traversal
            is desired, the implementations of the Visit methods should do the subsequent dispatching.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IReference.AsDefinition(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Gets the definition object corresponding to this reference within the given context, 
            or null if the referenced entity isn't defined in the context.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.CustomDebugInfoWriter.ShouldForwardNamespaceScopes(Microsoft.Cci.IMethodBody,System.UInt32,Microsoft.Cci.IMethodDefinition@)">
            <summary>
            Returns true if the namespace scope for this method should be forwarded to another method.
            Returns non-null <paramref name="forwardToMethod"/> if the forwarding should be done directly via UsingNamespace,
            null if the forwarding is done via custom debug info.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.DebugSourceDocument.#ctor(System.String,System.Guid,System.Func{System.Collections.Immutable.ImmutableArray{System.Byte}})">
            <summary>
            Use to create a document when checksum is computed based on actual source stream.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.DebugSourceDocument.#ctor(System.String,System.Guid,System.Collections.Immutable.ImmutableArray{System.Byte},System.Guid)">
            <summary>
            Use to create a document when checksum is suggested via external checksum pragma/directive
            </summary>
        </member>
        <member name="P:Microsoft.Cci.DebugSourceDocument.IsComputedChecksum">
            <summary>
            returns true when checksum was computed base on an actual source stream
            as opposed to be suggested via a checksum directive/pragma
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ExceptionHandlerRegion">
            <summary>
            A region representing an exception handler clause. The region exposes the type (catch or
            finally) and the bounds of the try block and catch or finally block as needed by 
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ExceptionHandlerRegion.HandlerKind">
            <summary>
            Handler kind for this SEH info
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ExceptionHandlerRegion.ExceptionType">
            <summary>
            If HandlerKind == HandlerKind.Catch, this is the type of expection to catch. If HandlerKind == HandlerKind.Filter, this is System.Object.
            Otherwise this is a Dummy.TypeReference.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ExceptionHandlerRegion.FilterDecisionStartOffset">
            <summary>
            Label instruction corresponding to the start of filter decision block
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ExceptionHandlerRegion.TryStartOffset">
            <summary>
            Label instruction corresponding to the start of try block
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ExceptionHandlerRegion.TryEndOffset">
            <summary>
            Label instruction corresponding to the end of try block
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ExceptionHandlerRegion.HandlerStartOffset">
            <summary>
            Label instruction corresponding to the start of handler block
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ExceptionHandlerRegion.HandlerEndOffset">
            <summary>
            Label instruction corresponding to the end of handler block
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IMetadataConstant">
            <summary>
            An expression that does not change its value at runtime and can be evaluated at compile time.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMetadataConstant.Value">
            <summary>
            The compile time value of the expression. Null to represent a null object reference or a null array.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IMetadataCreateArray">
            <summary>
            An expression that creates an array instance in metadata. Only for use in custom attributes.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMetadataCreateArray.ElementType">
            <summary>
            The element type of the array.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMetadataCreateArray.Elements">
            <summary>
            The values of the array elements. May be empty to represent an empty array.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMetadataCreateArray.ElementCount">
            <summary>
            The number of elements in the array.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IMetadataExpression">
            <summary>
            An expression that can be represented directly in metadata.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataExpression.Dispatch(Microsoft.Cci.MetadataVisitor)">
            <summary>
            Calls the visitor.Visit(T) method where T is the most derived object model node interface type implemented by the concrete type
            of the object implementing IStatement. The dispatch method does not invoke Dispatch on any child objects. If child traversal
            is desired, the implementations of the Visit methods should do the subsequent dispatching.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMetadataExpression.Type">
            <summary>
            The type of value the expression represents.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IMetadataNamedArgument">
            <summary>
            An expression that represents a (name, value) pair and that is typically used in method calls, custom attributes and object initializers.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMetadataNamedArgument.ArgumentName">
            <summary>
            The name of the parameter or property or field that corresponds to the argument.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMetadataNamedArgument.ArgumentValue">
            <summary>
            The value of the argument.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMetadataNamedArgument.IsField">
            <summary>
            True if the named argument provides the value of a field.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IMetadataTypeOf">
            <summary>
            An expression that results in a System.Type instance.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMetadataTypeOf.TypeToGet">
            <summary>
            The type that will be represented by the System.Type instance.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ExternNamespace">
            <summary>
            Represents an assembly reference with an alias (i.e. an extern alias in C#).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ExternNamespace.NamespaceAlias">
            <summary>
            An alias for the global namespace of the assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ExternNamespace.AssemblyName">
            <summary>
            The name of the referenced assembly.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ICustomAttribute">
            <summary>
            A metadata custom attribute.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ICustomAttribute.GetArguments(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Zero or more positional arguments for the attribute constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ICustomAttribute.Constructor(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            A reference to the constructor that will be used to instantiate this custom attribute during execution (if the attribute is inspected via Reflection).
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ICustomAttribute.GetNamedArguments(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Zero or more named arguments that specify values for fields and properties of the attribute.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ICustomAttribute.ArgumentCount">
            <summary>
            The number of positional arguments.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ICustomAttribute.NamedArgumentCount">
            <summary>
            The number of named arguments.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ICustomAttribute.GetType(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The type of the attribute. For example System.AttributeUsageAttribute.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ICustomAttribute.AllowMultiple">
            <summary>
            Whether attribute allows multiple.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IFileReference">
            <summary>
            Represents a file referenced by an assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFileReference.HasMetadata">
            <summary>
            True if the file has metadata.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFileReference.FileName">
            <summary>
            File name with extension.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IFileReference.GetHashValue(System.Reflection.AssemblyHashAlgorithm)">
            <summary>
            A hash of the file contents.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.LocalScope">
            <summary>
            A range of CLR IL operations that comprise a lexical scope, specified as an IL offset and a length.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.LocalScope.Offset">
            <summary>
            The offset of the first operation in the scope.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.LocalScope.Length">
            <summary>
            The length of the scope. Offset+Length equals the offset of the first operation outside the scope, or equals the method body length.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.LocalScope.Constants">
            <summary>
            Returns zero or more local constant definitions that are local to the given scope.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.LocalScope.Variables">
            <summary>
            Returns zero or more local variable definitions that are local to the given scope.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ManagedResource.#ctor(System.String,System.Boolean,System.Func{System.IO.Stream},Microsoft.Cci.IFileReference,System.UInt32)">
            <summary>
            <paramref name="streamProvider"/> streamProvider callers will dispose result after use.
            <paramref name="streamProvider"/> and <paramref name="fileReference"/> are mutually exclusive.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.CallingConvention">
            <summary>
            Specifies how the caller passes parameters to the callee and who cleans up the stack.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.CallingConvention.C">
            <summary>
            C/C++ style calling convention for unmanaged methods. The call stack is cleaned up by the caller, 
            which makes this convention suitable for calling methods that accept extra arguments.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.CallingConvention.Default">
            <summary>
            The convention for calling managed methods with a fixed number of arguments.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.CallingConvention.ExtraArguments">
            <summary>
            The convention for calling managed methods that accept extra arguments.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.CallingConvention.FastCall">
            <summary>
            Arguments are passed in registers when possible. This calling convention is not yet supported.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.CallingConvention.Standard">
            <summary>
            Win32 API calling convention for calling unmanaged methods via PlatformInvoke. The call stack is cleaned up by the callee.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.CallingConvention.ThisCall">
            <summary>
            C++ member unmanaged method (non-vararg) calling convention. The callee cleans the stack and the this pointer is pushed on the stack last.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.CallingConvention.Generic">
            <summary>
            The convention for calling a generic method.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.CallingConvention.HasThis">
            <summary>
            The convention for calling an instance method with an implicit this parameter (the method does not have an explicit parameter definition for this).
            </summary>
        </member>
        <member name="F:Microsoft.Cci.CallingConvention.ExplicitThis">
            <summary>
            The convention for calling an instance method that explicitly declares its first parameter to correspond to the this instance.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IEventDefinition">
            <summary>
            An event is a member that enables an object or class to provide notifications. Clients can attach executable code for events by supplying event handlers.
            This interface models the metadata representation of an event.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IEventDefinition.Accessors">
            <summary>
            A list of methods that are associated with the event.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IEventDefinition.Adder">
            <summary>
            The method used to add a handler to the event.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IEventDefinition.Caller">
            <summary>
            The method used to call the event handlers when the event occurs. May be null.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IEventDefinition.IsRuntimeSpecial">
            <summary>
            True if the event gets special treatment from the runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IEventDefinition.IsSpecialName">
            <summary>
            This event is special in some way, as specified by the name.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IEventDefinition.Remover">
            <summary>
            The method used to add a handler to the event.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IEventDefinition.GetType(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The (delegate) type of the handlers that will handle the event.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IFieldDefinition">
            <summary>
            A field is a member that represents a variable associated with an object or class.
            This interface models the metadata representation of a field.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IFieldDefinition.GetCompileTimeValue(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The compile time value of the field. This value should be used directly in IL, rather than a reference to the field.
            If the field does not have a valid compile time value, Dummy.Constant is returned.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.FieldMapping">
            <summary>
            Information of the location where this field is mapped to
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.IsCompileTimeConstant">
            <summary>
            This field is a compile-time constant. The field has no runtime location and cannot be directly addressed from IL.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.IsMapped">
            <summary>
            This field is mapped to an explicitly initialized (static) memory location.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.IsMarshalledExplicitly">
            <summary>
            This field has associated field marshalling information.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.IsNotSerialized">
            <summary>
            The field does not have to be serialized when its containing instance is serialized.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.IsReadOnly">
            <summary>
            This field can only be read. Initialization takes place in a constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.IsRuntimeSpecial">
            <summary>
            True if the field gets special treatment from the runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.IsSpecialName">
            <summary>
            This field is special in some way, as specified by the name.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.IsStatic">
            <summary>
            This field is static (shared by all instances of its declaring type).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.MarshallingInformation">
            <summary>
            Specifies how this field is marshalled when it is accessed from unmanaged code.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.MarshallingDescriptor">
            <summary>
            Checked if IsMarshalledExplicitly == true and MarshallingInformation is null
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.Offset">
            <summary>
            Offset of the field.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IFieldReference">
            <summary>
            A reference to a field.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IFieldReference.GetType(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The type of value that is stored in this field.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IFieldReference.GetResolvedField(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The Field being referred to.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldReference.IsContextualNamedEntity">
            <summary>
            True, if field is an IContextualNamedEntity, even if field reference implements the interface,
            doesn't mean it is contextual.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ILocalDefinition">
            <summary>
            An object that represents a local variable or constant.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.CompileTimeValue">
            <summary>
            The compile time value of the definition, if it is a local constant.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.CustomModifiers">
            <summary>
            Custom modifiers associated with local variable definition.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.IsConstant">
            <summary>
            True if this local definition is readonly and initialized with a compile time constant value.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.IsPinned">
            <summary>
            True if the value referenced by the local must not be moved by the actions of the garbage collector.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.IsReference">
            <summary>
            True if the local contains a managed pointer (for example a reference to a local variable or a reference to a field of an object).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.IsDynamic">
            <summary>
            True if the local variable is of type Dynamic.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.IsCompilerGenerated">
            <summary>
            True if the local was not declared in source.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.DynamicTransformFlags">
            <summary>
            Should return the synthesized dynamic attributes of the local definition if any. Else null.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.Type">
            <summary>
            The type of the local.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.Location">
            <summary>
            Location for reporting diagnostics about the local.
            </summary>
            <remark>
            Use <see cref="P:Microsoft.CodeAnalysis.Location.None"/> rather than null.
            </remark>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.SlotIndex">
            <summary>
            Slot index or -1 if not applicable.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.AsyncMethodBodyDebugInfo">
            <summary>
            Represents additional info needed by async method implementation methods 
            (MoveNext() methods) to properly emit necessary PDB data for async debugging.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.AsyncMethodBodyDebugInfo.KickoffMethod">
            <summary> Original async method transformed into MoveNext() </summary>
        </member>
        <member name="F:Microsoft.Cci.AsyncMethodBodyDebugInfo.CatchHandlerOffset">
            <summary> IL offset of catch handler or -1 </summary>
        </member>
        <member name="F:Microsoft.Cci.AsyncMethodBodyDebugInfo.YieldOffsets">
            <summary> Set of IL offsets where await operators yield control </summary>
        </member>
        <member name="F:Microsoft.Cci.AsyncMethodBodyDebugInfo.ResumeOffsets">
            <summary> Set of IL offsets where await operators are to be resumed </summary>
        </member>
        <member name="T:Microsoft.Cci.IMethodBody">
            <summary>
            A metadata (IL) level represetation of the body of a method or of a property/event accessor.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMethodBody.Dispatch(Microsoft.Cci.MetadataVisitor)">
            <summary>
            Calls the visitor.Visit(T) method where T is the most derived object model node interface type implemented by the concrete type
            of the object implementing IDoubleDispatcher. The dispatch method does not invoke Dispatch on any child objects. If child traversal
            is desired, the implementations of the Visit methods should do the subsequent dispatching.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.ExceptionRegions">
            <summary>
            A list exception data within the method body IL.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.LocalsAreZeroed">
            <summary>
            True if the locals are initialized by zeroing the stack upon method entry.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.LocalVariables">
            <summary>
            The local variables of the method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.MethodDefinition">
            <summary>
            The definition of the method whose body this is.
            If this is the body of an event or property accessor, this will hold the corresponding adder/remover/setter or getter method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.AsyncMethodDebugInfo">
            <summary> The additional info required by debugger  </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.MaxStack">
            <summary>
            The maximum number of elements on the evaluation stack during the execution of the method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.CustomDebugInfoKind">
            <summary>
            The PDB content for custom debug information is different between Visual Basic and CSharp.
            E.g. CS always includes a CustomMetadata Header (MD2) that contains the namespace scope counts, where 
            as VB only outputs namespace imports into the namespace scopes. CS defines forwards in that header, VB includes
            them into the scopes list.
            This enum is used to distinguish which style to pick while writing the PDB information.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.HasDynamicLocalVariables">
            <summary>
            Returns true if there is atleast one dynamic local within the MethodBody
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.LocalScopes">
            <summary>
            Returns zero or more local (block) scopes into which the CLR IL operations in the given method body is organized.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.NamespaceScopes">
            <summary>
            Returns zero or more namespace scopes into which the namespace type containing the given method body has been nested.
            These scopes determine how simple names are looked up inside the method body. There is a separate scope for each dotted
            component in the namespace type name. For istance namespace type x.y.z will have two namespace scopes, the first is for the x and the second
            is for the y.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.IteratorScopes">
            <summary>
            Returns zero or more local (block) scopes, each defining an IL range in which an iterator local is defined.
            The scopes are returned for the MoveNext method of the object returned by the iterator method.
            The index of the scope corresponds to the index of the local.  Specifically local scope i corresponds
            to the local stored in a field named &lt;localName&gt;5__i of the class used to store the local values in
            between calls to MoveNext, where localName is the original name of the local variable.  For example, if
            the first local to be moved into the class is named "xyzzy", it will be stored in a field named
            "&lt;xyzzy&gt;5__1", and the ILocalScope returned from this method at index 1 (i.e. the second one) will
            have the scope information for where that variable is in scope.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.IteratorClassName">
            <summary>
            If the body was written as an iterator, returns the name of the (nested)
            type that implements the iterator's state machine.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.CustomDebugInfoKind">
            <summary>
            This enum is used to distinguish which style to pick while writing the PDB information.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IMethodDefinition">
            <summary>
            This interface models the metadata representation of a method.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMethodDefinition.GetBody(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            A container for a list of IL instructions providing the implementation (if any) of this method.
            </summary>
            <remarks>
            When emitting metadata-only assemblies this returns null even if <see cref="M:Cci.Extensions.HasBody"/> returns true.
            </remarks>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.GenericParameters">
            <summary>
            If the method is generic then this list contains the type parameters.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.HasDeclarativeSecurity">
            <summary>
            True if this method has a non empty collection of SecurityAttributes or the System.Security.SuppressUnmanagedCodeSecurityAttribute.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsAbstract">
            <summary>
            True if the method does not provide an implementation.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsAccessCheckedOnOverride">
            <summary>
            True if the method can only be overridden when it is also accessible. 
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsConstructor">
            <summary>
            True if the method is a constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsExternal">
            <summary>
            True if the method has an external implementation (i.e. not supplied by this definition).
            </summary>
            <remarks>
            If the method is not external and not abstract it has to provide an IL body.
            </remarks>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsHiddenBySignature">
            <summary>
            True if this method is hidden if a derived type declares a method with the same name and signature. 
            If false, any method with the same name hides this method. This flag is ignored by the runtime and is only used by compilers.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsNewSlot">
            <summary>
            The method always gets a new slot in the virtual method table. 
            This means the method will hide (not override) a base type method with the same name and signature.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsPlatformInvoke">
            <summary>
            True if the method is implemented via the invocation of an underlying platform method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsRuntimeSpecial">
            <summary>
            True if the method gets special treatment from the runtime. For example, it might be a constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsSealed">
            <summary>
            True if the method may not be overridden.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsSpecialName">
            <summary>
            True if the method is special in some way for tools. For example, it might be a property getter or setter.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsStatic">
            <summary>
            True if the method does not require an instance of its declaring type as its first argument.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsVirtual">
            <summary>
            True if the method may be overridden (or if it is an override).
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMethodDefinition.GetImplementationAttributes(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Implementation flags.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.Parameters">
            <summary>
            The parameters forming part of this signature.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.PlatformInvokeData">
            <summary>
            Detailed information about the PInvoke stub. Identifies which method to call, which module has the method and the calling convention among other things.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.RequiresSecurityObject">
            <summary>
            True if the method calls another method containing security code. If this flag is set, the method
            should have System.Security.DynamicSecurityMethodAttribute present in its list of custom attributes.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.ReturnValueAttributes">
            <summary>
            Custom attributes associated with the method's return value.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.ReturnValueIsMarshalledExplicitly">
            <summary>
            The return value has associated marshalling information.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.ReturnValueMarshallingInformation">
            <summary>
            Specifies how the return value is marshalled when the method is called from unmanaged code.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.ReturnValueMarshallingDescriptor">
            <summary>
            Checked if ReturnValueIsMarshalledExplicitly == true and ReturnValueMarshallingInformation is null
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.SecurityAttributes">
            <summary>
            Declarative security actions for this method.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IParameterDefinition">
            <summary>
            This interface models the metadata representation of a method or property parameter.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IParameterDefinition.GetDefaultValue(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            A compile time constant value that should be supplied as the corresponding argument value by callers that do not explicitly specify an argument value for this parameter.
            Null if the parameter doesn't have default value.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterDefinition.HasDefaultValue">
            <summary>
            True if the parameter has a default value that should be supplied as the argument value by a caller for which the argument value has not been explicitly specified.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterDefinition.IsIn">
            <summary>
            True if the argument value must be included in the marshalled arguments passed to a remote callee.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterDefinition.IsMarshalledExplicitly">
            <summary>
            This parameter has associated marshalling information.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterDefinition.IsOptional">
            <summary>
            True if the argument value must be included in the marshalled arguments passed to a remote callee only if it is different from the default value (if there is one).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterDefinition.IsOut">
            <summary>
            True if the final value assigned to the parameter will be marshalled with the return values passed back from a remote callee.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterDefinition.MarshallingInformation">
            <summary>
            Specifies how this parameter is marshalled when it is accessed from unmanaged code.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterDefinition.MarshallingDescriptor">
            <summary>
            Checked if IsMarshalledExplicitly == true and MarshallingInformation is null
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IPropertyDefinition">
            <summary>
            A property is a member that provides access to an attribute of an object or a class.
            This interface models the metadata representation of a property.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPropertyDefinition.Accessors">
            <summary>
            A list of methods that are associated with the property.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPropertyDefinition.DefaultValue">
            <summary>
            A compile time constant value that provides the default value for the property. (Who uses this and why?)
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPropertyDefinition.Getter">
            <summary>
            The method used to get the value of this property. May be absent (null).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPropertyDefinition.HasDefaultValue">
            <summary>
            True if this property has a compile time constant associated with that serves as a default value for the property. (Who uses this and why?)
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPropertyDefinition.IsRuntimeSpecial">
            <summary>
            True if this property gets special treatment from the runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPropertyDefinition.IsSpecialName">
            <summary>
            True if this property is special in some way, as specified by the name.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPropertyDefinition.Parameters">
            <summary>
            The parameters forming part of this signature.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPropertyDefinition.Setter">
            <summary>
            The method used to set the value of this property. May be absent (null).
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ISignature">
            <summary>
            The parameters and return type that makes up a method or property signature.
            This interface models the metadata representation of a signature.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISignature.CallingConvention">
            <summary>
            Calling convention of the signature.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISignature.ParameterCount">
            <summary>
            The number of required parameters of the signature.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ISignature.GetParameters(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The parameters forming part of this signature.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISignature.ReturnValueCustomModifiers">
            <summary>
            Returns the list of custom modifiers, if any, associated with the returned value. Evaluate this property only if ReturnValueIsModified is true.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISignature.ReturnValueIsByRef">
            <summary>
            True if the return value is passed by reference (using a managed pointer).
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ISignature.GetType(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The return type of the method or type of the property.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ITypeDefinitionMember">
            <summary>
            A member of a type definition, such as a field or a method.
            This interface models the metadata representation of a type member.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinitionMember.ContainingTypeDefinition">
            <summary>
            The type definition that contains this member.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinitionMember.Visibility">
            <summary>
            Indicates if the member is public or confined to its containing type, derived types and/or declaring assembly.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ITypeMemberReference">
            <summary>
            A reference to a member of a type, such as a field or a method.
            This interface models the metadata representation of a type member reference.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeMemberReference.GetContainingType(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            A reference to the containing type of the referenced type member.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ISpecializedEventDefinition">
            <summary>
            Represents the specialized event definition.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISpecializedEventDefinition.UnspecializedVersion">
            <summary>
            The event that has been specialized to obtain this event. When the containing type is an instance of type which is itself a specialized member (i.e. it is a nested
            type of a generic type instance), then the unspecialized member refers to a member from the unspecialized containing type. (I.e. the unspecialized member always
            corresponds to a definition that is not obtained via specialization.)
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ISpecializedFieldReference">
            <summary>
            Represents reference specialized field.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISpecializedFieldReference.UnspecializedVersion">
            <summary>
            A reference to the field definition that has been specialized to obtain the field definition referred to by this field reference. 
            When the containing type of the referenced specialized field definition is itself a specialized nested type of a generic type instance, 
            then the unspecialized field reference refers to the corresponding field definition from the unspecialized containing type definition.
            (I.e. the unspecialized field reference always refers to a field definition that is not obtained via specialization.)
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ISpecializedMethodReference">
            <summary>
            Represents reference specialized method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISpecializedMethodReference.UnspecializedVersion">
            <summary>
            A reference to the method definition that has been specialized to obtain the method definition referred to by this method reference. 
            When the containing type of the referenced specialized method definition is itself a specialized nested type of a generic type instance, 
            then the unspecialized method reference refers to the corresponding method definition from the unspecialized containing type definition.
            (I.e. the unspecialized method reference always refers to a method definition that is not obtained via specialization.)
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ISpecializedPropertyDefinition">
            <summary>
            Represents the specialized property definition.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISpecializedPropertyDefinition.UnspecializedVersion">
            <summary>
            The property that has been specialized to obtain this property. When the containing type is an instance of type which is itself a specialized member (i.e. it is a nested
            type of a generic type instance), then the unspecialized member refers to a member from the unspecialized containing type. (I.e. the unspecialized member always
            corresponds to a definition that is not obtained via specialization.)
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IMethodReference">
            <summary>
            A reference to a method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodReference.AcceptsExtraArguments">
            <summary>
            True if the call sites that references the method with this object supply extra arguments.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodReference.GenericParameterCount">
            <summary>
            The number of generic parameters of the method. Zero if the referenced method is not generic.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodReference.IsGeneric">
            <summary>
            True if the method has generic parameters;
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMethodReference.GetResolvedMethod(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The method being referred to.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodReference.ExtraParameters">
            <summary>
            Information about this types of the extra arguments supplied at the call sites that references the method with this object.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGenericMethodInstanceReference">
            <summary>
            A reference to generic method instantiated with a list of type arguments.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IGenericMethodInstanceReference.GetGenericArguments(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The type arguments that were used to instantiate this.GenericMethod in order to create this method.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IGenericMethodInstanceReference.GetGenericMethod(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Returns the generic method of which this method is an instance.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGlobalFieldDefinition">
            <summary>
            Represents a global field in symbol table.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGlobalMethodDefinition">
            <summary>
            Represents a global method in symbol table.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGlobalMethodDefinition.Name">
            <summary>
            The name of the method.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.MetadataVisitor">
            <summary>
            A visitor base class that traverses the object model in depth first, left to right order.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataVisitor.DispatchAsReference(Microsoft.Cci.ITypeReference)">
            <summary>
            Use this routine, rather than ITypeReference.Dispatch, to call the appropriate derived overload of an ITypeReference.
            The former routine will call Visit(INamespaceTypeDefinition) rather than Visit(INamespaceTypeReference), etc., 
            in the case where a definition is used as a reference to itself.
            </summary>
            <param name="typeReference">A reference to a type definition. Note that a type definition can serve as a reference to itself.</param>
        </member>
        <member name="M:Microsoft.Cci.MetadataVisitor.DispatchAsReference(Microsoft.Cci.IUnitReference)">
            <summary>
            Use this routine, rather than IUnitReference.Dispatch, to call the appropriate derived overload of an IUnitReference.
            The former routine will call Visit(IAssembly) rather than Visit(IAssemblyReference), etc.
            in the case where a definition is used as the reference to itself.
            </summary>
            <param name="unitReference">A reference to a unit. Note that a unit can serve as a reference to itself.</param>
        </member>
        <member name="T:Microsoft.Cci.IteratorHelper">
            <summary>
            A container for static helper methods that are used for manipulating and computing iterators.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IteratorHelper.EnumerableIsNotEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            True if the given enumerable is not null and contains at least one element.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IteratorHelper.EnumerableIsEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            True if the given enumerable is null or contains no elements
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IteratorHelper.EnumerableCount``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the number of elements in the given enumerable. A null enumerable is allowed and results in 0.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.SecurityAttribute">
            <summary>
            A declarative specification of a security action applied to a set of permissions. Used by the CLR loader to enforce security restrictions.
            Each security attribute represents a serialized permission or permission set for a specified security action.
            The union of the security attributes with identical security action, define the permission set to which the security action applies.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IMarshallingInformation">
            <summary>
            Information about how values of managed types should be marshalled to and from unmanaged types.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMarshallingInformation.GetCustomMarshaller(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            <see cref="T:Microsoft.Cci.ITypeReference"/> or a string (ususally a fully-qualified type name of a type implementing the custom marshaller, but Dev11 allows any string).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMarshallingInformation.CustomMarshallerRuntimeArgument">
            <summary>
            An argument string (cookie) passed to the custom marshaller at run time.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMarshallingInformation.ElementType">
            <summary>
            The unmanaged element type of the unmanaged array.
            -1 if it should be omitted from the marshal blob.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMarshallingInformation.IidParameterIndex">
            <summary>
            Specifies the index of the parameter that contains the value of the Inteface Identifier (IID) of the marshalled object.
            -1 if it should be omitted from the marshal blob.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMarshallingInformation.UnmanagedType">
            <summary>
            The unmanaged type to which the managed type will be marshalled. This can be be UnmanagedType.CustomMarshaler, in which case the unmanaged type
            is decided at runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMarshallingInformation.NumberOfElements">
            <summary>
            The number of elements in the fixed size portion of the unmanaged array.
            -1 if it should be omitted from the marshal blob.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMarshallingInformation.ParamIndex">
            <summary>
            The zero based index of the parameter in the unmanaged method that contains the number of elements in the variable portion of unmanaged array.
            If -1, the variable portion is of size zero, or the caller conveys the size of the variable portion of the array to the unmanaged method in some other way.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMarshallingInformation.SafeArrayElementSubtype">
            <summary>
            The type to which the variant values of all elements of the safe array must belong. See also SafeArrayElementUserDefinedSubtype.
            (The element type of a safe array is VARIANT. The "sub type" specifies the value of all of the tag fields (vt) of the element values. )
            -1 if it should be omitted from the marshal blob.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMarshallingInformation.GetSafeArrayElementUserDefinedSubtype(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            A reference to the user defined type to which the variant values of all elements of the safe array must belong.
            (The element type of a safe array is VARIANT. The tag fields will all be either VT_DISPATCH or VT_UNKNOWN or VT_RECORD.
            The "user defined sub type" specifies the type of value the ppdispVal/ppunkVal/pvRecord fields of the element values may point to.)
            </summary>
        </member>
        <member name="T:Microsoft.Cci.INamedEntity">
            <summary>
            Implemented by any entity that has a name.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.INamedEntity.Name">
            <summary>
            The name of the entity.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IContextualNamedEntity">
            <summary>
            The name of the entity depends on other metadata (tokens, signatures) originated from
            PeWriter.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IContextualNamedEntity.AssociateWithPeWriter(Microsoft.Cci.PeWriter)">
            <summary>
            Method must be called before calling INamedEntity.Name.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IParameterListEntry">
            <summary>
            Implemented by an entity that is always a member of a particular parameter list, such as an IParameterDefinition.
            Provides a way to determine the position where the entity appears in the parameter list.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterListEntry.Index">
            <summary>
            The position in the parameter list where this instance can be found.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.PInvokeAttributes">
            <summary>
            This enum is used internally by BCL. It includes flags that are not in the metadata spec.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IPlatformInvokeInformation">
            <summary>
            Information that describes how a method from the underlying Platform is to be invoked.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPlatformInvokeInformation.ModuleName">
            <summary>
            Module providing the method/field.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPlatformInvokeInformation.EntryPointName">
            <summary>
            Name of the method providing the implementation.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPlatformInvokeInformation.Flags">
            <summary>
            Flags that determine marshalling behavior.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IWin32Resource">
            <summary>
            A resource file formatted according to Win32 API conventions and typically obtained from a Portable Executable (PE) file.
            See the Win32 UpdateResource method for more details.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IWin32Resource.TypeName">
            <summary>
            A string that identifies what type of resource this is. Only valid if this.TypeId &lt; 0.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IWin32Resource.TypeId">
            <summary>
            An integer tag that identifies what type of resource this is. If the value is less than 0, this.TypeName should be used instead.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IWin32Resource.Name">
            <summary>
            The name of the resource. Only valid if this.Id &lt; 0.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IWin32Resource.Id">
            <summary>
            An integer tag that identifies this resource. If the value is less than 0, this.Name should be used instead.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IWin32Resource.LanguageId">
            <summary>
            The language for which this resource is appropriate.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IWin32Resource.CodePage">
            <summary>
            The code page for which this resource is appropriate.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IWin32Resource.Data">
            <summary>
            The data of the resource.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.OperationCheckFlags">
            <summary>
            Flags for IL No Operation
            </summary>
        </member>
        <member name="F:Microsoft.Cci.OperationCheckFlags.NoTypeCheck">
            <summary>
            No type check needs to be performed for next operation
            </summary>
        </member>
        <member name="F:Microsoft.Cci.OperationCheckFlags.NoRangeCheck">
            <summary>
            No range check needs to be performed for next operation
            </summary>
        </member>
        <member name="F:Microsoft.Cci.OperationCheckFlags.NoNullCheck">
            <summary>
            No null check needs to be performed for next operation
            </summary>
        </member>
        <member name="T:Microsoft.Cci.PESectionKind">
            <summary>
            An enumeration indicating the section inside the PE File
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PESectionKind.Illegal">
            <summary>
            Section is unrecognized
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PESectionKind.ConstantData">
            <summary>
            Section for initialized constant data.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PESectionKind.CoverageData">
            <summary>
            Section for code coverage data.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PESectionKind.StaticData">
            <summary>
            Section for initialized writable data.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PESectionKind.Text">
            <summary>
            Section for IL and Metadata.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PESectionKind.ThreadLocalStorage">
            <summary>
            Section for initialized thread local storage.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ISectionBlock">
            <summary>
            Represents a block of data stored at a given offset within a specified section of the PE file.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISectionBlock.PESectionKind">
            <summary>
            Section where the block resides.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISectionBlock.Offset">
            <summary>
            Offset into section where the block resides.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISectionBlock.Size">
            <summary>
            Size of the block.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISectionBlock.Data">
            <summary>
            Byte information stored in the block.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.NamespaceScope">
            <summary>
            This is a list of the using directives (including aliases) in a lexial scope.
            </summary>
            <remarks>
            This scope is tied to a particular method body, so that partial types can be accommodated.
            </remarks>
        </member>
        <member name="P:Microsoft.Cci.NamespaceScope.UsedNamespaces">
            <summary>
            Zero or more used namespaces. These correspond to using clauses in C#.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PeWriter.NameLengthLimit">
            <summary>
            This is the maximum length of a type or member name in metadata, assuming
            the name is in UTF-8 format and not (yet) null-terminated.
            </summary>
            <remarks>
            Source names may have to be shorter still to accommodate mangling.
            Used for event names, field names, property names, field names, method def names,
            member ref names, type def (full) names, type ref (full) names, exported type
            (full) names, parameter names, manifest resource names, and unmanaged method names
            (ImplMap table).
            
            See CLI Part II, section 22.
            </remarks>
        </member>
        <member name="F:Microsoft.Cci.PeWriter.PathLengthLimit">
            <summary>
            This is the maximum length of a path in metadata, assuming the path is in UTF-8
            format and not (yet) null-terminated.
            </summary>
            <remarks>
            Used for file names, module names, and module ref names.
            
            See CLI Part II, section 22.
            </remarks>
        </member>
        <member name="F:Microsoft.Cci.PeWriter.PdbLengthLimit">
            <summary>
            This is the maximum length of a string in the PDB, assuming it is in UTF-8 format 
            and not (yet) null-terminated.
            </summary>
            <remarks>
            Used for import strings, locals, and local constants.
            </remarks>
        </member>
        <member name="F:Microsoft.Cci.PeWriter.deterministic">
            <summary>
            True if we should attempt to generate a deterministic output (no timestamps or random data).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PeWriter.IsFullMetadata">
            <summary>
            Returns true if writing full metadata, false if writing delta.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PeWriter.IsMinimalDelta">
            <summary>
            True if writing delta metadata in a minimal format.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PeWriter.Generation">
            <summary>
            Returns metadata generation ordinal. Zero for
            full metadata and non-zero for delta.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PeWriter.EncId">
            <summary>
            Returns unique Guid for this delta, or default(Guid)
            if full metadata.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PeWriter.EncBaseId">
            <summary>
            Returns Guid of previous delta, or default(Guid)
            if full metadata or generation 1 delta.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.PeWriter.CompressMetadataStream">
            <summary>
            Returns true if the metadata stream should be compressed.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.TryGetTypeDefIndex(Microsoft.Cci.ITypeDefinition,System.UInt32@)">
            <summary>
            Returns true and the 1-based index of the type definition
            if the type definition is recognized. Otherwise returns false.
            The index is into the full metadata.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetTypeDefIndex(Microsoft.Cci.ITypeDefinition)">
            <summary>
            The 1-based index of the type definition.
            The index is into the full metadata.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetTypeDef(System.Int32)">
            <summary>
            The type definition at the 0-based index into the full set. Deltas
            are only required to support indexing into current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetTypeDefs">
            <summary>
            The type definitions to be emitted, in row order. These
            are just the type definitions from the current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetEventDefIndex(Microsoft.Cci.IEventDefinition)">
            <summary>
            The 1-based index of the event definition.
            The index is into the full metadata.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetEventDefs">
            <summary>
            The event definitions to be emitted, in row order. These
            are just the event definitions from the current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetFieldDefIndex(Microsoft.Cci.IFieldDefinition)">
            <summary>
            The 1-based index of the field definition.
            The index is into the full metadata.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetFieldDefs">
            <summary>
            The field definitions to be emitted, in row order. These
            are just the field definitions from the current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.TryGetMethodDefIndex(Microsoft.Cci.IMethodDefinition,System.UInt32@)">
            <summary>
            Returns true and the 1-based index of the method definition
            if the method definition is recognized. Otherwise returns false.
            The index is into the full metadata.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetMethodDefIndex(Microsoft.Cci.IMethodDefinition)">
            <summary>
            The 1-based index of the method definition.
            The index is into the full metadata.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetMethodDef(System.Int32)">
            <summary>
            The method definition at the 0-based index into the full set. Deltas
            are only required to support indexing into current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetMethodDefs">
            <summary>
            The method definitions to be emitted, in row order. These
            are just the method definitions from the current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetPropertyDefIndex(Microsoft.Cci.IPropertyDefinition)">
            <summary>
            The 1-based index of the property definition.
            The index is into the full metadata.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetPropertyDefs">
            <summary>
            The property definitions to be emitted, in row order. These
            are just the property definitions from the current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetParameterDefIndex(Microsoft.Cci.IParameterDefinition)">
            <summary>
            The 1-based index of the parameter definition.
            The index is into the full metadata.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetParameterDefs">
            <summary>
            The parameter definitions to be emitted, in row order. These
            are just the parameter definitions from the current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetGenericParameterIndex(Microsoft.Cci.IGenericParameter)">
            <summary>
            The 1-based index of the generic parameter definition.
            The index is into the full metadata.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetGenericParameters">
            <summary>
            The generic parameter definitions to be emitted, in row order. These
            are just the generic parameter definitions from the current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetFieldDefIndex(Microsoft.Cci.INamedTypeDefinition)">
            <summary>
            The 1-based index of the first field of the type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetMethodDefIndex(Microsoft.Cci.INamedTypeDefinition)">
            <summary>
            The 1-based index of the first method of the type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetParameterDefIndex(Microsoft.Cci.IMethodDefinition)">
            <summary>
            The 1-based index of the first parameter of the method.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetOrAddAssemblyRefIndex(Microsoft.Cci.IAssemblyReference)">
            <summary>
            Return the 1-based index of the assembly reference, adding
            the reference to the index for this generation if missing.
            The index is into the full metadata. However, deltas
            are not required to return rows from previous generations.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetAssemblyRefs">
            <summary>
            The assembly references to be emitted, in row order. These
            are just the assembly references from the current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetOrAddModuleRefIndex(System.String)">
            <summary>
            Return the 1-based index of the module reference, adding
            the reference to the index for this generation if missing.
            The index is into the full metadata. However, deltas
            are not required to return rows from previous generations.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetModuleRefs">
            <summary>
            The module references to be emitted, in row order. These
            are just the module references from the current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetOrAddMemberRefIndex(Microsoft.Cci.ITypeMemberReference)">
            <summary>
            Return the 1-based index of the member reference, adding
            the reference to the index for this generation if missing.
            The index is into the full metadata. However, deltas
            are not required to return rows from previous generations.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetMemberRefs">
            <summary>
            The member references to be emitted, in row order. These
            are just the member references from the current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetOrAddMethodSpecIndex(Microsoft.Cci.IGenericMethodInstanceReference)">
            <summary>
            Return the 1-based index of the method spec, adding
            the spec to the index for this generation if missing.
            The index is into the full metadata. However, deltas
            are not required to return rows from previous generations.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetMethodSpecs">
            <summary>
            The method specs to be emitted, in row order. These
            are just the method specs from the current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.TryGetTypeRefIndex(Microsoft.Cci.ITypeReference,System.UInt32@)">
            <summary>
            Return true and the 1-based index of the type reference
            if the reference is available in the current generation.
            The index is into the full metadata. However, deltas
            are not required to return rows from previous generations.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetOrAddTypeRefIndex(Microsoft.Cci.ITypeReference)">
            <summary>
            Return the 1-based index of the type reference, adding
            the reference to the index for this generation if missing.
            The index is into the full metadata. However, deltas
            are not required to return rows from previous generations.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetTypeRefs">
            <summary>
            The type references to be emitted, in row order. These
            are just the type references from the current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetOrAddTypeSpecIndex(Microsoft.Cci.ITypeReference)">
            <summary>
            Return the 1-based index of the type spec, adding
            the spec to the index for this generation if missing.
            The index is into the full metadata. However, deltas
            are not required to return rows from previous generations.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetTypeSpecs">
            <summary>
            The type specs to be emitted, in row order. These
            are just the type specs from the current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetOrAddStandAloneSignatureIndex(System.UInt32)">
            <summary>
            Return the 1-based index of the signature index, adding
            the signature to the index for this generation if missing.
            The index is into the full metadata. However, deltas
            are not required to return rows from previous generations.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetStandAloneSignatures">
            <summary>
            The signature indices to be emitted, in row order. These
            are just the signature indices from the current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetBlobStreamOffset">
            <summary>
            Offset into full metadata blob stream.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetStringStreamOffset">
            <summary>
            Offset into full metadata string stream.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetUserStringStreamOffset">
            <summary>
            Offset into full metadata user string stream.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.CreateReferenceVisitor">
            <summary>
            Return a visitor for traversing all references to be emitted.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.OnSerializedMethodBody(Microsoft.Cci.IMethodDefinition,Microsoft.Cci.IMethodBody)">
            <summary>
            Invoked after serializing the method body.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.OnSerializedMetadataTables">
            <summary>
            Invoked after serializing metadata tables.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.PopulateEventMapTableRows(System.Collections.Generic.List{Microsoft.Cci.PeWriter.EventMapRow})">
            <summary>
            Populate EventMap table.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.PopulatePropertyMapTableRows(System.Collections.Generic.List{Microsoft.Cci.PeWriter.PropertyMapRow})">
            <summary>
            Populate PropertyMap table.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.PopulateEncLogTableRows(System.Collections.Generic.List{Microsoft.Cci.PeWriter.EncLogRow})">
            <summary>
            Populate EncLog table.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.PopulateEncMapTableRows(System.Collections.Generic.List{Microsoft.Cci.PeWriter.EncMapRow})">
            <summary>
            Populate EncMap table.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.PeWriter.StringIdx">
            <summary>
            Wraps a virtual string table index.
            An override to SerializeIndex does the resolving at the right time.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.FoldStrings">
            <summary>
            Fills in stringIndexMap with data from stringIndex and write to stringWriter.
            Releases stringIndex as the stringTable is sealed after this point.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.PeWriter.SuffixSort">
            <summary>
            Sorts strings such that a string is followed immediately by all strings
            that are a suffix of it.  
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.WriteDeterministicGuidAndTimestamps(System.IO.Stream,System.Int64,System.Int64,System.Int64)">
            <summary>
            Compute a deterministic Guid and timestamp based on the contents of the stream, and replace
            the 16 zero bytes at the given position and one or two 4-byte values with that computed Guid and timestamp.
            </summary>
            <param name="stream">Stream of data</param>
            <param name="positionOfModuleVersionId">Position in the stream of 16 zero bytes to be replaced by a Guid</param>
            <param name="positionOfHeaderTimestamp">Position in the stream of four zero bytes to be replaced by a timestamp</param>
            <param name="positionOfDebugTableTimestamp">Position in the stream of four zero bytes to be replaced by a timestamp, or 0 if there is no second timestamp to be replaced</param>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.ComputeSerializedGuidFromData(System.IO.Stream,System.Byte[]@)">
            <summary>
            Compute a random-looking but deterministic Guid from a hash of the stream's data, and produce a "timestamp" from the remaining bits.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetDefiningUnitReference(Microsoft.Cci.ITypeReference,Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Returns a reference to the unit that defines the given referenced type. If the referenced type is a structural type, such as a pointer or a generic type instance,
            then the result is null.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.GetStringIndexForNamespaceAndCheckLength(Microsoft.Cci.INamespaceTypeReference,System.String)">
            <summary>
            The Microsoft CLR requires that {namespace} + "." + {name} fit in MAX_CLASS_NAME 
            (even though the name and namespace are stored separately in the Microsoft
            implementation).  Note that the namespace name of a nested type is always blank
            (since comes from the container).
            </summary>
            <param name="namespaceType">We're trying to add the containing namespace of this type to the string heap.</param>
            <param name="mangledTypeName">Namespace names are never used on their own - this is the type that is adding the namespace name.
            Used only for length checking.</param>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.IsTooLongInternal(System.String,System.Int32)">
            <summary>
            Test the given name to see if it fits in metadata.
            </summary>
            <param name="str">String to test (non-null).</param>
            <param name="maxLength">Max length for name.  (Expected to be at least 5.)</param>
            <returns>True if the name is too long.</returns>
            <remarks>Internal for test purposes.</remarks>
        </member>
        <member name="T:Microsoft.Cci.PeWriter.AssemblyReferenceComparer">
            <summary>
            Compares quality of assembly references to achieve unique rows in AssemblyRef table.
            Metadata spec: "The AssemblyRef table shall contain no duplicates (where duplicate rows are deemd to 
            be those having the same MajorVersion, MinorVersion, BuildNumber, RevisionNumber, PublicKeyOrToken, 
            Name, and Culture)".
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.UnwrapTypeReference(Microsoft.Cci.ITypeReference)">
            <summary>
            Strip off *, &amp;, and [].
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.StrongName(Microsoft.Cci.IAssemblyReference)">
            <summary>
            Computes the string representing the strong name of the given assembly reference.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.NoPiaReferenceIndexer">
            <summary>
            Visitor to force translation of all symbols that will be referred to
            in metadata. Allows us to build the set of types that must be embedded
            as local types.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.RootModuleType">
            <summary>
            Special type &lt;Module&gt;
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ITypeExport">
            <summary>
            Represents an exported type.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeExport.ExportedType">
            <summary>
            Type reference of the exported type.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IArrayTypeReference">
            <summary>
            This interface models the metadata representation of an array type reference.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IArrayTypeReference.GetElementType(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The type of the elements of this array.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IArrayTypeReference.IsVector">
            <summary>
            This type of array is a single dimensional array with zero lower bound for index values.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IArrayTypeReference.LowerBounds">
            <summary>
            A possibly empty list of lower bounds for dimension indices. When not explicitly specified, a lower bound defaults to zero.
            The first lower bound in the list corresponds to the first dimension. Dimensions cannot be skipped.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IArrayTypeReference.Rank">
            <summary>
            The number of array dimensions.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IArrayTypeReference.Sizes">
            <summary>
            A possible empty list of upper bounds for dimension indices.
            The first upper bound in the list corresponds to the first dimension. Dimensions cannot be skipped.
            An unspecified upper bound means that instances of this type can have an arbitrary upper bound for that dimension.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ICustomModifier">
            <summary>
            Modifies the set of allowed values for a type, or the semantics of operations allowed on those values. 
            Custom modifiers are not associated directly with types, but rather with typed storage locations for values.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ICustomModifier.IsOptional">
            <summary>
            If true, a language may use the modified storage location without being aware of the meaning of the modification.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ICustomModifier.GetModifier(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            A type used as a tag that indicates which type of modification applies to the storage location.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IParameterTypeInformation">
            <summary>
            Information that describes a method or property parameter, but does not include all the information in a IParameterDefinition.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterTypeInformation.CustomModifiers">
            <summary>
            The list of custom modifiers, if any, associated with the parameter. Evaluate this property only if IsModified is true.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterTypeInformation.IsByReference">
            <summary>
            True if the parameter is passed by reference (using a managed pointer).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterTypeInformation.HasByRefBeforeCustomModifiers">
            <summary>
            The CLI spec says that custom modifiers must precede the ByRef type code in the encoding of a parameter.
            Unfortunately, the managed C++ compiler emits them in the reverse order.  In order to avoid breaking
            interop scenarios, we need to support such signatures.  When this flag is set, we need to reverse the
            emit order.
            </summary>
            <remarks>
            We support before (correct) and after (incorrect, but works), but not in between.
            </remarks>
        </member>
        <member name="M:Microsoft.Cci.IParameterTypeInformation.GetType(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The type of argument value that corresponds to this parameter.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IFunctionPointerTypeReference">
            <summary>
            This interface models the metadata representation of a function pointer type reference.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFunctionPointerTypeReference.ExtraArgumentTypes">
            <summary>
            The types and modifiers of extra arguments that the caller will pass to the methods that are pointed to by this pointer.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGenericParameter">
            <summary>
            The definition of a type parameter of a generic type or method.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IGenericParameter.GetConstraints(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            A list of classes or interfaces. All type arguments matching this parameter must be derived from all of the classes and implement all of the interfaces.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGenericParameter.MustBeReferenceType">
            <summary>
            True if all type arguments matching this parameter are constrained to be reference types.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGenericParameter.MustBeValueType">
            <summary>
            True if all type arguments matching this parameter are constrained to be value types.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGenericParameter.MustHaveDefaultConstructor">
            <summary>
            True if all type arguments matching this parameter are constrained to be value types or concrete classes with visible default constructors.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGenericParameter.Variance">
            <summary>
            Indicates if the generic type or method with this type parameter is co-, contra-, or non variant with respect to this type parameter.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGenericParameterReference">
            <summary>
            A reference to the definition of a type parameter of a generic type or method.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGenericMethodParameter">
            <summary>
            The definition of a type parameter of a generic method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGenericMethodParameter.DefiningMethod">
            <summary>
            The generic method that defines this type parameter.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGenericMethodParameterReference">
            <summary>
            A reference to a type parameter of a generic method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGenericMethodParameterReference.DefiningMethod">
            <summary>
            A reference to the generic method that defines the referenced type parameter.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGenericTypeInstanceReference">
            <summary>
            A generic type instantiated with a list of type arguments
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IGenericTypeInstanceReference.GetGenericArguments(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The type arguments that were used to instantiate this.GenericType in order to create this type.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGenericTypeInstanceReference.GenericType">
            <summary>
            Returns the generic type of which this type is an instance.
            Equivalent to Symbol.OriginalDefinition
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGenericTypeParameter">
            <summary>
            The definition of a type parameter of a generic type.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGenericTypeParameter.DefiningType">
            <summary>
            The generic type that defines this type parameter.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGenericTypeParameterReference">
            <summary>
            A reference to a type parameter of a generic type.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGenericTypeParameterReference.DefiningType">
            <summary>
            A reference to the generic type that defines the referenced type parameter.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.INamedTypeReference">
            <summary>
            A reference to a named type, such as an INamespaceTypeReference or an INestedTypeReference.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.INamedTypeReference.GenericParameterCount">
            <summary>
            The number of generic parameters. Zero if the type is not generic.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.INamedTypeReference.MangleName">
            <summary>
            If true, the persisted type name is mangled by appending "`n" where n is the number of type parameters, if the number of type parameters is greater than 0.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.INamedTypeDefinition">
            <summary>
            A named type definition, such as an INamespaceTypeDefinition or an INestedTypeDefinition.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.INamespaceTypeDefinition">
            <summary>
            A type definition that is a member of a namespace definition.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.INamespaceTypeDefinition.IsPublic">
            <summary>
            True if the type can be accessed from other assemblies.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.INamespaceTypeReference">
            <summary>
            A reference to a type definition that is a member of a namespace definition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.INamespaceTypeReference.GetUnit(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            A reference to the unit that defines the referenced type.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.INamespaceTypeReference.NamespaceName">
            <summary>
            Fully qualified name of the containing namespace.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.INestedTypeDefinition">
            <summary>
            A type definition that is a member of another type definition.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.INestedTypeReference">
            <summary>
            A type definition that is a member of another type definition.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ISpecializedNestedTypeReference">
            <summary>
            A reference to a type definition that is a specialized nested type.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISpecializedNestedTypeReference.UnspecializedVersion">
            <summary>
            A reference to the nested type that has been specialized to obtain this nested type reference. When the containing type is an instance of type which is itself a specialized member (i.e. it is a nested
            type of a generic type instance), then the unspecialized member refers to a member from the unspecialized containing type. (I.e. the unspecialized member always
            corresponds to a definition that is not obtained via specialization.)
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IMethodImplementation">
            <summary>
            Models an explicit implemenation or override of a base class virtual method or an explicit implementation of an interface method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodImplementation.ContainingType">
            <summary>
            The type that is explicitly implementing or overriding the base class virtual method or explicitly implementing an interface method.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMethodImplementation.Dispatch(Microsoft.Cci.MetadataVisitor)">
            <summary>
            Calls the visitor.Visit(T) method where T is the most derived object model node interface type implemented by the concrete type
            of the object implementing IDefinition. The dispatch method does not invoke Dispatch on any child objects. If child traversal
            is desired, the implementations of the Visit methods should do the subsequent dispatching.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodImplementation.ImplementedMethod">
            <summary>
            A reference to the method whose implementation is being provided or overridden.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodImplementation.ImplementingMethod">
            <summary>
            A reference to the method that provides the implementation.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IModifiedTypeReference">
            <summary>
            A type reference that has custom modifiers associated with it. For example a reference to the target type of a managed pointer to a constant.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModifiedTypeReference.CustomModifiers">
            <summary>
            Returns the list of custom modifiers associated with the type reference. Evaluate this property only if IsModified is true.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModifiedTypeReference.UnmodifiedType">
            <summary>
            An unmodified type reference.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IPointerTypeReference">
            <summary>
            This interface models the metadata representation of a pointer to a location in unmanaged memory.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IPointerTypeReference.GetTargetType(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The type of value stored at the target memory location.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IManagedPointerTypeReference">
            <summary>
            This interface models the metadata representation of a managed pointer.
            Remark: This should be only used in attributes. For other objects like Local variables etc
            there is explicit IsReference field that should be used.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IManagedPointerTypeReference.GetTargetType(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The type of value stored at the target memory location.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ITypeDefinition">
            <summary>
            This interface models the metadata representation of a type.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.Alignment">
            <summary>
            The byte alignment that values of the given type ought to have. Must be a power of 2. If zero, the alignment is decided at runtime.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeDefinition.GetBaseClass(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Returns null for interfaces and System.Object.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.Events">
            <summary>
            Zero or more events defined by this type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeDefinition.GetExplicitImplementationOverrides(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Zero or more implementation overrides provided by the class.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeDefinition.GetFields(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Zero or more fields defined by this type.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.GenericParameters">
            <summary>
            Zero or more parameters that can be used as type annotations.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.GenericParameterCount">
            <summary>
            The number of generic parameters. Zero if the type is not generic.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.HasDeclarativeSecurity">
            <summary>
            True if this type has a non empty collection of SecurityAttributes or the System.Security.SuppressUnmanagedCodeSecurityAttribute.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeDefinition.Interfaces(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Zero or more interfaces implemented by this type.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsAbstract">
            <summary>
            True if the type may not be instantiated.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsBeforeFieldInit">
            <summary>
            Is type initialized anytime before first access to static field
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsComObject">
            <summary>
            Is this imported from COM type library
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsGeneric">
            <summary>
            True if this type is parameterized (this.GenericParameters is a non empty collection).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsInterface">
            <summary>
            True if the type is an interface.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsRuntimeSpecial">
            <summary>
            True if this type gets special treatment from the runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsSerializable">
            <summary>
            True if this type is serializable.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsSpecialName">
            <summary>
            True if the type has special name.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsWindowsRuntimeImport">
            <summary>
            True if the type is a Windows runtime type.
            </summary>
            <remarks>
            A type can me marked as a Windows runtime type in source by applying the WindowsRuntimeImportAttribute.
            WindowsRuntimeImportAttribute is a pseudo custom attribute defined as an internal class in System.Runtime.InteropServices.WindowsRuntime namespace.
            This is needed to mark Windows runtime types which are redefined in mscorlib.dll and System.Runtime.WindowsRuntime.dll.
            These two assemblies are special as they implement the CLR's support for WinRT.
            </remarks>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsSealed">
            <summary>
            True if the type may not be subtyped.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.Layout">
            <summary>
            Layout of the type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeDefinition.GetMethods(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Zero or more methods defined by this type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeDefinition.GetNestedTypes(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Zero or more nested types defined by this type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeDefinition.GetProperties(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Zero or more properties defined by this type.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.SecurityAttributes">
            <summary>
            Declarative security actions for this type. Will be empty if this.HasSecurity is false.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.SizeOf">
            <summary>
            Size of an object of this type. In bytes. If zero, the size is unspecified and will be determined at runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.StringFormat">
            <summary>
            Default marshalling of the Strings in this class.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ITypeReference">
            <summary>
            A reference to a type.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeReference.IsEnum">
            <summary>
            True if the type is an enumeration (it extends System.Enum and is sealed). Corresponds to C# enum.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeReference.IsValueType">
            <summary>
            True if the type is a value type. 
            Value types are sealed and extend System.ValueType or System.Enum.
            A type parameter for which MustBeValueType (the struct constraint in C#) is true also returns true for this property.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeReference.GetResolvedType(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The type definition being referred to.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeReference.TypeCode(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Unless the value of TypeCode is PrimitiveTypeCode.NotPrimitive, the type corresponds to a "primitive" CLR type (such as System.Int32) and
            the type code identifies which of the primitive types it corresponds to.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeReference.TypeDef">
            <summary>
            TypeDefs defined in modules linked to the assembly being emitted are listed in the ExportedTypes table.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.PrimitiveTypeCode">
            <summary>
            A enumeration of all of the value types that are built into the Runtime (and thus have specialized IL instructions that manipulate them).
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Boolean">
            <summary>
            A single bit.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Char">
            <summary>
            An usigned 16 bit integer representing a Unicode UTF16 code point.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Int8">
            <summary>
            A signed 8 bit integer.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Float32">
            <summary>
            A 32 bit IEEE floating point number.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Float64">
            <summary>
            A 64 bit IEEE floating point number.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Int16">
            <summary>
            A signed 16 bit integer.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Int32">
            <summary>
            A signed 32 bit integer.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Int64">
            <summary>
            A signed 64 bit integer.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.IntPtr">
            <summary>
            A signed 32 bit integer or 64 bit integer, depending on the native word size of the underlying processor.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Pointer">
            <summary>
            A pointer to fixed or unmanaged memory.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Reference">
            <summary>
            A reference to managed memory.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.String">
            <summary>
            A string.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.UInt8">
            <summary>
            An unsigned 8 bit integer.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.UInt16">
            <summary>
            An unsigned 16 bit integer.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.UInt32">
            <summary>
            An unsigned 32 bit integer.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.UInt64">
            <summary>
            An unsigned 64 bit integer.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.UIntPtr">
            <summary>
            An unsigned 32 bit integer or 64 bit integer, depending on the native word size of the underlying processor.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Void">
            <summary>
            A type that denotes the absense of a value.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.NotPrimitive">
            <summary>
            Not a primitive type.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Invalid">
            <summary>
            Type is a dummy type.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.TypeMemberVisibility">
            <summary>
            Enumerates the different kinds of levels of visibility a type member can have.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeMemberVisibility.Default">
            <summary>
            The visibility has not been specified. Use the applicable default.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeMemberVisibility.Assembly">
            <summary>
            The member is visible only within its own assembly.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeMemberVisibility.Family">
            <summary>
            The member is visible only within its own type and any subtypes.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeMemberVisibility.FamilyAndAssembly">
            <summary>
            The member is visible only within the intersection of its family (its own type and any subtypes) and assembly. 
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeMemberVisibility.FamilyOrAssembly">
            <summary>
            The member is visible only within the union of its family and assembly. 
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeMemberVisibility.Other">
            <summary>
            The member is visible only to the compiler producing its assembly.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeMemberVisibility.Private">
            <summary>
            The member is visible only within its own type.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeMemberVisibility.Public">
            <summary>
            The member is visible everywhere its declaring type is visible.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeMemberVisibility.Mask">
            <summary>
            A mask that can be used to mask out flag bits when the latter are stored in the same memory word as this enumeration.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.TypeParameterVariance">
            <summary>
            Enumerates the different kinds of variance a generic method or generic type parameter may have.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeParameterVariance.NonVariant">
            <summary>
            Two type or method instances are compatible only if they have exactly the same type argument for this parameter.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeParameterVariance.Covariant">
            <summary>
            A type or method instance will match another instance if it has a type for this parameter that is the same or a subtype of the type the
            other instance has for this parameter.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeParameterVariance.Contravariant">
            <summary>
            A type or method instance will match another instance if it has a type for this parameter that is the same or a supertype of the type the
            other instance has for this parameter.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeParameterVariance.Mask">
            <summary>
            A mask that can be used to mask out flag bits when the latter are stored in the same memory word as the enumeration.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.Machine">
            <summary>
            Target CPU types.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Machine.Unknown">
            <summary>
            The target CPU is unknown or not specified.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Machine.I386">
            <summary>
            Intel 386.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Machine.ARMThumb2">
            <summary>
            ARM Thumb-2 little-endian.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Machine.IA64">
            <summary>
            Intel 64
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Machine.AMD64">
            <summary>
            AMD64 (K8)
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ModuleKind">
            <summary>
            The kind of metadata stored in the module. For example whether the module is an executable or a manifest resource file.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ModuleKind.ConsoleApplication">
            <summary>
            The module is an executable with an entry point and has a console.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ModuleKind.WindowsApplication">
            <summary>
            The module is an executable with an entry point and does not have a console.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ModuleKind.DynamicallyLinkedLibrary">
            <summary>
            The module is a library of executable code that is dynamically linked into an application and called via the application.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ModuleKind.WindowsRuntimeMetadata">
            <summary>
            The module is a .winmdobj file.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ModuleKind.ManifestResourceFile">
            <summary>
            The module contains no executable code. Its contents is a resource stream for the modules that reference it.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ModuleKind.UnmanagedDynamicallyLinkedLibrary">
            <summary>
            The module is a library of executable code but contains no .NET metadata and is specific to a processor instruction set.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IAssembly">
            <summary>
            Represents a .NET assembly.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IAssembly.GetFiles(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            A list of the files that constitute the assembly. These are not the source language files that may have been
            used to compile the assembly, but the files that contain constituent modules of a multi-module assembly as well
            as any external resources. It corresonds to the File table of the .NET assembly file format.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IAssembly.Flags">
            <summary>
            A set of bits and bit ranges representing properties of the assembly. The value of <see cref="P:Microsoft.Cci.IAssembly.Flags"/> can be set
            from source code via the AssemblyFlags assembly custom attribute. The interpretation of the property depends on the target platform.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IAssembly.PublicKey">
            <summary>
            The public part of the key used to encrypt the SHA1 hash over the persisted form of this assembly. Empty or null if not specified.
            This value is used by the loader to decrypt an encrypted hash value stored in the assembly, which it then compares with a freshly computed hash value
            in order to verify the integrity of the assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IAssembly.SignatureKey">
            <summary>
            The contents of the AssemblySignatureKeyAttribute
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IAssemblyReference">
            <summary>
            A reference to a .NET assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IAssemblyReference.Culture">
            <summary>
            Identifies the culture associated with the assembly reference. Typically specified for sattelite assemblies with localized resources.
            Empty or null if not specified.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IAssemblyReference.IsRetargetable">
            <summary>
            True if the implementation of the referenced assembly used at runtime is not expected to match the version seen at compile time.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IAssemblyReference.ContentType">
            <summary>
            Type of code contained in an assembly. Determines assembly binding model.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IAssemblyReference.PublicKeyToken">
            <summary>
            The hashed 8 bytes of the public key of the referenced assembly. This is empty or null if the referenced assembly does not have a public key.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IAssemblyReference.Version">
            <summary>
            The version of the assembly reference. Null means Version(0, 0, 0, 0).
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IModule">
            <summary>
            An object that represents a .NET module.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IModule.GetExportedTypes(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Public types defined in other modules making up this assembly and to which other assemblies may refer to via this assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.AssemblyAttributes">
            <summary>
            A list of objects representing persisted instances of types that extend System.Attribute. Provides an extensible way to associate metadata
            with this assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.AssemblySecurityAttributes">
            <summary>
            A list of objects representing persisted instances of pairs of security actions and sets of security permissions.
            These apply by default to every method reachable from the module.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IModule.GetAssemblyReferences(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            A list of the assemblies that are referenced by this module.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IModule.GetResources(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            A list of named byte sequences persisted with the assembly and used during execution, typically via .NET Framework helper classes.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IModule.GetCorLibrary(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            CorLibrary assembly referenced by this module.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.BaseAddress">
            <summary>
            The preferred memory address at which the module is to be loaded at runtime.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IModule.GetContainingAssembly(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The Assembly that contains this module. If this module is main module then this returns this.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.DllCharacteristics">
            <summary>
            Flags that control the behavior of the target operating system. CLI implementations are supposed to ignore this, but some operating system pay attention.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.EntryPoint">
            <summary>
            The method that will be called to start execution of this executable module. 
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.FileAlignment">
            <summary>
            The alignment of sections in the module's image file.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IModule.GetStrings">
            <summary>
            Returns zero or more strings used in the module. If the module is produced by reading in a CLR PE file, then this will be the contents
            of the user string heap. If the module is produced some other way, the method may return an empty enumeration or an enumeration that is a
            subset of the strings actually used in the module. The main purpose of this method is to provide a way to control the order of strings in a
            prefix of the user string heap when writing out a module as a PE file.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IModule.GetTopLevelTypes(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Returns all top-level (not nested) types defined in the current module. 
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.ILOnly">
            <summary>
            True if the module contains only IL and is processor independent.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.Kind">
            <summary>
            The kind of metadata stored in this module. For example whether this module is an executable or a manifest resource file.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.LinkerMajorVersion">
            <summary>
            The first part of a two part version number indicating the version of the linker that produced this module. For example, the 8 in 8.0.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.LinkerMinorVersion">
            <summary>
            The first part of a two part version number indicating the version of the linker that produced this module. For example, the 0 in 8.0.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.Machine">
            <summary>
            Specifies the target CPU. 
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.MetadataFormatMajorVersion">
            <summary>
            The first part of a two part version number indicating the version of the format used to persist this module. For example, the 1 in 1.0.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.MetadataFormatMinorVersion">
            <summary>
            The second part of a two part version number indicating the version of the format used to persist this module. For example, the 0 in 1.0.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.ModuleAttributes">
            <summary>
            A list of objects representing persisted instances of types that extend System.Attribute. Provides an extensible way to associate metadata
            with this module.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.ModuleName">
            <summary>
            The name of the module.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.ModuleReferences">
            <summary>
            A list of the modules that are referenced by this module.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.PersistentIdentifier">
            <summary>
            A globally unique persistent identifier for this module.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.RequiresAmdInstructionSet">
            <summary>
            If set, the module contains instructions or assumptions that are specific to the AMD 64 bit instruction set. Setting this flag to
            true also sets Requires64bits to true.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.RequiresStartupStub">
            <summary>
            If set, the module must include a machine code stub that transfers control to the virtual execution system.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.Requires32bits">
            <summary>
            If set, the module contains instructions that assume a 32 bit instruction set. For example it may depend on an address being 32 bits.
            This may be true even if the module contains only IL instructions because of PlatformInvoke and COM interop.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.Prefers32bits">
            <summary>
            True if the module contains only IL and is processor independent. Should there be a choice between launching as a 64-bit or 32-bit
            process, this setting will cause the host to launch it as a 32-bit process. 
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.Requires64bits">
            <summary>
            If set, the module contains instructions that assume a 64 bit instruction set. For example it may depend on an address being 64 bits.
            This may be true even if the module contains only IL instructions because of PlatformInvoke and COM interop.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.SizeOfHeapCommit">
            <summary>
            The size of the virtual memory initially committed for the initial process heap.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.SizeOfHeapReserve">
            <summary>
            The size of the virtual memory to reserve for the initial process heap.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.SizeOfStackCommit">
            <summary>
            The size of the virtual memory initially committed for the initial thread's stack.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.SizeOfStackReserve">
            <summary>
            The size of the virtual memory to reserve for the initial thread's stack.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.TargetRuntimeVersion">
            <summary>
            Identifies the version of the CLR that is required to load this module or assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.TrackDebugData">
            <summary>
            True if the instructions in this module must be compiled in such a way that the debugging experience is not compromised.
            To set the value of this property, add an instance of System.Diagnostics.DebuggableAttribute to the MetadataAttributes list.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.Win32Resources">
            <summary>
            A list of named byte sequences persisted with the module and used during execution, typically via the Win32 API.
            A module will define Win32 resources rather than "managed" resources mainly to present metadata to legacy tools
            and not typically use the data in its own code. 
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.Win32ResourceSection">
            <summary>
            An alternate form the Win32 resources may take. These represent the rsrc$01 and rsrc$02 section data and relocs
            from a COFF object file.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IModule.GetSymbolToLocationMap">
            <summary>
            Builds symbol definition to location map used for emitting token -> location info
            into PDB to be consumed by WinMdExp.exe tool (only applicable for /t:winmdobj)
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IModuleReference">
            <summary>
            A reference to a .NET module.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IModuleReference.GetContainingAssembly(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The Assembly that contains this module. May be null if the module is not part of an assembly.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IUnit">
            <summary>
            A unit of metadata stored as a single artifact and potentially produced and revised independently from other units.
            Examples of units include .NET assemblies and modules, as well C++ object files and compiled headers.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IUnitReference">
            <summary>
            A reference to a instance of <see cref="T:Microsoft.Cci.IUnit"/>.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.UsedNamespaceOrType">
            <summary>
            This represents a single using directive (in the scope of a method body).
            It has a name and possibly an alias.
            </summary>
            <remarks>
            A namespace that is used (imported) inside a namespace scope.
            
            Kind            | Example                   | Alias     | TargetName
            ----------------+---------------------------+-----------+-------------------
            Namespace       | using System;             | null      | "System"
            NamespaceAlias  | using S = System;         | "S"       | "System"
            ExternNamespace | extern alias LibV1;       | "LibV1"   | null
            TypeAlias       | using C = System.Console; | "C"       | "System.Console"
            </remarks>
        </member>
        <member name="M:Microsoft.Cci.UsedNamespaceOrType.CreateCSharpTypeAlias(System.String,System.String)">
            <remarks>
            <paramref name="name"/> is an assembly-qualified name so the extern alias, if any, can be dropped.
            </remarks>
        </member>
        <member name="P:Microsoft.Cci.UsedNamespaceOrType.TargetName">
            <summary>
            The name of a namepace that has been aliased.  For example the "y.z" of "using x = y.z;" or "using y.z" in C#.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.UsedNamespaceOrType.Alias">
            <summary>
            An alias for a namespace. For example the "x" of "using x = y.z;" in C#. Empty if no alias is present.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.UsedNamespaceOrType.ExternAlias">
            <summary>
            The name of an extern alias that has been used to qualify a name.  For example the "Q" of "using x = Q::y.z;" or "using Q::y.z" in C#.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.UsedNamespaceOrType.ProjectLevel">
            <summary>
            Indicates whether the import was specified on a project level, or on file level (used for VB only)
            </summary>
        </member>
        <member name="P:Microsoft.Cci.UsedNamespaceOrType.Kind">
            <summary>
            Distinguishes the various kinds of targets.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UsedNamespaceOrType.Encode">
            <summary>
            Returns an encoded name for this used type or namespace. The encoding is dependent on the <see cref="T:Microsoft.Cci.UsedNamespaceOrTypeKind"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentDictionaryExtensions.Add``2(System.Collections.Concurrent.ConcurrentDictionary{``0,``1},``0,``1)">
            <summary>
            NOTE!!! adding duplicates will result in exceptions. 
            Being concurrent only allows accessing the dictionary without takind locks.
            Duplicate keys are still not allowed in the hashtable.
            If unsure about adding unique items use APIs such as TryAdd, GetOrAdd, etc...
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ConcurrentSet`1">
            <summary>
            A concurrent, simplified HashSet.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ConcurrentSet`1.DefaultConcurrencyLevel">
            <summary>
            The default concurrency level is 2. That means the collection can cope with up to two
            threads making simultaneous modifications without blocking.
            Note ConcurrentDictionary's default concurrency level is dynamic, scaling according to
            the number of processors.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ConcurrentSet`1.DefaultCapacity">
            <summary>
            Taken from ConcurrentDictionary.DEFAULT_CAPACITY
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ConcurrentSet`1.dictionary">
            <summary>
            The backing dictionary. The values are never used; just the keys.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.#ctor">
            <summary>
            Construct a concurrent set with the default concurrency level.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Construct a concurrent set using the specified equality comparer.
            </summary>
            <param name="equalityComparer">The equality comparer for values in the set.</param>
        </member>
        <member name="P:Roslyn.Utilities.ConcurrentSet`1.Count">
            <summary>
            Obtain the number of elements in the set.
            </summary>
            <returns>The number of elements in the set.</returns>
        </member>
        <member name="P:Roslyn.Utilities.ConcurrentSet`1.IsEmpty">
            <summary>
            Determine whether the set is empty.</summary>
            <returns>true if the set is empty; otherwise, false.</returns>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.Contains(`0)">
            <summary>
            Determine whether the given value is in the set.
            </summary>
            <param name="value">The value to test.</param>
            <returns>true if the set contains the specified value; otherwise, false.</returns>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.Add(`0)">
            <summary>
            Attempts to add a value to the set.
            </summary>
            <param name="value">The value to add.</param>
            <returns>true if the value was added to the set. If the value already exists, this method returns false.</returns>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.Remove(`0)">
            <summary>
            Attempts to remove a value from the set.
            </summary>
            <param name="value">The value to remove.</param>
            <returns>true if the value was removed successfully; otherwise false.</returns>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.GetEnumerator">
            <summary>
            Obtain an enumerator that iterates through the elements in the set.
            </summary>
            <returns>An enumerator for the set.</returns>
        </member>
        <member name="T:Roslyn.Utilities.ConsList`1">
            <summary>
            a simple Lisp-like immutable list.  Good to use when lists are always accessed from the head.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.DebuggerUtilities.CallBeforeAcquiringLock">
            <summary>
            The issue here is acquiring a lock in the course of evaluating a property
            value in the debugger (e.g. in the Locals window).  If anything causes that
            evaluation to bail, it will do so without releasing the lock, making future
            evaluations impossible (leads to a timeout, among other things).  One thing
            that might cause the evaluation to bail is a call to 
            Debugger.NotifyOfCrossThreadDependency, which causes the debugger to prompt
            the user for confirmation (little swirling red and blue icon) before evaluating
            an expression that will involve multiple threads.  To prevent this from happening
            we make the call ourselved *before* acquiring the lock.  Then, when the user
            opts to proceed, the evaluation runs without interruption and succeeds.
            </summary>
            <remarks>
            TODO: This probably isn't necessary in Dev11 (see Dev11 548767 and/or Dev11 84313).
            </remarks>
        </member>
        <member name="T:Roslyn.Utilities.DocumentationCommentXmlNames">
            <summary>
            Names of well-known XML attributes and elements.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(``0[])">
            <remarks>
            This method is necessary to avoid an ambiguity between <see cref="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.IReadOnlyCollection{``0})"/> and <see cref="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.ICollection{``0})"/>.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.List{``0})">
            <remarks>
            This method is necessary to avoid an ambiguity between <see cref="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.IReadOnlyCollection{``0})"/> and <see cref="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.ICollection{``0})"/>.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.EnumUtilities.ConvertEnumUnderlyingTypeToUInt64(System.Object,Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Convert a boxed primitive (generally of the backing type of an enum) into a ulong.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.Hash.Combine(System.Int32,System.Int32)">
            <summary>
            This is how VB Anonymous Types combine hash values for fields.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Hash.Combine``1(``0,System.Int32)">
            <summary>
            This is how VB Anonymous Types combine hash values for fields.
            PERF: Do not use with enum types because that involves multiple
            unnecessary boxing operations.  Unfortunately, we can't constrain
            T to "non-enum", so we'll use a more restrictive constraint.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.Hash.FnvOffsetBias">
            <summary>
            The offset bias value used in the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.Hash.FnvPrime">
            <summary>
            The generative factor used in the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Byte[])">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.String,System.Int32,System.Int32)">
            <summary>
            Compute the hashcode of a sub-string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            Note: FNV-1a was developed and tuned for 8-bit sequences. We're using it here
            for 16-bit Unicode chars on the understanding that the majority of chars will
            fit into 8-bits and, therefore, the algorithm will retain its desirable traits
            for generating hash codes.
            </summary>
            <param name="text">The input string</param>
            <param name="start">The start index of the first character to hash</param>
            <param name="length">The number of characters, beginning with <paramref name="start"/> to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending after <paramref name="length"/> characters.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.String,System.Int32)">
            <summary>
            Compute the hashcode of a sub-string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <param name="start">The start index of the first character to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending at the end of the string.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.String)">
            <summary>
            Compute the hashcode of a string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <returns>The FNV-1a hash code of <paramref name="text"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Text.StringBuilder)">
            <summary>
            Compute the hashcode of a string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <returns>The FNV-1a hash code of <paramref name="text"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Char[],System.Int32,System.Int32)">
            <summary>
            Compute the hashcode of a sub string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string as a char array</param>
            <param name="start">The start index of the first character to hash</param>
            <param name="length">The number of characters, beginning with <paramref name="start"/> to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending after <paramref name="length"/> characters.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Char)">
            <summary>
            Compute the hashcode of a single character using the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            Note: In general, this isn't any more useful than "char.GetHashCode". However,
            it may be needed if you need to generate the same hash code as a string or
            substring with just a single character.
            </summary>
            <param name="ch">The character to hash</param>
            <returns>The FNV-1a hash code of the character.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.CombineFNVHash(System.Int32,System.String)">
            <summary>
            Combine a string with an existing FNV-1a hash code
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="hashCode">The accumulated hash code</param>
            <param name="text">The string to combine</param>
            <returns>The result of combining <paramref name="hashCode"/> with <paramref name="text"/> using the FNV-1a algorithm</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.CombineFNVHash(System.Int32,System.Char)">
            <summary>
            Combine a char with an existing FNV-1a hash code
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="hashCode">The accumulated hash code</param>
            <param name="ch">The new character to combine</param>
            <returns>The result of combining <paramref name="hashCode"/> with <paramref name="ch"/> using the FNV-1a algorithm</returns>
        </member>
        <member name="T:Roslyn.Utilities.ObjectPool`1">
            <summary>
            Generic implementation of object pooling pattern with predefined pool size limit. The main
            purpose is that limited number of frequently used objects can be kept in the pool for
            further recycling.
            
            Notes: 
            1) it is not the goal to keep all returned objects. Pool is not meant for storage. If there
               is no space in the pool, extra returned objects will be dropped.
            
            2) it is implied that if object was obtained from a pool, the caller will return it back in
               a relatively short time. Keeping checked out objects for long durations is ok, but 
               reduces usefulness of pooling. Just new up your own.
            
            Not returning objects to the pool in not detrimental to the pool's work, but is a bad practice. 
            Rationale: 
               If there is no intent for reusing the object, do not use pool - just use "new". 
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ObjectPool`1.Factory">
            <remarks>
            Not using <see cref="T:System.Func{T}"/> because this file is linked into the (debugger) Formatter,
            which does not have that type (since it compiles against .NET 2.0).
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.ObjectPool`1.Allocate">
            <summary>
            Produces an instance.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.ObjectPool`1.Free(`0)">
            <summary>
            Returns objects to the pool.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search in Allocate.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.ObjectPool`1.ForgetTrackedObject(`0,`0)">
            <summary>
            Removes an object from leak tracking.  
            
            This is called when an object is returned to the pool.  It may also be explicitly 
            called if an object allocated from the pool is intentionally not being returned
            to the pool.  This can be of use with pooled arrays if the consumer wants to 
            return a larger array to the pool than was originally allocated.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.OneOrMany`1">
            <summary>
            Represents a single item or many items. 
            </summary>
            <remarks>
            Used when a collection usually contains a single item but sometimes might contain multiple.
            </remarks>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.Empty">
            <summary>
            Null or empty.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.Relative">
            <summary>
            "file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToCurrentDirectory">
            <summary>
            ".\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToCurrentParent">
            <summary>
            "..\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToCurrentRoot">
            <summary>
            "\dir\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToDriveDirectory">
            <summary>
            "C:dir\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.Absolute">
            <summary>
            "C:\file" or "\\machine" (UNC).
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.RemoveTrailingSpacesAndDots(System.String)">
            <summary>
            Trims all '.' and whitespaces from the end of the path
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IndexOfExtension(System.String)">
            <summary>
            Returns the offset in <paramref name="path"/> where the dot that starts an extension is, or -1 if the path doesn't have an extension.
            </summary>
            <remarks>
            Returns 0 for path ".foo".
            Returns -1 for path "foo.".
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetExtension(System.String)">
            <summary>
            Returns an extension of the specified path string.
            </summary>
            <remarks>
            The same functionality as <see cref="M:System.IO.Path.GetExtension(string)"/> but doesn't throw an exception
            if there are invalid characters in the path.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.RemoveExtension(System.String)">
            <summary>
            Removes extension from path.
            </summary>
            <remarks>
            Returns "foo" for path "foo.".
            Returns "foo.." for path "foo...".
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.ChangeExtension(System.String,System.String)">
            <summary>
            Returns path with the extenion changed to <paramref name="extension"/>.
            </summary>
            <returns>
            Equivalent of <see cref="M:System.IO.Path.ChangeExtension"/>
            
            If <paramref name="path"/> is null, returns null. 
            If path does not end with an extension, the new extension is appended to the path.
            If extension is null, equivalent to <see cref="M:Roslyn.Utilities.PathUtilities.RemoveExtension(System.String)"/>.
            </returns>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IndexOfFileName(System.String)">
            <summary>
            Returns the position in given path where the file name starts.
            </summary>
            <returns>-1 if path is null.</returns>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsFileName(System.String)">
            <summary>
            Returns true if the string represents an unqualified file name.
            </summary>
            <param name="path">Path.</param>
            <returns>True if <paramref name="path"/> is a simple file name, false if it is null or includes a directory specification.</returns>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetFileName(System.String)">
            <summary>
            Get file name from path.
            </summary>
            <remarks>Unlike <see cref="M:System.IO.Path.GetFileName"/> doesn't check for invalid path characters.</remarks>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetDirectoryName(System.String)">
            <summary>
            Get directory name from path.
            </summary>
            <remarks>
            Unlike <see cref="M:System.IO.Path.GetDirectoryName"/> it
                doesn't check for invalid path characters, 
                doesn't strip any trailing directory separators (TODO: tomat),
                doesn't recognize UNC structure \\computer-name\share\directory-name\file-name (TODO: tomat).
            </remarks>
            <returns>Prefix of path that represents a directory. </returns>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsDriveRootedAbsolutePath(System.String)">
            <summary>
            Returns true if given path is absolute and starts with a drive specification ("C:\").
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetPathRoot(System.String)">
            <summary>
            Get a prefix of given path which is the root of the path.
            </summary>
            <returns>
            Root of an absolute path or null if the path isn't absolute or has invalid format (e.g. "\\").
            It may or may not end with a directory separator (e.g. "C:\", "C:\foo", "\\machine\share", etc.) .
            </returns>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetUncPathRootLength(System.String)">
            <summary>
            Calculates the length of root of an UNC path.
            </summary>
            <remarks>
            "\\server\share" is root of UNC path "\\server\share\dir1\dir2\file".
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.CombineAbsoluteAndRelativePaths(System.String,System.String)">
            <summary>
            Combines an absolute path with a relative.
            </summary>
            <param name="root">Absolute root path.</param>
            <param name="relativePath">Relative path.</param>
            <returns>
            An absolute combined path, or null if <paramref name="relativePath"/> is 
            absolute (e.g. "C:\abc", "\\machine\share\abc"), 
            relative to the current root (e.g. "\abc"), 
            or relative to a drive directory (e.g. "C:abc\def").
            </returns>
            <seealso cref="M:Roslyn.Utilities.PathUtilities.CombinePossiblyRelativeAndRelativePaths(System.String,System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.CombinePossiblyRelativeAndRelativePaths(System.String,System.String)">
            <summary>
            Combine two paths, the first of which may be absolute.
            </summary>
            <param name="rootOpt">First path: absolute, relative, or null.</param>
            <param name="relativePath">Second path: relative and non-null.</param>
            <returns>null, if <paramref name="rootOpt"/> is null; a combined path, otherwise.</returns>
            <seealso cref="M:Roslyn.Utilities.PathUtilities.CombineAbsoluteAndRelativePaths(System.String,System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsFilePath(System.String)">
            <summary>
            Determines whether an assembly reference is considered an assembly file path or an assembly name.
            used, for example, on values of /r and #r.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ReferenceEqualityComparer">
            <summary>
            Compares objects based upon their reference identity.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.StringExtensions.NeedsLocalization(System.String)">
            <summary>
            Used to indicate places where we are hard-coding strings that will later need to be
            localized.  This way, we can use a "Find All References" to find and fix these.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.StringExtensions.IsValidClrNamespaceName(System.String)">
            <summary>
            Checks if the given name is a sequence of valid CLR names separated by a dot.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.StringTable">
            <summary>
            This is basically a lossy cache of strings that is searchable by
            strings, string sub ranges, character array ranges or string-builder.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.WeakList`1">
            <summary>
            Represents an ordered sequence of weak references.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.WeakList`1.Compact(System.Int32,System.WeakReference{`0}[])">
            <summary>
            Copies all live references from <see cref="F:Roslyn.Utilities.WeakList`1.items"/> to <paramref name="result"/>.
            Assumes that all references prior <paramref name="firstDead"/> are alive.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.WeakList`1.WeakCount">
            <summary>
            Returns the number of weak references in this list. 
            Note that some of them might not point to live objects anymore.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.FileKey.FullPath">
            <summary>
            Full case-insensitive path.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.FileKey.Timestamp">
            <summary>
            Last write time (Utc).
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.FileKey.#ctor(System.String,System.DateTime)">
            <summary>
            Constructor.
            </summary>
            <param name="fullPath">Full path.</param>
            <param name="timestamp">Last write time (Utc).</param>
        </member>
        <member name="M:Roslyn.Utilities.FileKey.Create(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.ResolveRelativePath(System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.Func{System.String,System.Boolean})">
            <summary>
            Resolves relative path and returns absolute path.
            The method depends only on values of its parameters and their implementation (for fileExists).
            It doesn't itself depend on the state of the current process (namely on the current drive directories) or 
            the state of file system.
            </summary>
            <param name="path">
            Path to resolve.
            </param>
            <param name="basePath">
            Base file path to resolve CWD-relative paths against. Null if not available.
            </param>
            <param name="baseDirectory">
            Base directory to resolve CWD-relative paths against if <paramref name="basePath"/> isn't specified. 
            Must be absolute path.
            Null if not available.
            </param>
            <param name="searchPaths">
            Sequence of paths used to search for unqualified relative paths.
            </param>
            <param name="fileExists">
            Method that tests existence of a file.
            </param>
            <returns>
            The resolved path or null if the path can't be resolved.
            </returns>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.NormalizeAbsolutePath(System.String)">
            <summary>
            Normalizes an absolute path.
            </summary>
            <param name="path">Path to normalize.</param>
            <exception cref="T:System.IO.IOException"/>
            <returns>Normalized path.</returns>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.DeleteFileOnClose(System.String)">
            <summary>
            Marks given file for automatic deletion when all its handles are closed.
            Note that after doing this the file can't be opened again, not even by the same process.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.GetFileTimeStamp(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Roslyn.Utilities.FixedObjectBinder">
            <summary>
            A binder that used a predetermine list of types and reader functions.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ObjectReader">
            <summary>
            A class that reads both primitive values and non-cyclical object graphs from a stream that was constructed using 
            the ObjectWriter class.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadBoolean">
            <summary>
            Read a Boolean value from the stream. This value must have been written using <see cref="M:Roslyn.Utilities.ObjectWriter.WriteBoolean(System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadByte">
            <summary>
            Read a Byte value from the stream. This value must have been written using <see cref="M:Roslyn.Utilities.ObjectWriter.WriteByte(System.Byte)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadChar">
            <summary>
            Read a Char value from the stream. This value must have been written using <see cref="M:Roslyn.Utilities.ObjectWriter.WriteChar(System.Char)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadDecimal">
            <summary>
            Read a Decimal value from the stream. This value must have been written using <see cref="M:Roslyn.Utilities.ObjectWriter.WriteDecimal(System.Decimal)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadDouble">
            <summary>
            Read a Double value from the stream. This value must have been written using <see cref="M:Roslyn.Utilities.ObjectWriter.WriteDouble(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadSingle">
            <summary>
            Read a Single value from the stream. This value must have been written using <see cref="M:Roslyn.Utilities.ObjectWriter.WriteSingle(System.Single)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadInt32">
            <summary>
            Read a Int32 value from the stream. This value must have been written using <see cref="M:Roslyn.Utilities.ObjectWriter.WriteInt32(System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadInt64">
            <summary>
            Read a Int64 value from the stream. This value must have been written using <see cref="M:Roslyn.Utilities.ObjectWriter.WriteInt64(System.Int64)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadSByte">
            <summary>
            Read a SByte value from the stream. This value must have been written using <see cref="M:Roslyn.Utilities.ObjectWriter.WriteSByte(System.SByte)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadInt16">
            <summary>
            Read a Int16 value from the stream. This value must have been written using <see cref="M:Roslyn.Utilities.ObjectWriter.WriteInt16(System.Int16)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadUInt32">
            <summary>
            Read a UInt32 value from the stream. This value must have been written using <see cref="M:Roslyn.Utilities.ObjectWriter.WriteUInt32(System.UInt32)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadUInt64">
            <summary>
            Read a UInt64 value from the stream. This value must have been written using <see cref="M:Roslyn.Utilities.ObjectWriter.WriteUInt64(System.UInt64)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadUInt16">
            <summary>
            Read a UInt16 value from the stream. This value must have been written using <see cref="M:Roslyn.Utilities.ObjectWriter.WriteUInt16(System.UInt16)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadDateTime">
            <summary>
            Read a DateTime value from the stream. This value must have been written using the <see cref="M:Roslyn.Utilities.ObjectWriter.WriteDateTime(System.DateTime)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadCompressedUInt">
            <summary>
            Read a compressed 30-bit integer value from the stream. This value must have been written using <see cref="M:Roslyn.Utilities.ObjectWriter.WriteCompressedUInt(System.UInt32)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadValue">
            <summary>
            Read a value from the stream. The value must have been written using ObjectWriter.WriteValue.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadString">
            <summary>
            Read a String value from the stream. This value must have been written using ObjectWriter.WriteString.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ObjectWriter">
            <summary>
            A class that writes both primitive values and non-cyclical object graphs to a stream that may be
            later read back using the ObjectReader class.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteBoolean(System.Boolean)">
            <summary>
            Writes a Boolean value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteByte(System.Byte)">
            <summary>
            Writes a Byte value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteChar(System.Char)">
            <summary>
            Writes a Char value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteDecimal(System.Decimal)">
            <summary>
            Writes a Decimal value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteDouble(System.Double)">
            <summary>
            Writes a Double value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteSingle(System.Single)">
            <summary>
            Writes a Single value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteInt32(System.Int32)">
            <summary>
            Writes a Int32 value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteInt64(System.Int64)">
            <summary>
            Writes a Int64 value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteSByte(System.SByte)">
            <summary>
            Writes a SByte value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteInt16(System.Int16)">
            <summary>
            Writes a Int16 value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteUInt32(System.UInt32)">
            <summary>
            Writes a UInt32 value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteUInt64(System.UInt64)">
            <summary>
            Writes a UInt64 value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteUInt16(System.UInt16)">
            <summary>
            Writes a UInt16 value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteDateTime(System.DateTime)">
            <summary>
            Writes a DateTime value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteCompressedUInt(System.UInt32)">
            <summary>
            Writes a compressed 30 bit integer to the stream. (not 32 bit)
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteString(System.String)">
            <summary>
            Writes a String value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteValue(System.Object)">
            <summary>
            Writes any value (primitive or object graph) to the stream.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.RecordingObjectBinder">
            <summary>
            A binder that gathers type/reader mappings during object writing
            </summary>
        </member>
    </members>
</doc>
