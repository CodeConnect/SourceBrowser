<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.CodeAnalysis.Workspaces</name>
    </assembly>
    <members>
        <member name="M:Microsoft.CodeAnalysis.FusionAssemblyIdentity.ToAssemblyName(Microsoft.CodeAnalysis.FusionAssemblyIdentity.IAssemblyName)">
            <summary>
            Converts <see cref="T:Microsoft.CodeAnalysis.FusionAssemblyIdentity.IAssemblyName"/> to <see cref="T:System.Reflection.AssemblyName"/> with possibly missing name components.
            </summary>
            <returns>
            An <see cref="T:System.Reflection.AssemblyName"/> whose fields are be null if not present in <paramref name="nameObject"/>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FusionAssemblyIdentity.ToAssemblyIdentity(Microsoft.CodeAnalysis.FusionAssemblyIdentity.IAssemblyName)">
            <summary>
            Converts <see cref="T:Microsoft.CodeAnalysis.FusionAssemblyIdentity.IAssemblyName"/> to <see cref="T:System.Reflection.AssemblyName"/> with all metadata fields filled.
            </summary>
            <returns>
            Assembly name with Version, Culture and PublicKeyToken components filled in:
            "SimpleName, Version=#.#.#.#, Culture=XXX, PublicKeyToken=XXXXXXXXXXXXXXXX".
            In addition Retargetable flag and ContentType are set.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FusionAssemblyIdentity.ToAssemblyNameObject(System.Reflection.AssemblyName)">
            <summary>
            Converts <see cref="T:System.Reflection.AssemblyName"/> to an equivalent <see cref="T:Microsoft.CodeAnalysis.FusionAssemblyIdentity.IAssemblyName"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FusionAssemblyIdentity.ToAssemblyNameObject(System.String)">
            <summary>
            Creates <see cref="T:Microsoft.CodeAnalysis.FusionAssemblyIdentity.IAssemblyName"/> object by parsing given display name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FusionAssemblyIdentity.GetBestMatch(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.FusionAssemblyIdentity.IAssemblyName},System.String)">
            <summary>
            Selects the candidate assembly with the largest version number.  Uses culture as a tie-breaker if it is provided.
            All candidates are assumed to have the same name and must include versions and cultures.  
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.GlobalAssemblyCache">
            <summary>
            Provides APIs to enumerate and look up assemblies stored in the Global Assembly Cache.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.GlobalAssemblyCache.CurrentArchitectureFilter">
            <summary>
            Represents the current Processor architecture
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GlobalAssemblyCache.GetAssemblyIdentities(System.Reflection.AssemblyName,System.Func{System.Reflection.ProcessorArchitecture,System.Boolean})">
            <summary>
            Enumerates assemblies in the GAC returning those that match given partial name and
            architecture.
            </summary>
            <param name="partialName">Optional partial name.</param>
            <param name="architectureFilter">Optional architecture filter.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GlobalAssemblyCache.GetAssemblyIdentities(System.String,System.Func{System.Reflection.ProcessorArchitecture,System.Boolean})">
            <summary>
            Enumerates assemblies in the GAC returning those that match given partial name and
            architecture.
            </summary>
            <param name="partialName">The optional partial name.</param>
            <param name="architectureFilter">The optional architecture filter.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GlobalAssemblyCache.GetAssemblySimpleNames(System.Func{System.Reflection.ProcessorArchitecture,System.Boolean})">
            <summary>
            Enumerates assemblies in the GAC returning their simple names.
            </summary>
            <param name="architectureFilter">Optional architecture filter.</param>
            <returns>Unique simple names of GAC assemblies.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GlobalAssemblyCache.ResolvePartialName(System.String,System.Func{System.Reflection.ProcessorArchitecture,System.Boolean},System.Globalization.CultureInfo)">
            <summary>
            Looks up specified partial assembly name in the GAC and returns the best matching <see cref="T:Microsoft.CodeAnalysis.AssemblyIdentity"/>.
            </summary>
            <param name="displayName">The display name of an assembly</param>
            <param name="architectureFilter">The optional processor architecture</param>
            <param name="preferredCulture">The optional preferred culture information</param>
            <returns>An assembly identity or null, if <paramref name="displayName"/> can't be resolved.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="displayName"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GlobalAssemblyCache.ResolvePartialName(System.String,System.String@,System.Func{System.Reflection.ProcessorArchitecture,System.Boolean},System.Globalization.CultureInfo)">
            <summary>
            Looks up specified partial assembly name in the GAC and returns the best matching <see cref="T:Microsoft.CodeAnalysis.AssemblyIdentity"/>.
            </summary>
            <param name="displayName">The display name of an assembly</param>
            <param name="location">Full path name of the resolved assembly</param>
            <param name="architectureFilter">The optional processor architecture</param>
            <param name="preferredCulture">The optional preferred culture information</param>
            <returns>An assembly identity or null, if <paramref name="displayName"/> can't be resolved.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="displayName"/> is null.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.EncodedStringText">
            <summary>
            Implementation of SourceText based on a <see cref="T:System.String"/> input
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Text.EncodedStringText.source">
            <summary>
            Underlying string on which this SourceText instance is based
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Text.EncodedStringText.sha1Checksum">
            <summary>
            Sha1 checksum of the underlying stream.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.EncodedStringText.Source">
            <summary>
            Underlying string which is the source of this SourceText instance
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Initializes an instance of <see cref="T:StringText"/> with provided bytes.
            </summary>
            <param name="stream"></param>
            <param name="encodingOpt">
            Automatically detected, if not specified: BigEndianUnicode, Unicode, UTF8
            (with or without byte order mark). Windows-1252 will be used as a fallback.
            This method will throw an InvalidDataException if the stream appears to be a binary file and 
            a DecoderFallbackException if it can't be decoded.
            </param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.EncodedStringText.Length">
            <summary>
            The length of the text represented by <see cref="T:StringText"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.EncodedStringText.Item(System.Int32)">
            <summary>
            Returns a character at given position.
            </summary>
            <param name="position">The position to get the character from.</param>
            <returns>The character.</returns>
            <exception cref="T:ArgumentOutOfRangeException">When position is negative or 
            greater than <see cref="T:"/> length.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.ToString(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Provides a string representation of the StringText located within given span.
            </summary>
            <exception cref="T:ArgumentOutOfRangeException">When given span is outside of the text range.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.DetectEncodingAndDecode(System.IO.Stream)">
            <summary>
            The following encodings will be automatically detected: 
            BigEndianUnicode, Unicode, UTF8 (with or without byte order mark).
            The default windows codepage will be used as a fallback. If the 
            default windows codepage is 1252 (Western European), we will try to
            detect if the stream is binary encoded. Does not close the stream 
            after decoding.
            </summary>
            <exception cref="T:System.IO.InvalidDataException">If a binary file is 
            detected.</exception>
            <exception cref="T:System.Text.DecoderFallbackException">If the detected 
            encoding can't decode the stream.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.DecodeIfNotBinary(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Decodes the file using the supplied <paramref name="encoding"/> if and only 
            if the file fails the heuristic for detecting a binary file. The heuristic checks
            for occurrence of two consecutive NUL (U+0000) characters in the stream, which are 
            highly unlikely to appear in a text file. Since the heuristic is applied after 
            the text has been decoded, it can be used with any encoding.
            Does not close the stream when finished.
            </summary>
            <param name="data">Data stream</param>
            <param name="encoding">Encoding to use for decode</param>
            <exception cref="T:System.IO.InvalidDataException">If the stream is binary encoded</exception>
            <returns>Decoded stream as a text string</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.Decode(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Decode the given stream using the given encoding. Does not
            close the stream afterwards.
            </summary>
            <param name="data">Data stream</param>
            <param name="encoding">Encoding to use for decode</param>
            <exception cref="T:System.Text.DecoderFallbackException">If the given 
            encoding is set to use <see cref="T:System.Text.DecoderExceptionFallback"/>
            as its fallback decoder.</exception>
            <returns>Decoded stream as a text string</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.ReadUnicodeStringFromMemoryMappedViewStream(System.IO.MemoryMappedFiles.MemoryMappedViewStream)">
            <summary>
            Read a Unicode string from a memory mapped view. The stream is not closed on exit.
            </summary>
            <param name="memoryMappedViewStream">A view over a memory mapped stream which contains a Unicode string (preceded by a Unicode BOM)</param>
            <returns>The string</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.TryDecodeMemoryStream(System.IO.MemoryStream,System.Text.Encoding,System.Boolean,System.String@)">
            <summary>
            If the MemoryStream was created with publiclyVisible=true, then we can access its buffer
            directly and save allocations in StreamReader. The input MemoryStream is not closed on exit.
            </summary>
            <exception cref="T:System.Text.DecoderFallbackException">If the given encoding is set to use <see cref="T:System.Text.DecoderExceptionFallback"/> 
            as its fallback decoder.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.TryDecodeUTF8NoBOM(System.IO.Stream,System.String@)">
            <summary>
            Assume that the input is UTF8 encoded with no byte order mark (BOM)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextExtensions.GetRelatedDocumentsWithChanges(Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Gets the documents from the corresponding workspace's current solution that are associated with the source text's container,
            updated to contain the same text as the source if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextExtensions.GetOpenDocumentInCurrentContextWithChanges(Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Gets the document from the corresponding workspace's current solution that is associated with the source text's container 
            in its current project context, updated to contain the same text as the source if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextExtensions.GetRelatedDocuments(Microsoft.CodeAnalysis.Text.SourceTextContainer)">
            <summary>
            Gets the documents from the corresponding workspace's current solution that are associated with the text container. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextExtensions.GetOpenDocumentInCurrentContext(Microsoft.CodeAnalysis.Text.SourceTextContainer)">
            <summary>
            Gets the document from the corresponding workspace's current solution that is associated with the text container 
            in its current project context.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector.Annotation">
            <summary>
            The annotation normally used on nodes to request case correction.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector.CaseCorrectAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Case corrects all names found in the provided document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector.CaseCorrectAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxAnnotation,System.Threading.CancellationToken)">
            <summary>
            Case corrects all names found in the spans of any nodes annotated with the provided
            annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector.CaseCorrectAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            Case corrects all names found in the span.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector.CaseCorrectAsync(Microsoft.CodeAnalysis.Document,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            Case corrects all names found in the provided spans.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector.CaseCorrect(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Workspace,System.Threading.CancellationToken)">
            <summary>
            Case correct only things that don't require semantic information
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseCorrection.ICaseCorrectionService.CaseCorrectAsync(Microsoft.CodeAnalysis.Document,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            Case corrects all names found in the spans in the provided document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseCorrection.ICaseCorrectionService.CaseCorrect(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Workspace,System.Threading.CancellationToken)">
            <summary>
            Case corrects only things that don't require semantic information
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier.SyntaxNodeTypes">
            <summary>
            The syntax node types this classifier is able to classify
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier.SyntaxTokenKinds">
            <summary>
            The syntax token kinds this classifier is able to classify
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier.ClassifyNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SemanticModel,System.Threading.CancellationToken)">
            <summary>
            This method will be called for all nodes that match the types specified by the SyntaxNodeTypes property.
            Implementations should return null (instead of an empty enumerable) if they have no classifications for the provided node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier.ClassifyToken(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SemanticModel,System.Threading.CancellationToken)">
            <summary>
            This method will be called for all nodes that match the types specified by the SyntaxTokenKinds property.
            Implementations should return null (instead of an empty enumerable) if they have no classifications for the provided token.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.GetPreviousTokenStartPosition(Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.SpanMarkerType,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Get the proper start position based on the span marker type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.GetNextTokenEndPosition(Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.SpanMarkerType,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Get the proper end position based on the span marker type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.AnnotateNodeForTextSpans(Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            Inject annotations into the node so that it can re-calculate spans for each code cleaner after each tree transformation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.GetNonOverlappingSpans(Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            Make sure annotations are positioned outside of any spans. If not, merge two adjacent spans to one.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.GetTokensAroundSpan(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.SyntaxToken@)">
             <summary>
             Retrieves four tokens around span like below.
            
             [previousToken][startToken][SPAN][endToken][nextToken]
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.GetSpanAlignedToTokens(Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.SyntaxToken@)">
            <summary>
            Adjust provided span to align to either token's start position or end position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.FindTokenOnRightOfPosition(Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService,Microsoft.CodeAnalysis.SyntaxNode,System.Int32)">
            <summary>
            Find closest token (including one in structured trivia) right of given position
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.FindTokenOnLeftOfPosition(Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService,Microsoft.CodeAnalysis.SyntaxNode,System.Int32)">
            <summary>
            Find closest token (including one in structured trivia) left of given position
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.SpanMarkerType">
            <summary>
            Enum that indicates type of span marker
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.SpanMarkerType.Normal">
            <summary>
            Normal case
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.SpanMarkerType.BeginningOfFile">
            <summary>
            Span starts at the beginning of the tree
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.SpanMarkerType.EndOfFile">
            <summary>
            Span ends at the end of the tree
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.SpanMarker">
            <summary>
            Internal annotation type to mark span location in the tree.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.SpanMarker.Type">
            <summary>
            Indicates the current marker type
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.SpanMarker.OppositeMarkerType">
            <summary>
            Indicates how to find the other side of the span marker if it is missing
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner">
            <summary>
            Static CodeCleaner class that provides default code cleaning behavior.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner.GetDefaultProviders(Microsoft.CodeAnalysis.Document)">
            <summary>
            Return default code cleaners for a given document.
            
            This can be modified and given to the Cleanup method to provide different cleaners.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner.CleanupAsync(Microsoft.CodeAnalysis.Document,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider},System.Threading.CancellationToken)">
            <summary>
            Cleans up the whole document.
            Optionally you can provide your own options and code cleaners. Otherwise, the default will be used.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner.CleanupAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxAnnotation,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider},System.Threading.CancellationToken)">
            <summary>
            Cleans up the document marked with the provided annotation.
            Optionally you can provide your own options and code cleaners. Otherwise, the default will be used.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner.CleanupAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider},System.Threading.CancellationToken)">
            <summary>
            Clean up the provided span in the document.
            Optionally you can provide your own options and code cleaners. Otherwise, the default will be used.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner.CleanupAsync(Microsoft.CodeAnalysis.Document,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider},System.Threading.CancellationToken)">
            <summary>
            Clean up the provided spans in the document.
            Optionally you can provide your own options and code cleaners. Otherwise, the default will be used.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner.Cleanup(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Workspace,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider},System.Threading.CancellationToken)">
            <summary>
            Clean up the provided span in the node.
            This will only cleanup stuff that doesn't require semantic information.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner.Cleanup(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Workspace,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider},System.Threading.CancellationToken)">
            <summary>
            Clean up the provided spans in the node.
            This will only cleanup stuff that doesn't require semantic information.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeCleanup.ICodeCleanerService">
            <summary>
            Internal code cleanup service interface.
            
            This is not supposed to be used directly. It just provides a way to get the right service from each language.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.ICodeCleanerService.GetDefaultProviders">
            <summary>
            Returns the default code cleaners.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.ICodeCleanerService.CleanupAsync(Microsoft.CodeAnalysis.Document,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider},System.Threading.CancellationToken)">
            <summary>
            This will run all provided code cleaners in an order that is given to the method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.ICodeCleanerService.Cleanup(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Workspace,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider},System.Threading.CancellationToken)">
            <summary>
            This will run all provided code cleaners in an order that is given to the method.
            
            This will do cleanups that don't require any semantic information.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeCleanup.Providers.ExportCodeCleanupProvider">
            <summary>
            Specifies the exact type of the code cleanup exported.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider">
            <summary>
            A code cleaner that requires semantic information to do its job.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider.Name">
            <summary>
            Returns the name of this provider.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider.CleanupAsync(Microsoft.CodeAnalysis.Document,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            This should apply its code clean up logic to the spans of the document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider.Cleanup(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Workspace,System.Threading.CancellationToken)">
            <summary>
            This will run all provided code cleaners in an order that is given to the method.
            
            This will do cleanups that don't require any semantic information
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeCleanup.Providers.SimpleCodeCleanupProvider">
            <summary>
            Helper class that implements <see cref="T:Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider"/> using delegates passed to its constructor.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions">
            <summary>
            Options for controlling the code produced by the <see cref="T:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.ContextLocation">
            <summary>
            A location used to determine the best place to generate a member.  This is only used for
            determining which part of a partial type to generate in.  If a type only has one part, or
            an API is used that specifies the type, then this is not used.  A part is preferred if
            it surrounds this context location. If no part surrounds this location then a part is
            preferred if it comes from the same SyntaxTree as this location.  If there is no
            such part, then any part may be used for generation.
            
            This option is not necessary if 'AfterThisLocation' or 'BeforeThisLocation' are
            provided.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.AfterThisLocation">
            <summary>
            A hint to the code generation service to specify where the generated code should be
            placed.  Code will be generated after this location if the location is valid in the type
            or symbol being generated into, and it is possible to generate the code after it.
            
            If this option is provided, neither 'ContextLocation' nor 'BeforeThisLocation' are
            needed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.BeforeThisLocation">
            <summary>
            A hint to the code generation service to specify where the generated code should be
            placed.  Code will be generated before this location if the location is valid in the type
            or symbol being generated into, and it is possible to generate the code after it. 
            
            If this option is provided, neither 'ContextLocation' nor 'AfterThisLocation' are
            needed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.AddImports">
            <summary>
            True if the code generation service should try to automatically add imports to the file
            for any generated code.  Defaults to true.  Not used when generating directly into a
            declaration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.PlaceSystemNamespaceFirst">
            <summary>
            True if, when adding a System import, the import should be placed above non-System
            imports.  Defaults to true.  Only used if AddImports is true.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.AdditionalImports">
            <summary>
            Contains additional imports to be automatically added.  This is useful for adding
            imports that are part of a list of statements.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.GenerateMembers">
            <summary>
            True if members of a symbol should also be generated along with the declaration.  If
            false, only the symbol's declaration will be generated.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.MergeNestedNamespaces">
            <summary>
            True if the code generator should merge namespaces which only contain other namespaces
            into a single declaration with a dotted name.  False if the nesting should be preserved
            and each namespace declaration should be nested and should only have a single non-dotted
            name.
            
            Merging can only occur if the namespace only contains a single member that is also a
            namespace.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.MergeAttributes">
            <summary>
            True if the code generation should put multiple attributes in a single attribute
            declaration, or if should have a separate attribute declaration for each attribute.  For
            example, in C# setting this to True this would produce "[Foo, Bar]" while setting it to
            False would produce "[Foo][Bar]"
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.GenerateDefaultAccessibility">
            <summary>
            True if the code generator should always generate accessibility modifiers, even if they
            are the same as the defaults for that symbol.  For example, a private field in C# does
            not need its accessibility specified as it will be private by default.  However, if this
            option is set to true 'private' will still be generated.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.GenerateMethodBodies">
            <summary>
            True if the code generator should generate empty bodies for methods along with the
            method declaration.  If false, only method declarations will be generated.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.GenerateDocumentationComments">
            <summary>
            True if the code generator should generate documentation comments where available
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.AutoInsertionLocation">
            <summary>
            True if the code generator should automatically attempt to choose the appropriate location
            to insert members.  If false and a generation location is not specified by AfterThisLocation,
            or BeforeThisLocation, members will be inserted at the end of the destination definition.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.ReuseSyntax">
            <summary>
            True if the code generator should attempt to reuse the syntax of the constituent entities, such as members, access modifier tokens, etc. while attempting to generate code.
            If any of the member symbols have zero declaring syntax references (non-source symbols) OR two or more declaring syntax references (partial definitions), then syntax is not reused.
            If false, then the code generator will always synthesize a new syntax node and ignore the declaring syntax references.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory">
            <summary>
            Generates symbols that describe declarations to be generated.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.IsCodeGenerationSymbol(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Determines if the symbol is purely a code generation symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateEventSymbol(System.Collections.Generic.IList{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.CodeGeneration.SymbolModifiers,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.IEventSymbol,System.String,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.IMethodSymbol,System.Collections.Generic.IList{Microsoft.CodeAnalysis.IParameterSymbol})">
            <summary>
            Creates an event symbol that can be used to describe an event declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreatePropertySymbol(System.Collections.Generic.IList{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.CodeGeneration.SymbolModifiers,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.IPropertySymbol,System.String,System.Collections.Generic.IList{Microsoft.CodeAnalysis.IParameterSymbol},Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.IMethodSymbol,System.Boolean)">
            <summary>
            Creates a property symbol that can be used to describe a property declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateFieldSymbol(System.Collections.Generic.IList{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.CodeGeneration.SymbolModifiers,Microsoft.CodeAnalysis.ITypeSymbol,System.String,System.Boolean,System.Object,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a field symbol that can be used to describe a field declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateConstructorSymbol(System.Collections.Generic.IList{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.CodeGeneration.SymbolModifiers,System.String,System.Collections.Generic.IList{Microsoft.CodeAnalysis.IParameterSymbol},System.Collections.Generic.IList{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IList{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IList{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a constructor symbol that can be used to describe a constructor declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateDestructorSymbol(System.Collections.Generic.IList{Microsoft.CodeAnalysis.AttributeData},System.String,System.Collections.Generic.IList{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a destructor symbol that can be used to describe a destructor declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateMethodSymbol(System.Collections.Generic.IList{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.CodeGeneration.SymbolModifiers,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.IMethodSymbol,System.String,System.Collections.Generic.IList{Microsoft.CodeAnalysis.ITypeParameterSymbol},System.Collections.Generic.IList{Microsoft.CodeAnalysis.IParameterSymbol},System.Collections.Generic.IList{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IList{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IList{Microsoft.CodeAnalysis.AttributeData})">
            <summary>
            Creates a method symbol that can be used to describe a method declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateOperatorSymbol(System.Collections.Generic.IList{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.CodeGeneration.SymbolModifiers,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOperatorKind,System.Collections.Generic.IList{Microsoft.CodeAnalysis.IParameterSymbol},System.Collections.Generic.IList{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IList{Microsoft.CodeAnalysis.AttributeData})">
            <summary>
            Creates a method symbol that can be used to describe an operator declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateConversionSymbol(System.Collections.Generic.IList{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.CodeGeneration.SymbolModifiers,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.IParameterSymbol,System.Boolean,System.Collections.Generic.IList{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IList{Microsoft.CodeAnalysis.AttributeData})">
            <summary>
            Creates a method symbol that can be used to describe a conversion declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateParameterSymbol(Microsoft.CodeAnalysis.ITypeSymbol,System.String)">
            <summary>
            Creates a parameter symbol that can be used to describe a parameter declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateParameterSymbol(System.Collections.Generic.IList{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.RefKind,System.Boolean,Microsoft.CodeAnalysis.ITypeSymbol,System.String,System.Boolean,System.Boolean,System.Object)">
            <summary>
            Creates a parameter symbol that can be used to describe a parameter declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateTypeParameterSymbol(System.String,System.Int32)">
            <summary>
            Creates a parameter symbol that can be used to describe a parameter declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateTypeParameter(System.Collections.Generic.IList{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.VarianceKind,System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ITypeSymbol},System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Creates a type parameter symbol that can be used to describe a type parameter declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreatePointerTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Creates a pointer type symbol that can be used to describe a pointer type reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateArrayTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol,System.Int32)">
            <summary>
            Creates an array type symbol that can be used to describe an array type reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateAccessorSymbol(System.Collections.Generic.IList{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,System.Collections.Generic.IList{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an method type symbol that can be used to describe an accessor method declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateAttributeData(Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.TypedConstant},System.Collections.Immutable.ImmutableArray{System.Collections.Generic.KeyValuePair{System.String,Microsoft.CodeAnalysis.TypedConstant}})">
            <summary>
            Create attribute data that can be used in describing an attribute declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateNamedTypeSymbol(System.Collections.Generic.IList{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.CodeGeneration.SymbolModifiers,Microsoft.CodeAnalysis.TypeKind,System.String,System.Collections.Generic.IList{Microsoft.CodeAnalysis.ITypeParameterSymbol},Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Generic.IList{Microsoft.CodeAnalysis.INamedTypeSymbol},Microsoft.CodeAnalysis.SpecialType,System.Collections.Generic.IList{Microsoft.CodeAnalysis.ISymbol})">
            <summary>
            Creates a named type symbol that can be used to describe a named type declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateDelegateTypeSymbol(System.Collections.Generic.IList{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.CodeGeneration.SymbolModifiers,Microsoft.CodeAnalysis.ITypeSymbol,System.String,System.Collections.Generic.IList{Microsoft.CodeAnalysis.ITypeParameterSymbol},System.Collections.Generic.IList{Microsoft.CodeAnalysis.IParameterSymbol})">
            <summary>
            Creates a method type symbol that can be used to describe a delegate type declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateNamespaceSymbol(System.String,System.Collections.Generic.IList{Microsoft.CodeAnalysis.ISymbol},System.Collections.Generic.IList{Microsoft.CodeAnalysis.INamespaceOrTypeSymbol})">
            <summary>
            Creates a namespace symbol that can be used to describe a namespace declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.CreateEventDeclaration(Microsoft.CodeAnalysis.IEventSymbol,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Returns a newly created event declaration node from the provided event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.CreateFieldDeclaration(Microsoft.CodeAnalysis.IFieldSymbol,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Returns a newly created field declaration node from the provided field.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.CreateMethodDeclaration(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Returns a newly created method declaration node from the provided method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.CreatePropertyDeclaration(Microsoft.CodeAnalysis.IPropertySymbol,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Returns a newly created property declaration node from the provided property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.CreateNamedTypeDeclaration(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Returns a newly created named type declaration node from the provided named type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.CreateNamespaceDeclaration(Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Returns a newly created namespace declaration node from the provided namespace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddEventDeclaration``1(``0,Microsoft.CodeAnalysis.IEventSymbol,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Create a new declaration node with an event declaration of the same signature as the specified symbol added to it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddFieldDeclaration``1(``0,Microsoft.CodeAnalysis.IFieldSymbol,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Create a new declaration node with a field declaration of the same signature as the specified symbol added to it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddMethodDeclaration``1(``0,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Create a new declaration node with a method declaration of the same signature as the specified symbol added to it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddPropertyDeclaration``1(``0,Microsoft.CodeAnalysis.IPropertySymbol,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Create a new declaration node with a property declaration of the same signature as the specified symbol added to it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddNamedTypeDeclaration``1(``0,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Create a new declaration node with a named type declaration of the same signature as the specified symbol added to it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddMemberDeclarations``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Create a new declaration node with multiple member declarations of the same signatures as the specified symbols added to it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddParameterDeclarations``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IParameterSymbol},Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Create a new declaration node with one or more parameter declarations of the same signature as the specified symbols added to it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddAttributes``1(``0,Microsoft.CodeAnalysis.Workspace,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.AttributeData},System.Nullable{Microsoft.CodeAnalysis.SyntaxToken},Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Create a new declaration node with the specified attributes added to it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.RemoveAttribute``1(``0,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.AttributeData,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Removes the specified attribute node from the given declaration node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.RemoveAttribute``1(``0,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Removes the specified attribute node from the given declaration node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddStatements``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Create a new declaration node with one or more statements added to its body.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddEventDeclarationAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.IEventSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Create a new solution where the declaration of the destination symbol has an additional event of the same signature as the specified event symbol.
            Returns the document in the new solution where the destination symbol is declared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddFieldDeclarationAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.IFieldSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Create a new solution where the declaration of the destination symbol has an additional field of the same signature as the specified field symbol.
            Returns the document in the new solution where the destination symbol is declared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddMethodDeclarationAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Create a new solution where the declaration of the destination symbol has an additional method of the same signature as the specified method symbol.
            Returns the document in the new solution where the destination symbol is declared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddPropertyDeclarationAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.IPropertySymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Create a new solution where the declaration of the destination symbol has an additional property of the same signature as the specified property symbol.
            Returns the document in the new solution where the destination symbol is declared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddNamedTypeDeclarationAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Create a new solution where the declaration of the destination symbol has an additional named type of the same signature as the specified named type symbol.
            Returns the document in the new solution where the destination symbol is declared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddNamedTypeDeclarationAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Create a new solution where the declaration of the destination symbol has an additional named type of the same signature as the specified named type symbol.
            Returns the document in the new solution where the destination symbol is declared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddNamespaceDeclarationAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Create a new solution where the declaration of the destination symbol has an additional namespace of the same signature as the specified namespace symbol.
            Returns the document in the new solution where the destination symbol is declared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddNamespaceOrTypeDeclarationAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Create a new solution where the declaration of the destination symbol has an additional namespace or type of the same signature as the specified namespace or type symbol.
            Returns the document in the new solution where the destination symbol is declared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddMemberDeclarationsAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Create a new solution where the declaration of the destination symbol has additional members of the same signature as the specified member symbols.
            Returns the document in the new solution where the destination symbol is declared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.CanAdd(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            Returns <c>true</c> if additional declarations can be added to the destination symbol's declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.CreateEventDeclaration(Microsoft.CodeAnalysis.IEventSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Returns a newly created event declaration node from the provided event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.CreateFieldDeclaration(Microsoft.CodeAnalysis.IFieldSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Returns a newly created field declaration node from the provided field.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.CreateMethodDeclaration(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Returns a newly created method declaration node from the provided method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.CreatePropertyDeclaration(Microsoft.CodeAnalysis.IPropertySymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Returns a newly created property declaration node from the provided property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.CreateNamedTypeDeclaration(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Returns a newly created named type declaration node from the provided named type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.CreateNamespaceDeclaration(Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Returns a newly created namespace declaration node from the provided namespace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddEvent``1(``0,Microsoft.CodeAnalysis.IEventSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds an event into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddField``1(``0,Microsoft.CodeAnalysis.IFieldSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds a field into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddMethod``1(``0,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds a method into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddProperty``1(``0,Microsoft.CodeAnalysis.IPropertySymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds a property into destination. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddNamedType``1(``0,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds a named type into destination. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddNamespace``1(``0,Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds a namespace into destination. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddMembers``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds a method into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddParameters``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IParameterSymbol},Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds the parameters to destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddAttributes``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.AttributeData},System.Nullable{Microsoft.CodeAnalysis.SyntaxToken},Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds the attributes to destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.RemoveAttribute``1(``0,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Remove the given attribute from destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.RemoveAttribute``1(``0,Microsoft.CodeAnalysis.AttributeData,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Remove the given attribute from destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.UpdateDeclarationModifiers``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Update the modifiers list for the given declaration node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.UpdateDeclarationAccessibility``1(``0,Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Update the accessibility modifiers for the given declaration node, retaining the trivia of the existing modifiers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.UpdateDeclarationType``1(``0,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Update the type for the given declaration node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.UpdateDeclarationMembers``1(``0,System.Collections.Generic.IList{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Replace the existing members with the given newMembers for the given declaration node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddStatements``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds the statements to destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddEventAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.IEventSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds a field with the provided signature into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddFieldAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.IFieldSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds a field with the provided signature into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddMethodAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds a method with the provided signature into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddPropertyAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.IPropertySymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds a property with the provided signature into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddNamedTypeAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds a named type into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddNamedTypeAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds a named type into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddNamespaceAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds a namespace into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddNamespaceOrTypeAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds a namespace or type into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddMembersAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds all the provided members into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.CanAddTo(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            <c>true</c> if destination is a location where other symbols can be added to.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.CanAddTo(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            <c>true</c> if destination is a location where other symbols can be added to.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Differencing.Edit`1">
            <summary>
            Represents an edit operation on a tree or a sequence of nodes.
            </summary>
            <typeparam name="TNode">Tree node.</typeparam>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Differencing.Edit`1.OldNode">
            <summary>
            Insert: 
            default(TNode).
            
            Delete: 
            Deleted node.
            
            Move, Update: 
            Node in the tree/sequence #1.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Differencing.Edit`1.NewNode">
            <summary>
            Insert: 
            Inserted node.
            
            Delete: 
            default(TNode)
            
            Move, Update:
            Node in the tree/sequence #2.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Differencing.EditKind.None">
            <summary>
            No change.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Differencing.EditKind.Update">
            <summary>
            Node value was updated.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Differencing.EditKind.Insert">
            <summary>
            Node was inserted.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Differencing.EditKind.Delete">
            <summary>
            Node was deleted.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Differencing.EditKind.Move">
            <summary>
            Node changed parent.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Differencing.EditKind.Reorder">
            <summary>
            Node changed position within its parent. The parent nodes of the old node and the new node are matching.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Differencing.EditScript`1">
            <summary>
            Represents a sequence of tree edits.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1">
            <summary>
            Calculates Longest Common Subsequence.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1.ComputeDistance(`0,System.Int32,`0,System.Int32)">
            <summary>
            Returns a distance [0..1] of the specified sequences.
            The smaller distance the more of their elements match.
            </summary>
            <summary>
            Returns a distance [0..1] of the specified sequences.
            The smaller distance the more of their elements match.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1.ComputeCostMatrix(`0,System.Int32,`0,System.Int32)">
            <summary>
            Calculates costs of all paths in an edit graph starting from vertext (0,0) and ending in vertex (lengthA, lengthB). 
            </summary>
            <remarks>
            The edit graph for A and B has a vertex at each point in the grid (i,j), i in [0, lengthA] and j in [0, lengthB].
            
            The vertices of the edit graph are connected by horizontal, vertical, and diagonal directed edges to form a directed acyclic graph.
            Horizontal edges connect each vertex to its right neighbor. 
            Vertical edges connect each vertex to the neighbor below it.
            Diagonal edges connect vertex (i,j) to vertex (i-1,j-1) if <see cref="M:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1.ItemsEqual(`0,System.Int32,`0,System.Int32)"/>(sequenceA[i-1],sequenceB[j-1]) is true.
            
            Editing starts with S = []. 
            Move along horizontal edge (i-1,j)-(i,j) represents the fact that sequenceA[i-1] is not added to S.
            Move along vertical edge (i,j-1)-(i,j) represents an insert of sequenceB[j-1] to S.
            Move along diagonal edge (i-1,j-1)-(i,j) represents an addition of sequenceB[j-1] to S via an acceptable 
            change of sequenceA[i-1] to sequenceB[j-1].
            
            In every vertex the cheapest outgoing edge is selected. 
            The number of diagonal edges on the path from (0,0) to (lengthA, lengthB) is the length of the longest common subsequence.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Differencing.LongestCommonSubstring">
            <summary>
            Calculates longest common substring using Wagner algorithm.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.Match`1.GetTreeEdits">
            <summary>
            Returns an edit script (a sequence of edits) that transform <see cref="P:Microsoft.CodeAnalysis.Differencing.Match`1.OldRoot"/> subtree 
            to <see cref="P:Microsoft.CodeAnalysis.Differencing.Match`1.NewRoot"/> subtree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.Match`1.GetSequenceEdits(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Returns an edit script (a sequence of edits) that transform a sequence of nodes <paramref name="oldNodes"/>
            to a sequence of nodes <paramref name="newNodes"/>. 
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="oldNodes"/> or <paramref name="newNodes"/> is a null reference.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Differencing.TreeComparer`1">
            <summary>
            Implements a tree differencing algorithm.
            </summary>
            <remarks>
            Subclasses define relationships among tree nodes, and parameters to the differencing algorithm.
            </remarks>
            <typeparam name="TNode">Tree node.</typeparam>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.ComputeEditScript(`0,`0)">
            <summary>
            Returns an edit script that transforms <paramref name="oldRoot"/> to <paramref name="newRoot"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.ComputeMatch(`0,`0,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`0}})">
            <summary>
            Returns a match map of <paramref name="oldRoot"/> descendants to <paramref name="newRoot"/> descendants.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.GetDistance(`0,`0)">
            <summary>
            Calculates the distance [0..1] of two nodes.
            </summary>
            <remarks>
            The more similar the nodes the smaller the distance.
            
            Used to determine whether two nodes of the same label match.
            Even if 0 is returned the nodes might be slightly different.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.ValuesEqual(`0,`0)">
            <summary>
            Returns true if the specified nodes have equal values.
            </summary>
            <remarks>
            Called with matching nodes (<paramref name="oldNode"/>, <paramref name="newNode"/>).
            Return true if the values of the nodes are the same, or their difference is not important.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.LabelCount">
            <summary>
            The number of distinct labels used in the tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.GetLabel(`0)">
            <summary>
            Returns an integer label corresponding to the given node.
            </summary>
            <remarks>Returned value must be within [0, LabelCount).</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.TiedToAncestor(System.Int32)">
            <summary>
            Returns N > 0 if the node with specified label can't change its N-th ancestor node, zero otherwise.
            </summary>
            <remarks>
            1st ancestor is the node's parent node.
            2nd ancestor is the node's grandparent node.
            etc.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.GetChildren(`0)">
            <summary>
            May return null if the <paramref name="node"/> is a leaf.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.GetDescendants(`0)">
            <summary>
            Enumerates all descendant nodes of the given node in depth-first prefix order.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.TryGetParent(`0,`0@)">
            <summary>
            Returns a parent for the specified node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.TreesEqual(`0,`0)">
            <summary>
            Return true if specified nodes belong to the same tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.GetSpan(`0)">
            <summary>
            Returns the position of the node.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder">
            <summary>
            Provides helper methods for finding dependent projects across a solution that a given symbol can be referenced within.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder.dependentProjectsCache">
            <summary>
            Dependent projects cache.
            For a given solution, maps from an assembly (source/metadata) to the set of projects referencing it.
                Key: DefinitionProject, which contains the assembly name and a flag indicating whether assembly is source or metadata assembly.
                Value: List of DependentProjects, where each DependentProject contains a dependent project ID and a flag indicating whether the dependent project has internals access to definition project.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder.createDependentProjectsMapCallback">
            <summary>
            Used to create a new concurrent dependent projects map for a given assembly when needed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder.GetDependentProjectsWorkerAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            This method computes the dependent projects that need to be searched for references of the given <paramref name="symbol"/>.
            This computation depends on the given symbol's visibility:
                1) Public: Dependent projects include the symbol definition project and all the referencing projects.
                2) Internal: Dependent projects include the symbol definition project and all the referencing projects that have internals access to the definition project.
                3) Private: Dependent projects include the symbol definition project and all the referencing submission projects (which are special and can reference private fields of the previous submission).
            
            We perform this computation in two stages:
                1) Compute all the dependent projects (submission + non-submission) and their InternalsVisibleTo semantics to the definition project.
                2) Filter the above computed dependent projects based on symbol visibility.
            Dependent projects computed in stage (1) are cached to avoid recomputation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder.CreateInternalsVisibleToMap(Microsoft.CodeAnalysis.IAssemblySymbol)">
            <summary>
            This method creates an initial cheap InternalsVisibleTo map from the given <paramref name="assembly"/> to the assembly names that have friend access to this assembly.
            This map is a superset of the actual InternalsVisibleTo map and is used for performance reasons only.
            While identifying depend projects that can reference a given symbol (see method <see cref="M:AddNonSubmissionDependentProjectsAsync"/>), we need to know a symbol's
            accessibility from referencing projects. This requires us to create a compilation for the referencing project just to check accessibility and can be performance intensive.
            Instead, we crack the assembly attributes just for the symbol's containing assembly here to enable cheap checks for friend assemblies in <see cref="M:AddNonSubmissionDependentProjectsAsync"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder">
            <summary>
            Provides helper methods for finding dependent types (derivations, implementations, etc.) across a solution.
            </summary>
            <remarks>
            This type makes heavy use of <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2"/> for caching purposes. When
            modifying these caches, care must be taken to avoid introducing memory leaks. Instances of <see cref="T:Microsoft.CodeAnalysis.Compilation"/>
            are used as the keys in these caches, so in general only symbols or other data from that same compilation should be stored
            in the associated value.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder.compilationAllSourceAndAccessibleTypesTable">
            <summary>
            For a given <see cref="T:Microsoft.CodeAnalysis.Compilation"/>, stores a flat list of all the source types and all the accessible metadata types
            within the compilation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder.compilationSourceTypesTable">
            <summary>
            For a given <see cref="T:Microsoft.CodeAnalysis.Compilation"/>, stores a flat list of all the source types.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder.findDerivedClassesPredicate">
            <summary>
            A predicate for determining if one class derives from another. Static to avoid unnecessary allocations.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder.derivedClassesCache">
            <summary>
            For a given <see cref="T:Microsoft.CodeAnalysis.Compilation"/>, maps from a class (from the compilation or one of its dependencies)
            to the set of classes in the compilation that derive from it.
            </summary>
            <remarks>
            <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/>s are used instead of <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>s to avoid keeping other compilations alive
            unnecessarily.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder.findDerivedInterfacesPredicate">
            <summary>
            A predicate for determining if one interface derives from another. Static to avoid unnecessary allocations.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder.derivedInterfacesCache">
            <summary>
            For a given <see cref="T:Microsoft.CodeAnalysis.Compilation"/>, maps from an interface (from the compilation or one of its dependencies)
            to the set of interfaces in the compilation that derive from it.
            </summary>
            <remarks>
            <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/>s are used instead of <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>s to avoid keeping other compilations alive
            unnecessarily.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder.findImplementingInterfacesPredicate">
            <summary>
            A predicate for determining if a class implements an interface. Static to avoid unnecessary allocations.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder.implementingInterfacesCache">
            <summary>
            For a given <see cref="T:Microsoft.CodeAnalysis.Compilation"/>, maps from an interface (from the compilation or one of its dependencies)
            to the set of types in the compilation that implement it.
            </summary>
            <remarks>
            <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/>s are used instead of <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>s to avoid keeping other compilations alive
            unnecessarily.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder.symbolIdComparer">
            <summary>
            Used by the cache to compare <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/>s used as keys in the cache. We make sure to check the casing of names and assembly IDs during the comparison,
            in order to be as discriminating as possible.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder.createSymbolDictionary">
            <summary>
            Used to create a new concurrent <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/> map for a given compilation when needed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder`1.FindDocumentsAsync(Microsoft.CodeAnalysis.Project,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Document},System.Threading.CancellationToken,System.String[])">
            <summary>
            Finds all the documents in the provided project that contain the requested string
            values
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.Finders.IReferenceFinder">
            <summary>
            Extensibility interface to allow extending the IFindReferencesService service.  Implementations
            must be threadsafe as the methods on this interface may be called on multiple threads
            simultaneously.  Implementations should also respect the provided cancellation token and
            should try to cancel themselves quickly when requested.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.Finders.IReferenceFinder.DetermineProjectsToSearchAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)">
            <summary>
            Called by the find references search engine to determine which projects should be
            searched for a given symbol.  The returned projects will then be searched in parallel. If
            the implementation does not care about the provided symbol then null can be returned
            from this method.
            
            Implementations should endeavor to keep the list of returned projects as small as
            possible to keep search time down to a minimum.  Returning the entire list of projects in
            a solution is not recommended (unless, of course, there is reasonable reason to believe
            there are references in every project).
            
            Implementations of this method must be threadsafe.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.Finders.IReferenceFinder.DetermineDocumentsToSearchAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Project,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Document},System.Threading.CancellationToken)">
            <summary>
            Called by the find references search engine to determine which documents in the supplied
            project need to be searched for references.  Only projects returned by
            DetermineProjectsToSearch will be passed to this method.
            
            Implementations should endeavor to keep the list of returned documents as small as
            possible to keep search time down to a minimum.  Returning the entire list of documents
            in a project is not recommended (unless, of course, there is reasonable reason to
            believe there are references in every document).
            
            Implementations of this method must be threadsafe.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.Finders.IReferenceFinder.FindReferencesInDocumentAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Called by the find references search engine to determine the set of reference locations
            in the provided document.  Only documents returned by DetermineDocumentsToSearch will be
            passed to this method. 
            
            Implementations of this method must be threadsafe.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.Finders.IReferenceFinder.DetermineCascadedSymbolsAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)">
            <summary>
            Called by the find references search engine when a new symbol definition is found.
            Implementations can then choose to request more symbols be searched for.  For example, an
            implementation could choose for the find references search engine to cascade to
            constructors when searching for standard types.
            
            Implementations of this method must be threadsafe.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.Finders.ReferenceFinders.DefaultReferenceFinders">
            <summary>
            The list of common reference finders.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.FindReferencesProgress">
            <summary>
            A class that reports the current progress made when finding references to symbols.  
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine.documentToLocationMap">
            <summary>
            Mapping from a document to the list of reference locations found in it.  Kept around so
            we only notify the callback once when a location is found for a reference (in case
            multiple finders find the same reference location for a symbol).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine.foundReferences">
            <summary>
            The resultant collection of all references found per symbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.IFindReferencesProgress">
            <summary>
            Reports the progress of the FindReferences operation.  Note: these methods may be called on
            any thread.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.ReferencedSymbol">
            <summary>
            Represents a single result of the call to the synchronous
            IFindReferencesService.FindReferences method. Finding the references to a symbol will result
            in a set of definitions being returned (containing at least the symbol requested) as well as
            any references to those definitions in the source. Multiple definitions may be found due to
            how C# and VB allow a symbol to be both a definition and a reference at the same time (for
            example, a method which implements an interface method).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.ReferencedSymbol.Definition">
            <summary>
            The symbol definition that these are references to.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.ReferencedSymbol.Locations">
            <summary>
            The set of reference locations in the solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.ReferencedSymbol.GetDebuggerDisplay">
            <remarks>Internal for testing purposes</remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation">
            <summary>
            Information about a reference to a symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation.Document">
            <summary>
            The document that the reference was found in.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation.Alias">
            <summary>
            If the symbol was bound through an alias, then this is the alias that was used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation.Location">
            <summary>
            The actual source location for a given symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation.IsImplicit">
            <summary>
            Indicates if this is an implicit reference to the definition.  i.e. the definition wasn't
            explicitly stated in the source code at this position, but it was still referenced. For
            example, this can happen with special methods like GetEnumerator that are used
            implicitly by a 'for each' statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation.IsCandidateLocation">
            <summary>
            Indicates if this was not an exact reference to a location, but was instead a possible
            location that was found through error tolerance.  For example, a call to a method like
            "Foo()" could show up as an error tolerance location to a method "Foo(int i)" if no
            actual "Foo()" method existed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo">
            <summary>
            Contains information about a call from one symbol to another.  The symbol making the call is
            stored in CallingSymbol and the symbol that the call was made to is stored in CalledSymbol.
            Whether or not the call is direct or indirect is also stored.  A direct call is a call that
            does not go through any other symbols in the inheritance hierarchy of CalledSymbol, while an
            indirect call does go through the inheritance hierarchy.  For example, calls through a base
            member that this symbol overrides, or through an interface member that this symbol
            implements will be considered 'indirect'. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo.CallingSymbol">
            <summary>
            The symbol that is calling the symbol being called.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo.Locations">
            <summary>
            The locations inside the calling symbol where the called symbol is referenced.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo.CalledSymbol">
            <summary>
            The symbol being called.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo.IsDirect">
            <summary>
            True if the CallingSymbol is directly calling CalledSymbol.  False if it is calling a
            symbol in the inheritance hierarchy of the CalledSymbol.  For example, if the called
            symbol is a class method, then an indirect call might be through an interface method that
            the class method implements.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSymbolAtPosition(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.Workspace,System.Threading.CancellationToken)">
            <summary>
            Finds the symbol that is associated with a position in the text of a document.
            </summary>
            <param name="semanticModel">The semantic model associated with the document.</param>
            <param name="position">The character position within the document.</param>
            <param name="workspace">A workspace to provide context.</param>
            <param name="cancellationToken">A CancellationToken.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDefinitionAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Finds the definition symbol declared in source code for a corresponding reference symbol. 
            Returns null if no such symbol can be found in the specified solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSimilarSymbols``1(``0,Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken)">
            <summary>
            Finds symbols in the given compilation that are similar to the specified symbol.
            
            A found symbol may be the exact same symbol instance if the compilation is the origin of the specified symbol, 
            or it may be a different symbol instance if the compilation is not the originating compilation.
            
            Multiple symbols may be returned if there are ambiguous matches.
            No symbols may be returned if the compilation does not define or have access to a similar symbol.
            </summary>
            <param name="symbol">The symbol to find corresponding matches for.</param>
            <param name="compilation">A compilation to find the corresponding symbol within. The complilation may or may not be the origin of the symbol.</param>
            <param name="cancellationToken">A CancellationToken.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindDeclarationsAsync(Microsoft.CodeAnalysis.Project,System.String,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Find the declared symbols from either source, referenced projects or metadata assemblies with the specified name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.TranslateNamespaces(System.Collections.Generic.List{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Makes certain all namespace symbols returned by API are from the compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDeclarationsAsync(Microsoft.CodeAnalysis.Solution,System.String,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Find the symbols for declarations made in source with the specified name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDeclarationsAsync(Microsoft.CodeAnalysis.Project,System.String,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Find the symbols for declarations made in source with the specified name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDeclarationsAsync(Microsoft.CodeAnalysis.Solution,System.Func{System.String,System.Boolean},System.Threading.CancellationToken)">
            <summary>
            Find the symbols for declarations made in source with a matching name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDeclarationsAsync(Microsoft.CodeAnalysis.Project,System.Func{System.String,System.Boolean},System.Threading.CancellationToken)">
            <summary>
            Find the symbols for declarations made in source with a matching name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindOverridesAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)">
            <summary>
            Find symbols for members that override the specified member symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindImplementedInterfaceMembersAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)">
            <summary>
            Find symbols for declarations that implement members of the specified interface symbol
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindImplementationsAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)">
            <summary>
            Finds the symbols that implement an interface or interface member.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindCallersAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Finds all the callers of a specified symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindCallersAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Document},System.Threading.CancellationToken)">
            <summary>
            Finds all the callers of a specified symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindReferencesAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Finds all references to a symbol throughout a solution
            </summary>
            <param name="symbol">The symbol to find references to.</param>
            <param name="solution">The solution to find references within.</param>
            <param name="cancellationToken">A cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindReferencesAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Document},System.Threading.CancellationToken)">
            <summary>
            Finds all references to a symbol throughout a solution
            </summary>
            <param name="symbol">The symbol to find references to.</param>
            <param name="solution">The solution to find references within.</param>
            <param name="documents">A set of documents to be searched. If documents is null, then that means "all documents".</param>
            <param name="cancellationToken">A cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindReferencesAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.FindSymbols.IFindReferencesProgress,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Document},System.Threading.CancellationToken)">
            <summary>
            Finds all references to a symbol throughout a solution
            </summary>
            <param name="symbol">The symbol to find references to.</param>
            <param name="solution">The solution to find references within.</param>
            <param name="progress">An optional progress object that will receive progress
            information as the search is undertaken.</param>
            <param name="documents">An optional set of documents to be searched. If documents is null, then that means "all documents".</param>
            <param name="cancellationToken">An optional cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.Find(Microsoft.CodeAnalysis.IAssemblySymbol,System.String,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Get all symbols that have a name matching the specified name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.FindNodes(System.String,System.StringComparer)">
            <summary>
            Gets all the node indices with matching names.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.Search(Microsoft.CodeAnalysis.IAssemblySymbol,System.Func{System.String,System.Boolean},System.Threading.CancellationToken)">
            <summary>
            Get all symbols that have a matching name as determined by the predicate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.GetInfoForProjectAsync(Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <summary>
            this gives you SymbolTreeInfo for a project
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.GetInfoForAssemblyAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.IAssemblySymbol,System.String,System.Threading.CancellationToken)">
            <summary>
            this gives you SymbolTreeInfo for a metadata
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.Node">
            <summary>
            A node represents a single unique name in a dotted-name tree.
            Uniqueness is always case sensitive.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.LoadOrCreateAsync(Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <summary>
            this is for a project in a solution
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.LoadOrCreateAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.IAssemblySymbol,System.String,System.Threading.CancellationToken)">
            <summary>
            this is for a metadata reference in a solution
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeContextInfo.cache">
            <summary>
            hold context info in memory. since context info is quite small (less than 30 bytes per a document),
            holding this in memory should be fine.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIdentifierInfo.cache">
            <summary>
            in memory cache will hold onto any info related to opened documents in primary branch or all documents in forked branch
            
            this is not snapshot based so multiple versions of snapshots can re-use same data as long as it is relevant.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIdentifierInfo.ProbablyContainsIdentifier(System.String)">
            <summary>
            Returns true when the identifier is probably (but not guaranteed) to be within the
            syntax tree.  Returns false when the identifier is guaranteed to not be within the the
            syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIdentifierInfo.ProbablyContainsEscapedIdentifier(System.String)">
            <summary>
            Returns true when the identifier is probably (but not guaranteed) escaped within the
            text of the syntax tree.  Returns false when the identifier is guaranteed to not be
            escaped within the the text of the syntax tree.  An identifier that is not escaped within
            the text can be found by searching the text directly.  An identifier that is escaped can
            only be found by parsing the text and syntactically interpreting any escaping
            mechanisms found in the language ("\uXXXX" or "@XXXX" in C# or "[XXXX]" in Visual
            Basic).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeInfo.identifierSnapshotCache">
            <summary>
            snapshot based cache to guarantee same info is returned without re-calculating for same solution snapshot.
            since document will be re-created per new solution, this should go away as soon as there is any change on workspace.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.FormattingContext">
            <summary>
            this class maintain contextual information such as 
            indentation of current position, based token to follow in current position and etc.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.FormattingContext.AnchorData">
            <summary>
            data that will be used in an interval tree related to Anchor.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.FormattingContext.IndentationData">
            <summary>
            data that will be used in an interval tree related to indentation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.SuppressSpacingData">
            <summary>
            data that will be used in an interval tree related to suppressing spacing operations.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.SuppressWrappingData">
            <summary>
            data that will be used in an interval tree related to suppressing wrapping operations.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.ContextIntervalTree`1">
            <summary>
            a tweaked version of our interval tree to meet the formatting engine's need
            
            it now has an ability to return a smallest span that contains a position rather than
            all Intersecting or overlapping spans
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractAggregatedFormattingResult.Rewriter(System.Collections.Generic.Dictionary{Roslyn.Utilities.ValueTuple{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken},Microsoft.CodeAnalysis.Formatting.TriviaData},System.Threading.CancellationToken)">
            <summary>
            rewrite the node with the given trivia information in the map
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractFormatEngine.FormatSummary">
            <summary>
            return summary for current formatting work
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.AbstractFormatEngine.OperationApplier">
            <summary>
            this actually applies formatting operations to trivia between two tokens
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.AbstractFormattingResult.FormattedSpan">
            <summary>
            span in the tree to format
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractFormattingResult.Rewriter(System.Collections.Generic.Dictionary{Roslyn.Utilities.ValueTuple{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken},Microsoft.CodeAnalysis.Formatting.TriviaData},System.Threading.CancellationToken)">
            <summary>
            rewrite the tree info root node with the trivia information in the map
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.AbstractTriviaDataFactory.Whitespace">
            <summary>
            represents a general trivia between two tokens. slightly more expensive than others since it
            needs to calculate stuff unlike other cases
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.NodeOperations">
            <summary>
            this collector gathers formatting operations that are based on a node
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.OperationCache`1">
            <summary>
            a delegate cache for a continuation style chaining
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.TokenData">
            <summary>
            it represents a token that is inside of token stream not also outside of token stream
            
            it uses an index to navigate previous and after tokens in the stream to make navigation faster. and regular
            Previous/NextToken for tokens outside of the stream.
            
            this object is supposed to be live very short but created a lot of time. that is why it is struct. 
            (same reason why SyntaxToken is struct - to reduce heap allocation)
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.TokenPairWithOperations">
            <summary>
            it holds onto space and wrapping operation need to run between two tokens.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.TokenStream">
            <summary>
            This class takes care of tokens consumed in the formatting engine.
            
            It will maintain information changed compared to original token information. and answers
            information about tokens.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.TokenStream.Changes">
            <summary>
            thread-safe collection that holds onto changes
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.TokenStream.GetColumn(Microsoft.CodeAnalysis.Formatting.TokenData,System.Func{Microsoft.CodeAnalysis.Formatting.TokenData,Microsoft.CodeAnalysis.Formatting.TokenData,Microsoft.CodeAnalysis.Formatting.TriviaData})">
            <summary>
            Get column of the token 
            * column means text position on a line where all tabs are converted to spaces that first position on a line becomes 0
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.TreeData">
            <summary>
            this provides information about the syntax tree formatting service is formatting.
            this provides necessary abstraction between different kinds of syntax trees so that ones that contain
            actual text or cache can answer queries more efficiently.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.TriviaData">
            <summary>
            it holds onto trivia information between two tokens
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Formatter">
            <summary>
            Formats whitespace in documents or syntax trees.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Formatter.Annotation">
            <summary>
            The annotation used to mark portions of a syntax tree to be formatted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.GetDefaultFormattingRules(Microsoft.CodeAnalysis.Document)">
            <summary>
            Gets the formatting rules that would be applied if left unspecified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.GetDefaultFormattingRules(Microsoft.CodeAnalysis.Workspace,System.String)">
            <summary>
            Gets the formatting rules that would be applied if left unspecified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.FormatAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace in a document.
            </summary>
            <param name="document">The document to format.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the document's workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The formatted document.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.FormatAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace in an area of a document corresponding to a text span.
            </summary>
            <param name="document">The document to format.</param>
            <param name="span">The span of the document's text to format.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the document's workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The formatted document.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.FormatAsync(Microsoft.CodeAnalysis.Document,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace in areas of a document corresponding to multiple non-overlapping spans.
            </summary>
            <param name="document">The document to format.</param>
            <param name="spans">The spans of the document's text to format.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the document's workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The formatted document.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.FormatAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxAnnotation,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace in areas of a document corresponding to annotated nodes.
            </summary>
            <param name="document">The document to format.</param>
            <param name="annotation">The annotation used to find on nodes to identify spans to format.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the document's workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The formatted document.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.Format(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxAnnotation,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace in areas of a syntax tree corresponding to annotated nodes.
            </summary>
            <param name="node">The root node of a syntax tree to format.</param>
            <param name="annotation">The annotation used to find nodes to identify spans to format.</param>
            <param name="workspace">A workspace used to give the formatting context.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The formatted tree's root node.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.Format(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace of a syntax tree.
            </summary>
            <param name="node">The root node of a syntax tree to format.</param>
            <param name="workspace">A workspace used to give the formatting context.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The formatted tree's root node.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.Format(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace in areas of a syntax tree identified by a span.
            </summary>
            <param name="node">The root node of a syntax tree to format.</param>
            <param name="span">The span within the node's full span to format.</param>
            <param name="workspace">A workspace used to give the formatting context.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The formatted tree's root node.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.Format(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace in areas of a syntax tree identified by multiple non-overlapping spans.
            </summary>
            <param name="node">The root node of a syntax tree to format.</param>
            <param name="spans">The spans within the node's full span to format.</param>
            <param name="workspace">A workspace used to give the formatting context.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The formatted tree's root node.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.IFormattingResult">
            <summary>
            Contains changes that can be either applied to different targets such as a buffer or a tree
            or examined to be used in other places such as quick fix.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule">
            <summary>
            base IFormattingRule implementation that users can override to provide
            their own functionality
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.ExportFormattingRule">
            <summary>
            Specifies the exact type of the formatting rule exported
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.IFormattingRule">
            <summary>
            Provide a custom formatting operation provider that can intercept/filter/replace default formatting operations.
            </summary>
            <remarks>All methods defined in this interface can be called concurrently. Must be thread-safe.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.IFormattingRule.AddSuppressOperations(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.SuppressOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Options.OptionSet,Microsoft.CodeAnalysis.Formatting.Rules.NextAction{Microsoft.CodeAnalysis.Formatting.Rules.SuppressOperation})">
            <summary>
            Returns SuppressWrappingIfOnSingleLineOperations under a node either by itself or by
            filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.IFormattingRule.AddAnchorIndentationOperations(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.AnchorIndentationOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Options.OptionSet,Microsoft.CodeAnalysis.Formatting.Rules.NextAction{Microsoft.CodeAnalysis.Formatting.Rules.AnchorIndentationOperation})">
            <summary>
            returns AnchorIndentationOperations under a node either by itself or by filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.IFormattingRule.AddIndentBlockOperations(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Options.OptionSet,Microsoft.CodeAnalysis.Formatting.Rules.NextAction{Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation})">
            <summary>
            returns IndentBlockOperations under a node either by itself or by filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.IFormattingRule.AddAlignTokensOperations(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Options.OptionSet,Microsoft.CodeAnalysis.Formatting.Rules.NextAction{Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOperation})">
            <summary>
            returns AlignTokensOperations under a node either by itself or by filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.IFormattingRule.GetAdjustNewLinesOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Options.OptionSet,Microsoft.CodeAnalysis.Formatting.Rules.NextOperation{Microsoft.CodeAnalysis.Formatting.Rules.AdjustNewLinesOperation})">
            <summary>
            returns AdjustNewLinesOperation between two tokens either by itself or by filtering/replacing a operation returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.IFormattingRule.GetAdjustSpacesOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Options.OptionSet,Microsoft.CodeAnalysis.Formatting.Rules.NextOperation{Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOperation})">
            <summary>
            returns AdjustSpacesOperation between two tokens either by itself or by filtering/replacing a operation returned by NextOperation
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.IOperationHolder`1">
            <summary>
            a delegate cache for a continuation style chaining
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.NextAction`1">
            <summary>
            Represents a next operation to run in a continuation style chaining.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.NextOperation`1">
            <summary>
            Represents a next operation to run in a continuation style chaining.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AdjustNewLinesOperation">
            <summary>
            indicate how many lines are needed between two tokens
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AdjustNewLinesOption">
            <summary>
            Options for AdjustNewLinesOperation.
            
            PreserveLines means the operation will leave lineBreaks as it is if original lineBreaks are
            equal or greater than given lineBreaks
            
            ForceLines means the operation will force existing lineBreaks to the given lineBreaks.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOperation">
            <summary>
            indicate how many spaces are needed between two spaces
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption">
            <summary>
            Options for AdjustSpacesOperation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption.PreserveSpaces">
            <summary>
            Preserve spaces as it is
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption.DefaultSpacesIfOnSingleLine">
            <summary>
            DefaultSpacesIfOnSingleLine means a default space operation created by the formatting
            engine by itself. It has its own option kind to indicates that this is an operation
            generated by the engine itself. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption.ForceSpacesIfOnSingleLine">
            <summary>
            ForceSpaceIfOnSingleLine means forcing the specified spaces between two tokens if two
            tokens are on a single line. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption.ForceSpaces">
            <summary>
            ForceSpaces means forcing the specified spaces regardless of positions of two tokens.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption.DynamicSpaceToIndentationIfOnSingleLine">
            <summary>
            If two tokens are on a single line, second token will be placed at current indentation if possible
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOperation">
            <summary>
            align first tokens on lines among the given tokens to the base token
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOption">
            <summary>
            option to control AlignTokensOperation behavior
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AnchorIndentationOperation">
            <summary>
            preserve relative spaces between anchor token and first tokens on lines within the given text span 
            as long as it doesn't have explicit line operations associated with them
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateAnchorIndentationOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            create anchor indentation region around start and end token
            start token will act as anchor token and right after anchor token to end of end token will become anchor region
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateAnchorIndentationOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            create anchor indentation region more explicitly by providing all necessary information.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateSuppressOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Formatting.Rules.SuppressOption)">
            <summary>
            create suppress region around start and end token
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateSuppressOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Formatting.Rules.SuppressOption)">
            <summary>
            create suppress region around the given text span
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateIndentBlockOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Int32,Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption)">
            <summary>
            create indent block region around the start and end token with the given indentation delta added to the existing indentation at the position of the start token
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateIndentBlockOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Text.TextSpan,System.Int32,Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption)">
            <summary>
            create indent block region around the given text span with the given indentation delta added to the existing indentation at the position of the start token
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateRelativeIndentBlockOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Int32,Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption)">
            <summary>
            create indent block region around the start and end token with the given indentation delta added to the column of the base token
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateRelativeIndentBlockOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Text.TextSpan,System.Int32,Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption)">
            <summary>
            create indent block region around the given text span with the given indentation delta added to the column of the base token
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateAlignTokensOperation(Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOption)">
            <summary>
            instruct the engine to try to align first tokens on the lines among the given tokens to be aligned to the base token
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateAdjustNewLinesOperation(System.Int32,Microsoft.CodeAnalysis.Formatting.Rules.AdjustNewLinesOption)">
            <summary>
            instruct the engine to try to put the give lines between two tokens
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateAdjustSpacesOperation(System.Int32,Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption)">
            <summary>
            instruct the engine to try to put the given spaces between two tokens
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.GetSuppressOperations(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Formatting.Rules.IFormattingRule},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            return SuppressOperation for the node provided by the given formatting rules
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.GetAnchorIndentationOperations(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Formatting.Rules.IFormattingRule},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            return AnchorIndentationOperation for the node provided by the given formatting rules
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.GetIndentBlockOperations(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Formatting.Rules.IFormattingRule},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            return IndentBlockOperation for the node provided by the given formatting rules
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.GetAlignTokensOperations(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Formatting.Rules.IFormattingRule},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            return AlignTokensOperation for the node provided by the given formatting rules
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.GetAdjustNewLinesOperation(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Formatting.Rules.IFormattingRule},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            return AdjustNewLinesOperation for the node provided by the given formatting rules
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.GetAdjustSpacesOperation(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Formatting.Rules.IFormattingRule},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            return AdjustSpacesOperation for the node provided by the given formatting rules
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation">
            <summary>
            set indentation level for the given text span. it can be relative, absolute or dependent to other tokens
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption">
            <summary>
            Options for IndentBlockOperation
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption.RelativeToFirstTokenOnBaseTokenLine">
            <summary>
            This indentation will be a delta to the first token in the line in which the base token is present
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption.RelativePosition">
            <summary>
            IndentationDeltaOrPosition will be interpreted as delta of its enclosing indentation
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption.AbsolutePosition">
            <summary>
            IndentationDeltaOrPosition will be interpreted as absolute position
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption.RelativePositionMask">
            <summary>
            Mask for relative position options
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption.PositionMask">
            <summary>
            Mask for position options
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.SuppressOperation">
            <summary>
            suppress formatting operations within the given text span
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.SuppressOption">
            <summary>
            Options for SuppressOperation
            
            NoWrappingIfOnSingleLine means no wrapping if given tokens are on same line
            NoWrapping means no wrapping regardless of relative positions of two tokens
            NoSpacing means no spacing regardless of relative positions of two tokens
            
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.TaskExecutor.ConcurrentExecutor">
            <summary>
            concurrent task executor
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.TaskExecutor.SynchronousExecutor">
            <summary>
            synchronous executor
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter`1.#cctor">
            <summary>
            set up space string caches
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter`1.Formatter`1">
            <summary>
            format the trivia at the line column and put changes to the changes
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter`1.WhitespaceAppender`1">
            <summary>
            create whitespace for the delta at the line column and put changes to the changes
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter`1.Succeeded">
            <summary>
            return whether this formatting succeeded or not
            for example, if there is skipped tokens in one of trivia between tokens
            we consider formatting this region is failed
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter`1.IsWhitespace(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            check whether given trivia is whitespace trivia or not
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter`1.IsEndOfLine(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            check whether given trivia is end of line trivia or not
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter`1.IsNullOrWhitespace(System.String)">
            <summary>
            check whether given string is either null or whitespace
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter`1.IsWhitespace(System.Char)">
            <summary>
            check whether given char is whitespace
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter`1.IsNewLine(System.Char)">
            <summary>
            check whether given char is new line char
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter`1.Convert(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            convert common syntax trivia to SyntaxTrivia
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter`1.CreateWhitespace(System.String)">
            <summary>
            create whitespace trivia
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter`1.CreateEndOfLine">
            <summary>
            create end of line trivia
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter`1.GetLineColumnRuleBetween(Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.Formatting.LineColumnDelta,Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            return line column rule for the given two trivia
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter`1.Format(Microsoft.CodeAnalysis.Formatting.LineColumn,Microsoft.CodeAnalysis.SyntaxTrivia,System.Collections.Generic.List{Microsoft.CodeAnalysis.SyntaxTrivia},System.Threading.CancellationToken)">
            <summary>
            format the given trivia at the line column position and put result to the changes list
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter`1.Format(Microsoft.CodeAnalysis.Formatting.LineColumn,Microsoft.CodeAnalysis.SyntaxTrivia,System.Collections.Generic.List{Microsoft.CodeAnalysis.Text.TextChange},System.Threading.CancellationToken)">
            <summary>
            format the given trivia at the line column position and put text change result to the changes list
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter`1.GetOverallLineColumnRuleBetween(Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.Formatting.LineColumnDelta,Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            get line column rule between two trivia
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter`1.GetTokensAtEdgeOfStructureTrivia(Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.SyntaxToken@)">
            <summary>
            if the given trivia is the very first or the last trivia between two normal tokens and 
            if the trivia is structured trivia, get one token that belongs to the structured trivia and one belongs to the normal token stream
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter`1.ContainsOnlyWhitespace(System.Int32,System.Int32)">
            <summary>
            check whether string between start and end position only contains whitespace
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter`1.FirstLineBlank">
            <summary>
            check whether first line between two tokens contains only whitespace
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter`1.GetTrailingLinesAtEndOfTrivia1(Microsoft.CodeAnalysis.Formatting.LineColumn)">
            <summary>
            return 0 or 1 based on line column of the trivia1's end point
            this is based on our structured trivia's implementation detail that some structured trivia can have
            one new line at the end of the trivia
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IOrderableMetadata">
            <summary>
            This interface exists purely to enable some shared code that operates over orderable metadata.
            This interface should not be used directly with MEF, used OrderableMetadata instead.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.ILanguagesMetadata">
            <summary>
            This interface is provided purely to enable some shared logic that handles multiple kinds of 
            metadata that share the Languages property. It should not be used to find exports via MEF,
            use LanguageMetadata instead.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer">
            <summary>
            The layer of an exported service.  
            
            If there are multiple definitions of a service, the <see cref="T:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer"/> is used to determine which is used.
            
            Editor overrides Default
            Host overrides Editor and Default
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceAttribute">
            <summary>
            Use this attribute to declare a <see cref="T:Microsoft.CodeAnalysis.Host.ILanguageService"/> implementation for inclusion in a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.MefHostServices"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceAttribute.ServiceType">
            <summary>
            The assembly qualified name of the service's type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceAttribute.Language">
            <summary>
            The language that the service is target for; LanguageNames.CSharp, etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceAttribute.Layer">
            <summary>
            The layer that the service is specified for; ServiceLayer.Default, etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceAttribute.#ctor(System.Type,System.String,System.String)">
            <summary>
            Declares a <see cref="T:Microsoft.CodeAnalysis.Host.ILanguageService"/> implementation for inclusion in a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.MefHostServices"/>.
            </summary>
            <param name="type">The type that will be used to retrieve the service from a <see cref="T:Microsoft.CodeAnalysis.Host.HostLanguageServices"/>.</param>
            <param name="language">The language that the service is target for; LanguageNames.CSharp, etc.</param>
            <param name="layer">The layer that the service is specified for; ServiceLayer.Default, etc.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceFactoryAttribute">
            <summary>
            Use this attribute to declare a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.ILanguageServiceFactory"/> implementation for inclusion in a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.MefHostServices"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceFactoryAttribute.ServiceType">
            <summary>
            The assembly qualified name of the service's type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceFactoryAttribute.Language">
            <summary>
            The language that the service is target for; LanguageNames.CSharp, etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceFactoryAttribute.Layer">
            <summary>
            The layer that the service is specified for; ServiceLayer.Default, etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceFactoryAttribute.#ctor(System.Type,System.String,System.String)">
            <summary>
            Declares a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.ILanguageServiceFactory"/> implementation for inclusion in a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.MefHostServices"/>.
            </summary>
            <param name="type">The type that will be used to retrieve the service from a <see cref="T:Microsoft.CodeAnalysis.Host.HostLanguageServices"/>.</param>
            <param name="language">The language that the service is target for; LanguageNames.CSharp, etc.</param>
            <param name="layer">The layer that the service is specified for; ServiceLayer.Default, etc.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.ILanguageMetadata">
            <summary>
            This interface is provided purely to enable some shared logic that handles multiple kinds of 
            metadata that share the Language property. It should not be used to find exports via MEF,
            use LanguageMetadata instead.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.ILanguageServiceFactory">
            <summary>
            A factory that creates instances of a specific <see cref="T:Microsoft.CodeAnalysis.Host.ILanguageService"/>.
            
            Implement a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.ILanguageServiceFactory"/> when you want to provide <see cref="T:Microsoft.CodeAnalysis.Host.ILanguageService"/> instances that use other services.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.ILanguageServiceFactory.CreateLanguageService(Microsoft.CodeAnalysis.Host.HostLanguageServices)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Host.ILanguageService"/> instance.
            </summary>
            <param name="languageServices">The <see cref="T:Microsoft.CodeAnalysis.Host.HostLanguageServices"/> that can be used to access other services.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.LanguageMetadata">
            <summary>
            MEF metadata class used to find exports declared for a specific language.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.LanguageServiceMetadata">
            <summary>
            MEF metadata class used for finding <see cref="T:Microsoft.CodeAnalysis.Host.ILanguageService"/> and <see cref="T:Microsoft.CodeAnalysis.Host.Mef.ILanguageServiceFactory"/> exports.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.MefHostServices">
            <summary>
            A class that provides host services via classes instances exported via a MEF composition.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.MefHostServices.CreateWorkspaceServices(Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Host.HostWorkspaceServices"/> associated with the specified workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.MefHostServices.GetExports``2">
            <summary>
            Gets all the MEF exports of the specified type with the specified metadata.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.MefHostServices.GetExports``1">
            <summary>
            Gets all the MEF exports of the specified type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceAttribute">
            <summary>
            Use this attribute to declare a <see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceService"/> implementation for inclusion in a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.MefHostServices"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceAttribute.ServiceType">
            <summary>
            The assembly qualified name of the service's type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceAttribute.Layer">
            <summary>
            The layer that the service is specified for; ServiceLayer.Default, etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceAttribute.#ctor(System.Type,System.String)">
            <summary>
            Declares a <see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceService"/> implementation for inclusion in a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.MefHostServices"/>.
            </summary>
            <param name="serviceType">The type that will be used to retreive the service from a <see cref="T:Microsoft.CodeAnalysis.Host.HostWorkspaceServices"/>.</param>
            <param name="layer">The layer that the service is specified for; ServiceLayer.Default, etc.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceFactoryAttribute">
            <summary>
            Use this attribute to declare a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory"/> implementation for inclusion in a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.MefHostServices"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceFactoryAttribute.ServiceType">
            <summary>
            The assembly qualified name of the service's type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceFactoryAttribute.Layer">
            <summary>
            The layer that the service is specified for; ServiceLayer.Default, etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceFactoryAttribute.#ctor(System.Type,System.String)">
            <summary>
            Declares a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory"/> implementation for inclusion in a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.MefHostServices"/>.
            </summary>
            <param name="serviceType">The type that will be used to retreive the service from a <see cref="T:Microsoft.CodeAnalysis.Host.HostWorkspaceServices"/>.</param>
            <param name="layer">The layer that the service is specified for; ServiceLayer.Default, etc.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory">
            <summary>
            A factory that creates instances of a specific <see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceService"/>.
            
            Implement a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory"/> when you want to provide <see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceService"/> instances that use other services.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory.CreateService(Microsoft.CodeAnalysis.Host.HostWorkspaceServices)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceService"/> instance.
            </summary>
            <param name="workspaceServices">The <see cref="T:Microsoft.CodeAnalysis.Host.HostWorkspaceServices"/> that can be used to access other services.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.WorkspaceServiceMetadata">
            <summary>
            MEF metadata class used for finding <see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceService"/> and <see cref="T:Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory"/> exports.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.AbstractSyntaxTreeFactoryService.AbstractRecoverableSyntaxRoot`1">
            <summary>
            Represents all the state used by a language-specific recoverable syntax tree
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.AbstractSyntaxTreeFactoryService.AbstractRecoverableSyntaxRoot`1.SetContainingTree(Microsoft.CodeAnalysis.Host.IRecoverableSyntaxTree{`0})">
            <summary>
            Called by the constructor the parent tree.
            </summary>
            <remarks>
            This is to address the catch-22 dependency -- a tree needs it's recoverable root
            and vice versa. The dangerous bit is when we call TickleCache because it's the
            first place when this tree gets handed out to another system. We need to make sure
            both this object and the parent tree are fully constructed by that point.</remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.ILanguageService">
            <summary>
            Empty interface just to mark language services.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.ISyntaxTreeFactoryService">
            <summary>
            Factory service for creating syntax trees.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.CostBasedCache`1">
            <summary>
            Cost based cache with elastic upper bound.
            
            This cache has two distinct characteristics where it will try to keep actively 
            referenced entries as long as possible but also tries to keep more data in the cache 
            if there is a sudden flood of data coming in.
            
            The first part is achieved by giving more weight on items that are more frequently
            accessed. But also by gradually retiring them once they are not accessed, it should 
            give space back to newer data.
            
            The second part is achieved by increasing the size of the upper bound of the cache when there is a
            sudden increase in the rate of data coming into the cache.
            
            the size of the upper bound will be decreased to its normal level once those activities have ceased.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.ICompilationCacheService.Primary">
            <summary>
            compilation cache for main branch
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.ICompilationCacheService.Secondary">
            <summary>
            compilation cache for all other branches which could include in progress main branch compilation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.ICompilationCacheService.Clear">
            <summary>
            clear compilation caches belong to this workspace
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IObjectCache`1">
            <summary>
            An object cache controls the lifetime of an object by holding a reference to it,
            keeping the garbage collector from collecting it. 
            
            The cache uses a heuristic to determine how many objects to keep alive, which 
            to evict from the cache and when to evict them. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IObjectCache`1.AddOrAccess(`0,Microsoft.CodeAnalysis.Host.IWeakAction{`0})">
            <summary>
            Add an object to the cache, or notify the cache that the object was recently used.
            </summary>
            <param name="instance">The object to add or notify.</param>
            <param name="evictor">An action to take when the object is evicted.</param>
            <returns>True if the instance was added.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IObjectCache`1.Clear">
            <summary>
            Clear the cache.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IWeakAction`1">
            <summary>
            called when data stored in the cache is evicted.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.RecoverableCachedObjectSource`1">
            <summary>
            This class is a ValueSource that manages storing an item in a cache,
            saving the item's state when it is evicted from the cache and recovering
            it from its saved state when the value source is accessed again.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.RecoverableCachedObjectSource`1.SaveAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Override this to save the state of the instance so it can be recovered.
            This method will only ever be called once.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.RecoverableCachedObjectSource`1.RecoverAsync(System.Threading.CancellationToken)">
            <summary>
            Override this method to implement asynchronous recovery semantics.
            This method may be called multiple times.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.RecoverableCachedObjectSource`1.Recover(System.Threading.CancellationToken)">
            <summary>
            Override this method to implement synchronous recovery semantics.
            This method may be called multiple times.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.HostLanguageServices">
            <summary>
            Per language services provided by the host environment.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.HostLanguageServices.WorkspaceServices">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.Host.HostWorkspaceServices"/> that originated this language service.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.HostLanguageServices.Language">
            <summary>
            The name of the language
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.HostLanguageServices.GetService``1">
            <summary>
            Gets a language specific service provided by the host identified by the service type. 
            If the host does not provide the service, this method returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.HostLanguageServices.CompilationFactory">
            <summary>
            A factory for creating compilations instances.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.HostServices">
            <summary>
            Services provided by the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.HostServices.CreateWorkspaceServices(Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Creates a new workspace service. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.AbstractPersistentStorage.AddRefUnsafe">
            <summary>
            caller should make sure this is called in a thread-safe way
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.AbstractPersistentStorage.ReleaseRefUnsafe">
            <summary>
            caller should make sure this is called in a thread-safe way
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IPersistentStorageService">
            <summary>
            This service allows you to persist information relative to solution, projects and documents.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.PersistentStorageServiceFactory">
            <summary>
            A service that enables storing and retrieving of information associated with solutions,
            projects or documents across runtime sessions.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IWorkspaceTaskScheduler">
            <summary>
            An abstraction for running tasks either in sequence or in parallel.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IWorkspaceTaskScheduler.ScheduleTask(System.Action,System.String,System.Threading.CancellationToken)">
            <summary>
            Execute the task action on a thread owned by a task scheduler.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IWorkspaceTaskScheduler.ScheduleTask``1(System.Func{``0},System.String,System.Threading.CancellationToken)">
            <summary>
            Execute the task function on a thread owned by a task scheduler and return the schedule
            task that can be used to wait for the result.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IWorkspaceTaskScheduler.ScheduleTask(System.Func{System.Threading.Tasks.Task},System.String,System.Threading.CancellationToken)">
            <summary>
            Execute the task function on a thread owned by a task scheduler and return the schedule
            task that can be used to wait for the result.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IWorkspaceTaskScheduler.ScheduleTask``1(System.Func{System.Threading.Tasks.Task{``0}},System.String,System.Threading.CancellationToken)">
            <summary>
            Execute the task function on a thread owned by a task scheduler and return the schedule
            task that can be used to wait for the result.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IWorkspaceTaskSchedulerFactory">
            <summary>
            A factory that creates either sequential or parallel task schedulers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IWorkspaceTaskSchedulerFactory.CreateTaskScheduler(System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a workspace task scheduler that schedules tasks to run in parallel.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IWorkspaceTaskSchedulerFactory.CreateTaskQueue(System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a workspace task scheduler that schedules task to run in sequence.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.ISupportDirectMemoryAccess">
            <summary>
            support direct memory access pointer
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.ITemporaryStorage">
            <summary>
            TemporaryStorage can be used to read and write text to a temporary storage location.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.ITemporaryStorageService">
            <summary>
            This service allows you to access temporary storage.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService">
            <summary>
            Temporarily stores text and streams in memory mapped files.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedFileManager">
            <summary>
            Rather than creating a separate MemoryMappedFile for every string/stream we need to persist,
            use several large MemoryMappedFile 'arenas' that contain multiple buffers each.
            
            Group buffers by size to simplify fragmentation and complexity of this memory management code.
            Currently, anything larger than 256KB will get its own MemoryMappedFile.
            
            When opening Roslyn.sln and doing a full initialization through Solution Navigator, we get
            8000+ requests.  Since the minimum OS allocation for a memory mapped file is rounded up to 
            64KB, this would map ~500MB alone, not counting the additional space needed for files > 64KB.
            Using the strategy below for the same scenario, we create only 90 4MB arenas which hold all but
            104 buffers that are larger than 256KB.  So we avoid creating ~7500 MemoryMappedFile objects
            and save roughly 400MB of fragmentation when compared to the simple one MemoryMappedFile per
            request approach.
            
            The MemoryMappedFileManager, MemoryMappedFileArena, and MemoryMappedInfo classes all
            have very tight coupling in the current implementation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.streamCount">
            <summary>
            ref count of stream given out
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.accessor">
            <summary>
            actual memory accessor that owns the VM
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.CreateReadableStream">
            <summary>
            Caller is responsible for disposing the returned stream.
            multiple call of this will not increase VM.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.CreateWritableStream">
            <summary>
            Caller is responsible for disposing the returned stream.
            multiple call of this will increase VM.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.SharedReadableStream.GetPointer">
            <summary>
            get underlying native memory directly
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.ITextFactoryService">
            <summary>
            A factory for creating SourceText instances.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.HostWorkspaceServices">
            <summary>
            Per workspace services provided by the host environment.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.HostServices">
            <summary>
            The host services this workspace services originated from.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.Workspace">
            <summary>
            The workspace corresponding to this workspace services instantiation
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.PersistentStorage">
            <summary>
            A service for storing information across that can be retrieved in a separate process.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.TemporaryStorage">
            <summary>
            A service for storing information in a temporary location that only lasts for the duration of the process.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.TextFactory">
            <summary>
            A factory that constructs <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.SupportedLanguages">
            <summary>
            A list of language names for supported language services.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.IsSupported(System.String)">
            <summary>
            Returns true if the language is supported.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.GetLanguageServices(System.String)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Host.HostLanguageServices"/> for the language name.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IWorkspaceService">
            <summary>
            Empty interface just to mark workspace services.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServices.ISyntaxVersionLanguageService">
            <summary>
            A service that computes the syntactic version of a syntax tree
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxVersionLanguageService.ComputePublicHash(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Computes a hash corresponding to the public declarations in the syntax tree.
            Interior regions like method bodies, or trivia are not included.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LanguageServices.ISemanticFactsService.SupportsImplicitInterfaceImplementation">
            <summary>
            True if this language supports implementing an interface by signature only. If false,
            implementations must specific explicitly which symbol they're implementing.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LanguageServices.ISemanticFactsService.ExposesAnonymousFunctionParameterNames">
            <summary>
            True if anonymous functions in this language have signatures that include named
            parameters that can be referenced later on when the function is invoked.  Or, if the
            anonymous function is simply a signature that will be assigned to a delegate, and the
            delegate's parameter names are used when invoking.  
            
            For example, in VB one can do this: 
            
            dim v = Sub(x as Integer) Blah()
            v(x:=4)
            
            However, in C# that would need to be:
            
            Action&lt;int&gt; v = (int x) => Blah();
            v(obj:=4)
            
            Note that in VB one can access 'x' outside of the declaration of the anonymous type.
            While in C# 'x' can only be accessed within the anonymous type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISemanticFactsService.IsWrittenTo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            True if a write is performed to the given expression.  Note: reads may also be performed
            to the expression as well.  For example, "++a".  In this expression 'a' is both read from
            and written to.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISemanticFactsService.IsOnlyWrittenTo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            True if a write is performed to the given expression.  Note: unlike IsWrittenTo, this
            will not return true if reads are performed on the expression as well.  For example,
            "++a" will return 'false'.  However, 'a' in "out a" or "a = 1" will return true.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISemanticFactsService.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            return speculative semantic model for supported node. otherwise, it will return null
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISemanticFactsService.GetAliasNameSet(Microsoft.CodeAnalysis.SemanticModel,System.Threading.CancellationToken)">
            <summary>
            get all alias names defined in the semantic model
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISymbolDeclarationService.GetDeclarations(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Given a symbol in source, returns the syntax nodes that compromise its declarations.
            This differs from symbol.Locations in that Locations returns a list of ILocations that
            normally correspond to the name node of the symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService.IsTypeCharacter(System.Char)">
            <summary>
            Returns true if the given character is a character which may be included in an
            identifier to specify the type of a variable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService.GetBindableParent(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Returns the parent node that binds to the symbols that the IDE prefers for features like
            Quick Info and Find All References. For example, if the token is part of the type of
            an object creation, the parenting object creation expression is returned so that binding
            will return constructor symbols.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServices.ITypeInferenceService">
            <summary>
            Helper service for telling you what type can be inferred to be viable in a particular
            location in code.  This is useful for features that are starting from code that doesn't bind,
            but would like to know type that code should be in the location that it can be found in.  For
            example:
            
              int i = Here(); 
            
            If 'Here()' doesn't bind, then this class can be used to say that it is currently in a
            location whose type has been inferred to be 'int' from the surrounding context.  Note: this
            is simply a best effort guess.  'byte/short/etc.' as well as any user convertible types to
            int would also be valid here, however 'int' seems the most reasonable when considering user
            intuition.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.EmptyLogBlock">
            <summary>
            no op log block
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.EmptyLogger">
            <summary>
            a logger that doesn't do anything
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.EtwLogger">
            <summary>
            A logger that publishes events to ETW using an EventSource.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.EtwLogger.RoslynEtwLogBlock">
            <summary>
            This tracks the logged message. On instantiation, it logs 'Started block' with other event data.
            On dispose, it logs 'Ended block' with the same event data so we can track which block started and ended when looking at logs.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.FeatureId">
            <summary>
            Enum to uniquely identify each feature
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.FunctionId">
            <summary>
            Enum to uniquely identify each function location
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.ILogger">
            <summary>
            logger interface actual logger should implements
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.ILogger.IsEnabled(Microsoft.CodeAnalysis.Internal.Log.FeatureId,Microsoft.CodeAnalysis.Internal.Log.FunctionId)">
            <summary>
            answer whether it is enabled or not for the specific feature and function id
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.ILogger.IsVerbose">
            <summary>
            answer whether it is in verbose mode or not
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.ILogger.Log(Microsoft.CodeAnalysis.Internal.Log.FeatureId,Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.String)">
            <summary>
            log a specific event with context message
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.ILogger.LogBlock(Microsoft.CodeAnalysis.Internal.Log.FeatureId,Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.String,System.Int32,System.Threading.CancellationToken)">
            <summary>
            log a start and end pair with context message
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.InteractionClass">
            <summary>
            An interaction class defines how much time is expected to reach a time point, the response 
            time point being the most commonly used. The interaction classes correspond to human perception,
            so, for example, all interactions in the Fast class are perceived as fast and roughly feel like 
            they have the same performance. By defining these interaction classes, we can describe 
            performance using adjectives that have a precise, consistent meaning.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.ITelemetryService">
            <summary>
            Provides a way to log qualitative usage data
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.Logger">
            <summary>
            provide a way to log activities to various back end such as etl, code marker and etc
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.Logger.lastUniqueBlockId">
            <summary>
            next unique block id that will be given to each LogBlock
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.SetLogger(Microsoft.CodeAnalysis.Internal.Log.ILogger)">
            <summary>
            give a way to explicitly set/replace the logger
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.GetLogger">
            <summary>
            ensure we have a logger by putting one from workspace service if one is not there already.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.Log(Microsoft.CodeAnalysis.Internal.Log.FeatureId,Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.String)">
            <summary>
            log a specific event with a simple context message which should be very cheap to create
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.Log(Microsoft.CodeAnalysis.Internal.Log.FeatureId,Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{System.String})">
            <summary>
            log a specific event with a context message that will only be created when it is needed.
            the messageGetter should be cheap to create. in another word, it shouldn't capture any locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.Log``1(Microsoft.CodeAnalysis.Internal.Log.FeatureId,Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,System.String},``0)">
            <summary>
            log a specific event with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.Log``2(Microsoft.CodeAnalysis.Internal.Log.FeatureId,Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,``1,System.String},``0,``1)">
            <summary>
            log a specific event with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.Log``3(Microsoft.CodeAnalysis.Internal.Log.FeatureId,Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,``1,``2,System.String},``0,``1,``2)">
            <summary>
            log a specific event with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.Log``4(Microsoft.CodeAnalysis.Internal.Log.FeatureId,Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,``1,``2,``3,System.String},``0,``1,``2,``3)">
            <summary>
            log a specific event with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.GetNextUniqueBlockId">
            <summary>
            return next unique pair id
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock(Microsoft.CodeAnalysis.Internal.Log.FeatureId,Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Threading.CancellationToken)">
            <summary>
            simplest way to log a start and end pair
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock(Microsoft.CodeAnalysis.Internal.Log.FeatureId,Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.String,System.Threading.CancellationToken)">
            <summary>
            simplest way to log a start and end pair with a simple context message which should be very cheap to create
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock(Microsoft.CodeAnalysis.Internal.Log.FeatureId,Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{System.String},System.Threading.CancellationToken)">
            <summary>
            log a start and end pair with a context message that will only be created when it is needed.
            the messageGetter should be cheap to create. in another word, it shouldn't capture any locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock``1(Microsoft.CodeAnalysis.Internal.Log.FeatureId,Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,System.String},``0,System.Threading.CancellationToken)">
            <summary>
            log a start and end pair with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock``2(Microsoft.CodeAnalysis.Internal.Log.FeatureId,Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,``1,System.String},``0,``1,System.Threading.CancellationToken)">
            <summary>
            log a start and end pair with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock``3(Microsoft.CodeAnalysis.Internal.Log.FeatureId,Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,``1,``2,System.String},``0,``1,``2,System.Threading.CancellationToken)">
            <summary>
            log a start and end pair with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock``4(Microsoft.CodeAnalysis.Internal.Log.FeatureId,Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,``1,``2,``3,System.String},``0,``1,``2,``3,System.Threading.CancellationToken)">
            <summary>
            log a start and end pair with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.RoslynEventSource">
            <summary>
            This EventSource exposes our events to ETW.
            RoslynEventSource GUID is {bf965e67-c7fb-5c5b-d98f-cdf68f8154c2}.
            CodeSense.RoslynEventSource GUID is {2dced975-85dd-59d7-3eba-f83dde58d6e7}.
            
            When updating this class, use the following to also update Main\Source\Test\Performance\Log\RoslynEventSourceParser.cs:
            Main\Tools\Source\TraceParserGen\bin\Debug\TraceParserGen.exe Microsoft.CodeAnalysis.Workspaces.dll -eventsource:RoslynEventSource
            
            Use this command to register the ETW manifest on any machine where you need to decode events in xperf/etlstackbrowse:
            "\\clrmain\tools\managed\etw\eventRegister\bin\Debug\eventRegister.exe" Microsoft.CodeAnalysis.Workspaces.dll
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.TraceLogger">
            <summary>
            Implementation of <see cref="T:Microsoft.CodeAnalysis.Internal.Log.ILogger"/> that produce timing debug output. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.TraceLogger.IsVerbose">
            <summary>
            Trace logger always uses verbose mode.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Notification.GlobalOperationNotificationServiceFactory.NoOpService">
            <summary>
            a service which will never raise start event
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Notification.IGlobalOperationNotificationService.Started">
            <summary>
            raised when global operation is started
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Notification.IGlobalOperationNotificationService.Stopped">
            <summary>
            raised when global operation is stopped
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Notification.IGlobalOperationNotificationService.Start(System.String)">
            <summary>
            start new global operation
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.IOptionService">
            <summary>
            Provides services for reading and writing options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IOptionService.GetOption``1(Microsoft.CodeAnalysis.Options.Option{``0})">
            <summary>
            Gets the current value of the specific option.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IOptionService.GetOption``1(Microsoft.CodeAnalysis.Options.PerLanguageOption{``0},System.String)">
            <summary>
            Gets the current value of the specific option.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IOptionService.GetOption(Microsoft.CodeAnalysis.Options.OptionKey)">
            <summary>
            Gets the current value of the specific option.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IOptionService.GetOptions">
            <summary>
            Fetches an immutable set of all current options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IOptionService.SetOptions(Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            Applies a set of options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IOptionService.GetRegisteredOptions">
            <summary>
            Returns the set of all registered options.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.Option`1">
            <summary>
            An global option. An instance of this class can be used to access an option value from an OptionSet.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.Option`1.Feature">
            <summary>
            Feature this option is associated with.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.Option`1.Name">
            <summary>
            The name of the option.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.Option`1.Type">
            <summary>
            The type of the option value.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.Option`1.DefaultValue">
            <summary>
            The default value of the option.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.OptionSet.GetOption``1(Microsoft.CodeAnalysis.Options.Option{``0})">
            <summary>
            Gets the value of the option.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.OptionSet.GetOption``1(Microsoft.CodeAnalysis.Options.PerLanguageOption{``0},System.String)">
            <summary>
            Gets the value of the option.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.OptionSet.GetOption(Microsoft.CodeAnalysis.Options.OptionKey)">
            <summary>
            Gets the value of the option.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.OptionSet.WithChangedOption``1(Microsoft.CodeAnalysis.Options.Option{``0},``0)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Options.OptionSet" /> that contains the changed value.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.OptionSet.WithChangedOption``1(Microsoft.CodeAnalysis.Options.PerLanguageOption{``0},System.String,``0)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Options.OptionSet" /> that contains the changed value.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.OptionSet.WithChangedOption(Microsoft.CodeAnalysis.Options.OptionKey,System.Object)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Options.OptionSet" /> that contains the changed value.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.OptionSet.GetAccessedOptions">
            <summary>
            Gets a list of all the options that were accessed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.PerLanguageOption`1">
            <summary>
            An option that can be specified once per language.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.PerLanguageOption`1.Feature">
            <summary>
            Feature this option is associated with.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.PerLanguageOption`1.Name">
            <summary>
            The name of the option.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.PerLanguageOption`1.Type">
            <summary>
            The type of the option value.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.PerLanguageOption`1.DefaultValue">
            <summary>
            The default option value.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.Providers.IOptionSerializer">
            <summary>
            Exportable by a host to specify the save and restore behavior for a particular set of
            values.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation">
            <summary>
            This annotation will be used by rename to mark all places where it needs to rename an identifier (token replacement) and where to 
            check if the semantics have been changes (conflict detection).
            </summary>
            <remarks>This annotation should be put on tokens only.</remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.OriginalSpan">
            <summary>
            The span this token occupied in the original syntax tree. Can be used to show e.g. conflicts in the UI.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.IsRenameLocation">
            <summary>
            A flag indicating whether this is a location that needs to be renamed or just tracked for conflicts.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.IsAccessorLocation">
            <summary>
            A flag indicating if this identifier represents an accessor. E.g. get_Foo (of property Foo).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.IsOriginalTextLocation">
            <summary>
            A flag indicating whether the token at this location has the same ValueText then the original name 
            of the symbol that gets renamed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.Suffix">
            <summary>
            When replacing the annotated token this string will be appended to the token's value. This is used when renaming compiler 
            generated types whose names are derived from user given names (e.g. "XEventHandler" for event "X").
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.RenameDeclarationLocationReferences">
            <summary>
            A single dimensional array of annotations to verify after rename.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.IsNamespaceDeclarationReference">
            <summary>
            States if this token is a Namespace Declaration Reference
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.IsInvocationExpression">
            <summary>
            States if this token is annotated as a part of the Invocation Expression that needs to be checked for the Conflicts
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameDeclarationLocationReference">
            <summary>
            This class is used to refer to a Symbol definition which could be in source or metadata
            it has a metadata name.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameDeclarationLocationReference.Name">
            <summary>
            The metadata name for this symbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameDeclarationLocationReference.SymbolLocationsCount">
            <summary>
            Count of symbol location (Partial Types, Constructors, etc).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameDeclarationLocationReference.IsOverriddenFromMetadata">
            <summary>
            A flag indicating that the associated symbol is an override of a symbol from metadata
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictingIdentifierTracker.currentIdentifiersInScope">
            <summary>
            The core data structure of the tracker. This is a dictionary of variable name to the
            current identifier tokens that are declaring variables. This should only ever be updated
            via the AddIdentifier and RemoveIdentifier helpers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolution">
            <summary>
            The result of the conflict engine. Once this object is returned from the engine, it is
            immutable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolution.RelatedLocations">
            <summary>
            The list of all symbol locations that are referenced either by the original symbol or
            the renamed symbol. This includes both resolved and unresolved conflicts.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolution.DocumentIds">
            <summary>
            The list of all document ids of documents that have been touched for this rename operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolution.NewSolution">
            <summary>
            The new workspace snapshot
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolution.OldSolution">
            <summary>
            The base workspace snapshot
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolution.ReplacementTextValid">
            <summary>
            Whether the text that was resolved with was even valid. This may be false if the
            identifier was not valid in some language that was involved in the rename.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolution.ReplacementText">
            <summary>
            The original text that is the rename replacement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.ResolveConflictsAsync(Microsoft.CodeAnalysis.Rename.RenameLocationSet,System.String,System.String,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Performs the renaming of the symbol in the solution, identifies renaming conflicts and automatically resolves them where possible.
            </summary>
            <param name="renameLocationSet">The locations to perform the renaming at.</param>
            <param name="originalText">The original name of the identifier.</param>
            <param name="replacementText">The new name of the identifier</param>
            <param name="optionSet">The option for rename</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>A conflict resolution containing the new solution.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.SymbolsForEnclosingInvocationExpressionWorker(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SemanticModel,System.Threading.CancellationToken)">
            <summary>
            Used to find the symbols associated with the Invocation Expression surrounding the Token
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.AddDeclarationConflictsAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolution,System.Collections.Generic.IDictionary{Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.Location},System.Threading.CancellationToken)">
            <summary>
            Computes an adds conflicts relating to declarations, which are independent of
            location-based checks. Examples of these types of conflicts include renaming a member to
            the same name as another member of a type: binding doesn't change (at least from the
            perspective of find all references), but we still need to track it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.GetSymbolLocationAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            Gives the First Location for a given Symbol by ordering the locations using DocumentId first and Location starting position second
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.Session">
            <summary>
            Helper class to track the state necessary for finding/resolving conflicts in a 
            rename session.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.Session.IdentifyConflictsAsync(System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DocumentId},Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolution)">
            <summary>
            Find conflicts in the new solution 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.Session.GetNodesOrTokensToCheckForConflicts(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the list of the nodes that were annotated for a conflict check 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.Session.FindDocumentsAndPossibleNameConflicts">
            <summary>
            The method determines the set of document that has to be processed for Rename and also gives the possible set of Names
            that has to be checked for conflict
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.ConflictEngine.RelatedLocation">
            <summary>
            Gives information about an identifier span that was affected by Rename (Reference or Non reference)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RelatedLocationType.NoConflict">
            <summary>
            There was no conflict. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RelatedLocationType.ResolvedReferenceConflict">
            <summary>
            A conflict was resolved at a location that references the symbol being renamed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RelatedLocationType.ResolvedNonReferenceConflict">
            <summary>
            A conflict was resolved in a piece of code that does not reference the symbol being
            renamed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RelatedLocationType.PossibilyResolvableConflict">
            <summary>
            There was a conflict that could not be resolved.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RelatedLocationType.UnresolvableConflict">
            <summary>
            These are the conflicts that cannot be resolved. E.g.: Declaration Conflict
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenamedSpansTracker">
            <summary>
            Tracks the text spans that were modified as part of a rename operation
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenamedSpansTracker.ComplexifiedSpan">
            <summary>
            Information to track deltas of complexified spans
            
            Consider the following example where renaming a->b causes a conflict 
            and Foo is an extension method:
                "a.Foo(a)" is rewritten to "NS1.NS2.Foo(NS3.a, NS3.a)"
            
            The OriginalSpan is the span of "a.Foo(a)"
            
            The NewSpan is the span of "NS1.NS2.Foo(NS3.a, NS3.a)"
            
            The ModifiedSubSpans are the pairs of complexified symbols sorted 
            according to their order in the original source code span:
                "a", "NS3.a"
                "Foo", "NS1.NS2.Foo"
                "a", "NS3.a"
            
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService.AnnotateAndRename(Microsoft.CodeAnalysis.Rename.RenameRewriterParameters)">
            <summary>
            This method annotates the given syntax tree with all the locations that need to be checked for conflict
            after the rename operation.  It also renames all the reference locations and expands any conflict locations.
            </summary>
            <param name="parameters">The options describing this rename operation</param>
            <returns>The root of the annotated tree.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService.TryAddPossibleNameConflicts(Microsoft.CodeAnalysis.ISymbol,System.String,System.Collections.Generic.ICollection{System.String})">
            <summary>
            Based on the kind of the symbol and the new name, this function determines possible conflicting names that
            should be tracked for semantic changes during rename.
            </summary>
            <param name="symbol">The symbol that gets renamed.</param>
            <param name="newName">The new name for the symbol.</param>
            <param name="possibleNameConflicts">List where possible conflicting names will be added to.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService.ComputeDeclarationConflictsAsync(System.String,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Solution,System.Collections.Generic.IDictionary{Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.Location},System.Threading.CancellationToken)">
            <summary>
            Identifies the conflicts caused by the new declaration created during rename.
            </summary>
            <param name="replacementText">The replacementText as given from the user.</param>
            <param name="renamedSymbol">The new symbol (after rename).</param>
            <param name="renameSymbol">The original symbol that got renamed.</param>
            <param name="referencedSymbols">All referenced symbols that are part of this rename session.</param>
            <param name="baseSolution">The original solution when rename started.</param>
            <param name="newSolution">The resulting solution after rename.</param>
            <param name="reverseMappedLocations">A mapping from new to old locations.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>All locations where conflicts were caused because the new declaration.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService.ComputeImplicitReferenceConflicts(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation},System.Threading.CancellationToken)">
            <summary>
            Identifies the conflicts caused by implicitly referencing the renamed symbol.
            </summary>
            <param name="renameSymbol">The original symbol that got renamed.</param>
            <param name="renamedSymbol">The new symbol (after rename).</param>
            <param name="implicitReferenceLocations">All implicit reference locations.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>A list of implicit conflicts.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService.ComputePossibleImplicitUsageConflicts(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Location,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Identifies the conflicts caused by implicitly referencing the renamed symbol.
            </summary>
            <param name="renamedSymbol">The new symbol (after rename).</param>
            <param name="semanticModel">The SemanticModel of the document in the new solution containing the renamedSymbol</param>
            <param name="originalDeclarationLocation">The location of the renamedSymbol in the old solution</param>
            <param name="newDeclarationLocationStartingPosition">The starting position of the renamedSymbol in the new solution</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>A list of implicit conflicts.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService.LocalVariableConflict(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Identifies potential Conflicts into the inner scope locals. This may give false positives.
            </summary>
            <param name="token">The Token that may introduce errors else where</param>
            <returns>Returns if there is a potential conflict</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService.IsIdentifierValid(System.String,Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService)">
            <summary>
            Used to find if the replacement Identifier is valid
            </summary>
            <param name="replacementText"></param>
            <param name="syntaxFactsService"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService.GetExpansionTargetForLocation(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Gets the top most enclosing statement as target to call MakeExplicit on.
            It's either the enclosing statement, or if this statement is inside of a lambda expression, the enclosing
            statement of this lambda.
            </summary>
            <param name="token">The token to get the complexification target for.</param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.RenameEntityKind.BaseSymbol">
            <summary>
            mentions that the result is for the base symbol of the rename
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.RenameEntityKind.OverloadedSymbols">
            <summary>
            mentions that the result is for the overloaded symbols of the rename
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.RenameLocationSet">
            <summary>
            A helper class that contains some of the methods and filters that must be used when
            processing the raw results from the FindReferences API.
            </summary>
            <summary>
            Holds the ILocations of a symbol that should be renamed, along with the symbol and Solution
            for the set.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.RenameLocationSet.ReferenceProcessing.GetRenamableSymbolAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Given a symbol in a document, returns the "right" symbol that should be renamed in
            the case the name binds to things like aliases _and_ the underlying type at once.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.RenameLocationSet.ReferenceProcessing.FindDefinitionSymbolAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Given a symbol, finds the symbol that actually defines the name that we're using.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.RenameLocationSet.ReferenceProcessing.GetRenamableDefinitionLocationsAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Given a ISymbol, returns the renamable locations for a given symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.RenameLocationSet.FindAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Find the locations that need to be renamed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SemanticModelWorkspaceService.ISemanticModelService">
            <summary>
            a service that provides a semantic model that will re-use last known compilation if
            semantic version hasn't changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModelWorkspaceService.ISemanticModelService.GetSemanticModelForNodeAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Don't call this directly. use Document extension method GetSemanticModelForNodeAsync or GetSemanticModelForSpanAsync instead.
            
            see the descriptions on the extension methods
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Collections.IntervalTree`1">
            <summary>
            An interval tree represents an ordered tree data structure to store intervals of the form [start, end).  It
            allows you to efficiently find all intervals that intersect or overlap a provided interval.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.CommonSyntaxNodeExtensions.IsChildNode``1(Microsoft.CodeAnalysis.SyntaxNode,System.Func{``0,Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Returns true if is a given token is a child token of of a certain type of parent node.
            </summary>
            <typeparam name="TParent">The type of the parent node.</typeparam>
            <param name="node">The node that we are testing.</param>
            <param name="childGetter">A function that, when given the parent node, returns the child token we are interested in.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.CommonSyntaxNodeExtensions.IsFoundUnder``1(Microsoft.CodeAnalysis.SyntaxNode,System.Func{``0,Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Returns true if this node is found underneath the specified child in the given parent.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.CommonSyntaxNodeExtensions.AddAnnotations(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{System.Tuple{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxAnnotation}})">
            <summary>
            create a new root node from the given root after adding annotations to the tokens
            
            tokens should belong to the given root
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.CommonSyntaxNodeExtensions.AddAnnotations(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{System.Tuple{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxAnnotation}})">
            <summary>
            create a new root node from the given root after adding annotations to the nodes
            
            nodes should belong to the given root
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.CommonSyntaxNodeExtensions.ReplaceNodesAsync``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Func{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken,System.Threading.Tasks.Task{Microsoft.CodeAnalysis.SyntaxNode}},System.Threading.CancellationToken)">
            <summary>
            Creates a new tree of nodes from the existing tree with the specified old nodes replaced with a newly computed nodes.
            </summary>
            <param name="root">The root of the tree that contains all the specified nodes.</param>
            <param name="nodes">The nodes from the tree to be replaced.</param>
            <param name="computeReplacementAsync">A function that computes a replacement node for
            the argument nodes. The first argument is one of the original specified nodes. The second argument is
            the same node possibly rewritten with replaced descendants.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.CommonSyntaxNodeExtensions.ReplaceTokensAsync``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Func{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Threading.CancellationToken,System.Threading.Tasks.Task{Microsoft.CodeAnalysis.SyntaxToken}},System.Threading.CancellationToken)">
            <summary>
            Creates a new tree of tokens from the existing tree with the specified old tokens replaced with a newly computed tokens.
            </summary>
            <param name="root">The root of the tree that contains all the specified tokens.</param>
            <param name="tokens">The tokens from the tree to be replaced.</param>
            <param name="computeReplacementAsync">A function that computes a replacement token for
            the argument tokens. The first argument is one of the originally specified tokens. The second argument is
            the same token possibly rewritten with replaced trivia.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.CommonSyntaxTreeExtensions.GetTouchingWord(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService,System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Returns the identifier, keyword, contextual keyword or preprocessor keyword touching this
            position, or a token of Kind = None if the caret is not touching either.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.CommonSyntaxTreeExtensions.IsHiddenPosition(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Returns <c>true</c> if the provided position is in a hidden region inaccessible to the user.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions.GetSemanticModelForSpanAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            this will return either regular semantic model or speculative semantic based on context. 
            any feature that is involved in typing or run on UI thread should use this to take advantage of speculative semantic model 
            whenever possible automatically.
            
            when using this API, semantic model should only be used to ask node inside of the given span. 
            otherwise, it might throw if semantic model returned by this API is a speculative semantic model.
            
            also, symbols from the semantic model returned by this API might have out of date location information. 
            if exact location (not relative location) is needed from symbol, regular GetSemanticModel should be used.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions.GetSemanticModelForNodeAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            this will return either regular semantic model or speculative semantic based on context. 
            any feature that is involved in typing or run on UI thread should use this to take advantage of speculative semantic model 
            whenever possible automatically.
            
            when using this API, semantic model should only be used to ask node inside of the given node except ones that belong to 
            member signature. otherwise, it might throw if semantic model returned by this API is a speculative semantic model.
            
            also, symbols from the semantic model returned by this API might have out of date location information. 
            if exact location (not relative location) is needed from symbol, regular GetSemanticModel should be used.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions.GetLinkedDocumentIds(Microsoft.CodeAnalysis.Document)">
            <summary>
            Gets the list of DocumentIds that are linked to the given document in the workspace's
            current solution and also exist in the given document's solution. The DocumentId of the
            given Document is excluded.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.INamespaceSymbolExtensions.FindNamespaces(Microsoft.CodeAnalysis.INamespaceSymbol,System.String,System.Threading.CancellationToken)">
            <summary>
            Searches the namespace for namespaces with the provided name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsUnsafe(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns true if this symbol contains anything unsafe within it.  for example
            List&lt;int*&gt; is unsafe, as it "int* Foo { get; }"
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsInaccessibleLocal(Microsoft.CodeAnalysis.ISymbol,System.Int32)">
            <returns>
            Returns true if symbol is a local variable and its declaring syntax node is 
            after the current position, false otherwise (including for non-local symbols)
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsEditorBrowsable(Microsoft.CodeAnalysis.ISymbol,System.Boolean,Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.IMethodSymbol,System.Collections.Generic.List{Microsoft.CodeAnalysis.IMethodSymbol},System.Collections.Generic.List{Microsoft.CodeAnalysis.IMethodSymbol},System.Collections.Generic.List{Microsoft.CodeAnalysis.IMethodSymbol},Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Checks a given symbol for browsability based on its declaration location, attributes 
            explicitly limiting browsability, and whether showing of advanced members is enabled. 
            The optional attribute constructor parameters may be used to specify the symbols of the
            constructors of the various browsability limiting attributes because finding these 
            repeatedly over a large list of symbols can be slow. If providing these constructor 
            symbols, they should be in the format provided by 
            EditorBrowsableHelpers.GetSpecial*AttributeConstructor(). If these are not provided,
            they will be found in the compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.FilterToVisibleAndBrowsableSymbols``1(System.Collections.Generic.IEnumerable{``0},System.Boolean,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            First, remove symbols from the set if they are overridden by other symbols in the set.
            If a symbol is overridden only by symbols outside of the set, then it is not removed. 
            This is useful for filtering out symbols that cannot be accessed in a given context due
            to the existence of overriding members. Second, remove remaining symbols that are
            unsupported (e.g. pointer types in VB) or not editor browsable based on the EditorBrowsable
            attribute.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsAccessibleWithin(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Checks if 'symbol' is accessible from within 'within'.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsAccessibleWithin(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.IAssemblySymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Checks if 'symbol' is accessible from within assembly 'within'.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsAccessibleWithin(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Checks if 'symbol' is accessible from within name type 'within', with an optional
            qualifier of type "throughTypeOpt".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsSymbolAccessible(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean@)">
            <summary>
            Checks if 'symbol' is accessible from within assembly 'within', with an qualifier of
            type "throughTypeOpt". Sets "failedThroughTypeCheck" to true if it failed the "through
            type" check.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsSymbolAccessibleCore(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean@)">
            <summary>
            Checks if 'symbol' is accessible from within 'within', which must be a INamedTypeSymbol
            or an IAssemblySymbol.  If 'symbol' is accessed off of an expression then
            'throughTypeOpt' is the type of that expression. This is needed to properly do protected
            access checks. Sets "failedThroughTypeCheck" to true if this protected check failed.
            
            NOTE(cyrusn): I expect this function to be called a lot.  As such, I do not do any memory
            allocations in the function itself (including not making any iterators).  This does mean
            that certain helper functions that we'd like to call are inlined in this method to
            prevent the overhead of returning collections or enumerators.  
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions.FindImplementationsForInterfaceMember(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Workspace,System.Threading.CancellationToken)">
            <summary>
            Returns the corresponding symbol in this type or a base type that implements 
            interfaceMember (either implicitly or explicitly), or null if no such symbol exists
            (which might be either because this type doesn't implement the container of
            interfaceMember, or this type doesn't supply a member that successfully implements
            interfaceMember).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SemanticModelExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxToken,System.Threading.CancellationToken)">
            <summary>
            Gets semantic information, such as type, symbols, and diagnostics, about the parent of a token.
            </summary>
            <param name="semanticModel">The SemanticModel object to get semantic information
            from.</param>
            <param name="token">The token to get semantic information from. This must be part of the
            syntax tree associated with the binding.</param>
            <param name="cancellationToken">A cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SimpleIntervalTreeExtensions.IntersectsWith(Microsoft.CodeAnalysis.Shared.Collections.SimpleIntervalTree{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            check whether the given span is intersects with the tree
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SourceTextExtensions.GetLeadingWhitespaceOfLineAtPosition(Microsoft.CodeAnalysis.Text.SourceText,System.Int32)">
            <summary>
            Returns the leading whitespace of the line located at the specified position in the given snapshot.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SourceTextExtensions.TryOverlapsHiddenPosition(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Text.TextSpan,System.Func{System.Int32,System.Threading.CancellationToken,System.Boolean},System.Threading.CancellationToken)">
            <summary>
            Same as OverlapsHiddenPosition but doesn't throw on cancellation.  Instead, returns false
            in that case.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SourceTextExtensions.HasSameText(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Determine if this SourceText has the same text as another SourceText.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Extensions.SymbolDisplayFormats.NameFormat">
            <summary>
            Standard format for displaying to the user.
            </summary>
            <remarks>
            No return type.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Extensions.SymbolDisplayFormats.SignatureFormat">
            <summary>
            Contains enough information to determine whether two symbols have the same signature.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextLineExtensions.GetFirstNonWhitespacePosition(Microsoft.CodeAnalysis.Text.TextLine)">
            <summary>
            Returns the first non-whitespace position on the given line, or null if 
            the line is empty or contains only whitespace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextLineExtensions.GetFirstNonWhitespaceOffset(Microsoft.CodeAnalysis.Text.TextLine)">
            <summary>
            Returns the first non-whitespace position on the given line as an offset
            from the start of the line, or null if the line is empty or contains only
            whitespace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextLineExtensions.GetLastNonWhitespacePosition(Microsoft.CodeAnalysis.Text.TextLine)">
            <summary>
            Returns the last non-whitespace position on the given line, or null if 
            the line is empty or contains only whitespace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextLineExtensions.IsEmptyOrWhitespace(Microsoft.CodeAnalysis.Text.TextLine)">
            <summary>
            Determines whether the specified line is empty or contains whitespace only.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextSpanExtensions.ToNormalizedSpans(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan})">
            <summary>
            merge provided spans to each distinct group of spans in ascending order
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection"/> that is
            empty.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.#ctor(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Initializes a new instance of <see cref="T:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection"/> that contains the specified span.
            </summary>
            <param name="span">TextSpan contained by the span set.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.#ctor(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan})">
            <summary>
            Initializes a new instance of <see cref="T:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection"/> that contains the specified list of spans.
            </summary>
            <param name="spans">The spans to be added.</param>
            <remarks>
            <para>The list of spans will be sorted and normalized (overlapping and adjoining spans will be combined).</para>
            <para>This constructor runs in O(N log N) time, where N = spans.Count.</para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="spans"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.Union(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection,Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Finds the union of two span sets.
            </summary>
            <param name="left">
            The first span set.
            </param>
            <param name="right">
            The second span set.
            </param>
            <returns>
            The new span set that corresponds to the union of <paramref name="left"/> and <paramref name="right"/>.
            </returns>
            <remarks>This operator runs in O(N+M) time where N = left.Count, M = right.Count.</remarks>
            <exception cref="T:System.ArgumentNullException">Either <paramref name="left"/> or <paramref name="right"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.Overlap(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection,Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Finds the overlap of two span sets.
            </summary>
            <param name="left">The first span set.</param>
            <param name="right">The second span set.</param>
            <returns>The new span set that corresponds to the overlap of <paramref name="left"/> and <paramref name="right"/>.</returns>
            <remarks>This operator runs in O(N+M) time where N = left.Count, M = right.Count.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="left"/> or <paramref name="right"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.Intersection(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection,Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Finds the intersection of two span sets.
            </summary>
            <param name="left">The first span set.</param>
            <param name="right">The second span set.</param>
            <returns>The new span set that corresponds to the intersection of <paramref name="left"/> and <paramref name="right"/>.</returns>
            <remarks>This operator runs in O(N+M) time where N = left.Count, M = right.Count.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="left"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="right"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.Difference(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection,Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Finds the difference between two sets. The difference is defined as everything in the first span set that is not in the second span set.
            </summary>
            <param name="left">The first span set.</param>
            <param name="right">The second span set.</param>
            <returns>The new span set that corresponds to the difference between <paramref name="left"/> and <paramref name="right"/>.</returns>
            <remarks>
            Empty spans in the second set do not affect the first set at all. This method returns empty spans in the first set that are not contained by any set in
            the second set.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="left"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="right"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.op_Equality(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection,Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Determines whether two span sets are the same. 
            </summary>
            <param name="left">The first set.</param>
            <param name="right">The second set.</param>
            <returns><c>true</c> if the two sets are equivalent, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.op_Inequality(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection,Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Determines whether two span sets are not the same.
            </summary>
            <param name="left">The first set.</param>
            <param name="right">The second set.</param>
            <returns><c>true</c> if the two sets are not equivalent, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.OverlapsWith(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Determines whether this span set overlaps with another span set.
            </summary>
            <param name="set">The span set to test.</param>
            <returns><c>true</c> if the span sets overlap, otherwise <c>false</c>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="set"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.OverlapsWith(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Determines whether this span set overlaps with another span.
            </summary>
            <param name="span">The span to test.</param>
            <returns><c>true</c> if this span set overlaps with the given span, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.IntersectsWith(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Determines whether this span set intersects with another span set.
            </summary>
            <param name="set">Set to test.</param>
            <returns><c>true</c> if the span sets intersect, otherwise <c>false</c>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="set"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.IntersectsWith(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Determines whether this span set intersects with another span.
            </summary>
            <returns><c>true</c> if this span set intersects with the given span, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.GetHashCode">
            <summary>
            Gets a unique hash code for the span set.
            </summary>
            <returns>A 32-bit hash code associated with the set.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.Equals(System.Object)">
            <summary>
            Determines whether this span set is the same as another object.
            </summary>
            <param name="obj">The object to test.</param>
            <returns><c>true</c> if the two objects are equal, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.ToString">
            <summary>
            Provides a string representation of the set.
            </summary>
            <returns>The string representation of the set.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.#ctor(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.OrderedSpanList)">
            <summary>
            Private ctor for use when the span list is already normalized.
            </summary>
            <param name="normalizedSpans">An already normalized span list.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.BloomFilter.#ctor(System.Int32,System.Double,System.Boolean)">
            <summary><![CDATA[
            1) n  = Number of items in the filter
            
            2) p = Probability of false positives, (a double between 0 and 1).
            
            3) m = Number of bits in the filter
            
            4) k = Number of hash functions
            
            m = ceil((n * log(p)) / log(1.0 / (pow(2.0, log(2.0)))))
            
            k = round(log(2.0) * m / n)
            ]]></summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.BloomFilter.ComputeHash(System.String,System.Int32)">
            <summary>
            Modification of the murmurhash2 algorithm.  Code is simpler because it operates over
            strings instead of byte arrays.  Because each string character is two bytes, it is known
            that the input will be an even number of bytes (though not necessarily a multiple of 4).
            
            This is needed over the normal 'string.GetHashCode()' because we need to be able to generate
            'k' different well distributed hashes for any given string s.  Also, we want to be able to
            generate these hashes without allocating any memory.  My ideal solution would be to use an
            MD5 hash.  However, there appears to be no way to do MD5 in .Net where you can:
            
            a) feed it individual values instead of a byte[]
            
            b) have the hash computed into a byte[] you provide instead of a newly allocated one
            
            Generating 'k' pieces of garbage on each insert and lookup seems very wasteful.  So,
            instead, we use murmur hash since it provides well distributed values, allows for a
            seed, and allocates no memory.
            
            Murmur hash is public domain.  Actual code is included below as reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.CommonFormattingHelpers.GetSpanIncludingTrailingAndLeadingTriviaOfAdjacentTokens(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            this will create a span that includes its trailing trivia of its previous token and leading trivia of its next token
            for example, for code such as "class A { int ...", if given tokens are "A" and "{", this will return span [] of "class[ A { ]int ..."
            which included trailing trivia of "class" which is previous token of "A", and leading trivia of "int" which is next token of "{"
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment">
            <summary>
            A documentation comment derived from either source text or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.HadXmlParseError">
            <summary>
            True if an error occurred when parsing.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.FullXmlFragment">
            <summary>
            The full XML text of this tag.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.ExampleText">
            <summary>
            The text in the &lt;example&gt; tag. Null if no tag existed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.SummaryText">
            <summary>
            The text in the &lt;summary&gt; tag. Null if no tag existed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.ReturnsText">
            <summary>
            The text in the &lt;returns&gt; tag. Null if no tag existed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.RemarksText">
            <summary>
            The text in the &lt;remarks&gt; tag. Null if no tag existed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.ParameterNames">
            <summary>
            The names of items in &lt;param&gt; tags.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.TypeParameterNames">
            <summary>
            The names of items in &lt;typeparam&gt; tags.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.ExceptionTypes">
            <summary>
            The types of items in &lt;exception&gt; tags.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.FromXmlFragment(System.String)">
            <summary>
            Parses and constructs a <see cref="T:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment" /> from the given fragment of XML.
            </summary>
            <param name="xml">The fragment of XML to parse.</param>
            <returns>A DocumentationComment instance.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.GetParameterText(System.String)">
            <summary>
            Returns the text for a given parameter, or null if no documentation was given for the parameter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.GetTypeParameterText(System.String)">
            <summary>
            Returns the text for a given type parameter, or null if no documentation was given for the type parameter.
            </summary>
            <param name="typeParameterName"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.GetExceptionTexts(System.String)">
            <summary>
            Returns the texts for a given exception, or an empty <see cref="T:System.Collections.Immutable.ImmutableArray"/> if no documentation was given for the exception.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.Empty">
            <summary>
            An empty comment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.EditorBrowsableHelpers.GetSpecialEditorBrowsableAttributeConstructor(Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Finds the constructor which takes exactly one argument, which must be of type EditorBrowsableState.
            It does not require that the EditorBrowsableAttribute and EditorBrowsableState types be those
            shipped by Microsoft, but it does demand the types found follow the expected pattern. If at any
            point that pattern appears to be violated, return null to indicate that an appropriate constructor
            could not be found.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.EditorBrowsableHelpers.GetSpecialTypeLibAttributeConstructorsWorker(Microsoft.CodeAnalysis.Compilation,System.String,System.String)">
            <summary>
            The TypeLib*Attribute classes that accept TypeLib*Flags with FHidden as an option all have two constructors,
            one accepting a TypeLib*Flags and the other a short. This methods gets those two constructor symbols for any
            of these attribute classes. It does not require that the either of these types be those shipped by Microsoft,
            but it does demand the types found follow the expected pattern. If at any point that pattern appears to be
            violated, return an empty enumerable to indicate that no appropriate constructors were found.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.EnumValueUtilities.GetNextEnumValue(Microsoft.CodeAnalysis.INamedTypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Determines, using heuristics, what the next likely value is in this enum.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.FindTokenHelper.FindTokenOnRightOfPosition``1(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Func{Microsoft.CodeAnalysis.SyntaxTriviaList,System.Int32,Microsoft.CodeAnalysis.SyntaxToken},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            If the position is inside of token, return that token; otherwise, return the token to the right.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.FindTokenHelper.FindTokenOnLeftOfPosition``1(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Func{Microsoft.CodeAnalysis.SyntaxTriviaList,System.Int32,Microsoft.CodeAnalysis.SyntaxToken},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            If the position is inside of token, return that token; otherwise, return the token to the left.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.FindTokenHelper.FindSkippedTokenBackward(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Int32)">
            <summary>
            Look inside a trivia list for a skipped token that contains the given position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.FindTokenHelper.FindSkippedTokenForward(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Int32)">
            <summary>
            Look inside a trivia list for a skipped token that contains the given position.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.IFileSystemDiscoveryService.CurrentDirectory">
            <summary>
            Gets the full path of the current directory.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.IntegerUtilities.Convert(System.Int64,Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Helper as VB's CType doesn't work without arithmetic overflow.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.Matcher`1">
            <summary>
            Helper class to allow one to do simple regular expressions over a sequence of objects (as
            opposed to a sequence of characters).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.Matcher.Repeat``1(Microsoft.CodeAnalysis.Shared.Utilities.Matcher{``0})">
            <summary>
            Matcher equivalent to (m*)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.Matcher.OneOrMore``1(Microsoft.CodeAnalysis.Shared.Utilities.Matcher{``0})">
            <summary>
            Matcher equivalent to (m+)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.Matcher.Choice``1(Microsoft.CodeAnalysis.Shared.Utilities.Matcher{``0},Microsoft.CodeAnalysis.Shared.Utilities.Matcher{``0})">
            <summary>
            Matcher equivalent to (m_1|m_2)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.Matcher.Sequence``1(Microsoft.CodeAnalysis.Shared.Utilities.Matcher{``0}[])">
            <summary>
            Matcher equivalent to (m_1 ... m_n)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.Matcher.Single``1(System.Func{``0,System.Boolean},System.String)">
            <summary>
            Matcher that matches an element if the provide predicate returns true.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.NameGenerator.EnsureUniqueness(System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.Boolean},System.Func{System.String,System.Boolean},System.Boolean)">
            <summary>
            Ensures that any 'names' is unique and does not collide with any other name.  Names that
            are marked as IsFixed can not be touched.  This does mean that if there are two names
            that are the same, and both are fixed that you will end up with non-unique names at the
            end.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.NameGenerator.EnsureUniqueness(System.String,System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            Transforms baseName into a name that does not conflict with any name in 'reservedNames'
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.ProgressTracker">
            <summary>
            Utility class that can be used to track the progress of an operation in a threadsafe manner.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.StringBreaker.BreakIntoCharacterParts(System.String)">
            <summary>
            Breaks an identifier string into constituent parts.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.StringBreaker.BreakIntoWordParts(System.String)">
            <summary>
            Breaks an identifier string into constituent parts.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer">
            <summary>
            Provides a way to test two symbols for equivalence.  While there are ways to ask for
            different sorts of equivalence, the following must hold for two symbols to be considered
            equivalent.
            
            1) The kinds of the two symbols must match.
            
            2) The names of the two symbols must match.
            
            3) The arity of the two symbols must match.
            
            4) If the symbols are methods or parameterized properties, then the signatures of the two
            symbols must match.
            
            5) Both symbols must be definitions or must be instantiations.  If they are instantiations,
            then they must be instantiated in the same manner.
            
            6) The containing symbols of the two symbols must be equivalent.
            
            Note: equivalence does not concern itself with whole symbols.  Two types are considered
            equivalent if the above hold, even if one type has different members than the other.  Note:
            type parameters, and signature parameters are not considered 'children' when comparing
            symbols.
            
            Options are provided to tweak the above slightly.  For example, by default, symbols are
            equivalent only if they come from the same assembly.  However, one can ask if two symbols are
            equivalent even if their assemblies differ.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer.Equals(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Compares given symbols <paramref name="x"/> and <paramref name="y"/> for equivalence.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer.Equals(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol})">
            <summary>
            Compares given symbols <paramref name="x"/> and <paramref name="y"/> for equivalence and populates <paramref name="equivalentTypesWithDifferingAssemblies"/>
            with equivalent non-nested named type key-value pairs that are contained in different assemblies.
            These equivalent named type key-value pairs represent possibly equivalent forwarded types, but this API doesn't perform any type forwarding equivalence checks. 
            </summary>
            <remarks>This API is only supported for <see cref="F:Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer.IgnoreAssembliesInstance"/>.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer.EquivalenceVisitor.HandleNamedTypesWorker(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol})">
            <summary>
            Worker for comparing two named types for equivalence. Note: The two
            types must have the same TypeKind.
            </summary>
            <param name="x">The first type to compare</param>
            <param name="y">The second type to compare</param>
            <param name="equivalentTypesWithDifferingAssemblies">
            Map of equivalent non-nested types to be populated, such that each key-value pair of named types are equivalent but reside in different assemblies.
            This map is populated only if we are ignoring assemblies for symbol equivalence comparison, i.e. <see cref="F:Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer.assembliesCanDiffer"/> is true.
            </param>
            <returns>True if the two types are equivalent.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8">
            <summary>
            Helper class to analyze the semantic effects of a speculated syntax node replacement on the parenting nodes.
            Given an expression node from a syntax tree and a new expression from a different syntax tree,
            it replaces the expression with the new expression to create a speculated syntax tree.
            It uses the original tree's semantic model to create a speculative semantic model and verifies that
            the syntax replacement doesn't break the semantics of any parenting nodes of the original expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.#ctor(`1,`1,`7,System.Threading.CancellationToken,System.Boolean,System.Boolean)">
            <summary>
            Creates a semantic analyzer for speculative syntax replacement.
            </summary>
            <param name="expression">Original expression to be replaced.</param>
            <param name="newExpression">New expression to replace the original expression.</param>
            <param name="semanticModel">Semantic model of <paramref name="expression"/> node's syntax tree.</param>
            <param name="cancellationToken">Cancellation token.</param>
            <param name="skipVerificationForReplacedNode">
            True if semantic analysis should be skipped for the replaced node and performed starting from parent of the original and replaced nodes.
            This could be the case when custom verifications are required to be done by the caller or
            semantics of the replaced expression are different from the original expression.
            </param>
            <param name="failOnOverloadResolutionFailuresInOriginalCode">
            True if semantic analysis should fail when any of the invocation expression ancestors of <paramref name="expression"/> in original code has overload resolution failures.
            </param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.OriginalExpression">
            <summary>
            Original expression to be replaced.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.SemanticRootOfOriginalExpression">
            <summary>
            First ancestor of <see cref="P:OriginalExpression"/> which is either a statement, attribute, constructor initializer,
            field initializer, default parameter initializer or type syntax node.
            It serves as the root node for all semantic analysis for this syntax replacement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.OriginalSemanticModel">
            <summary>
            Semantic model for the syntax tree corresponding to <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.OriginalExpression"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.ReplacedExpression">
            <summary>
            Node which replaces the <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.OriginalExpression"/>.
            Note that this node is a cloned version of <see cref="F:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.newExpressionForReplace"/> node, which has been re-parented
            under the node to be speculated, i.e. <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.SemanticRootOfReplacedExpression"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.SemanticRootOfReplacedExpression">
            <summary>
            Node created by replacing <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.OriginalExpression"/> under <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.SemanticRootOfOriginalExpression"/> node.
            This node is used as the argument to the GetSpeculativeSemanticModel API and serves as the root node for all
            semantic analysis of the speculated tree.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.SpeculativeSemanticModel">
            <summary>
            Speculative semantic model used for analyzing the semantics of the new tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.ReplacementChangesSemantics">
            <summary>
            Determines whether performing the given syntax replacement will change the semantics of any parenting expressions
            by performing a bottom up walk from the <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.OriginalExpression"/> upto <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.SemanticRootOfOriginalExpression"/>
            in the original tree and simultaneously walking bottom up from <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.ReplacedExpression"/> up to <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.SemanticRootOfReplacedExpression"/>
            in the speculated syntax tree and performing appropriate semantic comparisons.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.SymbolsForOriginalAndReplacedNodesAreCompatible">
            <summary>
            Checks whether the semantic symbols for the <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.OriginalExpression"/> and <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.ReplacedExpression"/> are non-null and compatible.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Simplification.AliasAnnotation">
            <summary>
            This annotation will be used by the expansion/reduction to annotate expanded syntax nodes to store the information that an 
            alias was used before expansion.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Simplification.SimplificationOptions">
            <summary>
            This Object contains the options that needs to be drilled down to the Simplification Engine
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.PreferAliasToQualification">
            <summary>
            This option tells the simplification engine if the Qualified Name should be replaced by Alias
            if the user had initially not used the Alias
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.PreferOmittingModuleNamesInQualification">
            <summary>
            This option influences the name reduction of members of a module in VB. If set to true, the 
            name reducer will e.g. reduce Namespace.Module.Member to Namespace.Member.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.PreferImplicitTypeInference">
            <summary>
            This option says that if we should simplify the Generic Name which has the type argument inferred
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.PreferImplicitTypeInLocalDeclaration">
            <summary>
            This option says if we should simplify the Explicit Type in Local Declarations
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.AllowSimplificationToGenericType">
            <summary>
            This option says if we should simplify to NonGeneric Name rather than GenericName
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.AllowSimplificationToBaseType">
            <summary>
            This option says if we should simplify from Derived types to Base types in Static Member Accesses
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.QualifyMemberAccessWithThisOrMe">
            <summary>
            This option says if we should simplify away the this. or Me. in member access expression
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Simplification.Simplifier">
            <summary>
            Expands and Reduces subtrees.
            
            Expansion:
                 1) Replaces names with fully qualified dotted names.
                 2) Adds parentheses around expressions
                 3) Adds explicit casts/conversions where implicit conversions exist
                 4) Adds escaping to identifiers
                 5) Rewrites extension method invocations with explicit calls on the class containing the extension method.
                 
            Reduction:
                1) Shortens dotted names to their minimally qualified form
                2) Removes unnecessary parentheses
                3) Removes unnecessary casts/conversions
                4) Removes unnecessary escaping
                5) Rewrites explicit calls to extension methods to use dot notation
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation">
            <summary>
            The annotation the reducer uses to identify sub trees to be reduced.
            The Expand operations add this annotation to nodes so that the Reduce operations later find them.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Simplification.Simplifier.SpecialTypeAnnotation">
            <summary>
            This is the annotation used by the simplifier and expander to identify Predefined type and preserving
            them from over simplification
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Simplification.Simplifier.ExpandAsync``1(``0,Microsoft.CodeAnalysis.Document,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Expand qualifying parts of the specified subtree, annotating the parts using the Simplifier.Annotation annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Simplification.Simplifier.Expand``1(``0,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Workspace,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Expand qualifying parts of the specified subtree, annotating the parts using the Simplifier.Annotation annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Simplification.Simplifier.ExpandAsync(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Document,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Threading.CancellationToken)">
            <summary>
            Expand qualifying parts of the specified subtree, annotating the parts using the Simplifier.Annotation annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Simplification.Simplifier.Expand(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Workspace,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Threading.CancellationToken)">
            <summary>
            Expand qualifying parts of the specified subtree, annotating the parts using the Simplifier.Annotation annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Simplification.Simplifier.ReduceAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Reduce all subtrees annotated with Simplifier.Annotation found within the document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Simplification.Simplifier.ReduceAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxAnnotation,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Reduce the sub trees annotated with Simplifier.Annotation found within the subtrees identified with the specified annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Simplification.Simplifier.ReduceAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Reduce the sub trees annotated with Simplifier.Annotation found within the specified span.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Simplification.Simplifier.ReduceAsync(Microsoft.CodeAnalysis.Document,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Reduce the sub trees annotated with Simplifier.Annotation found within the specified spans.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Simplification.SymbolAnnotation">
            <summary>
            An annotation that holds onto information about a type or namespace symbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolKey">
            <summary>
            <para>
            A SymbolKey is a lightweight identifier for a symbol that can be used to resolve the "same"
            symbol across compilations.  Different symbols have different concepts of "same-ness".
            Same-ness is recursively defined as follows:
            <list type="number">
              <item>Two IArraySymbol's are the "same" if they have the "same" element type and the same rank.</item>
              <item>Two IAssemblySymbol's are the "same" if they have the same <see cref="P:Microsoft.CodeAnalysis.ISymbol.Name"/>.</item>
              <item>Two IEventSymbol's are the "same" if they have the "same" containing type and the same <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>.</item>
              <item>Two IMethodSymbol's are the "same" if they have the "same" containing type, the same
                <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>, the same <see cref="P:Microsoft.CodeAnalysis.IMethodSymbol.Arity"/>, the "same"
                <see cref="P:Microsoft.CodeAnalysis.IMethodSymbol.TypeArguments"/>, and have same parameter types and 
                <see cref="P:Microsoft.CodeAnalysis.IParameterSymbol.RefKind"/>.</item>
              <item>IModuleSymbol's are the "same" if they have the same containing assembly.
                <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/> is not used because module identity is not important in practice.</item>
              <item>Two INamedTypeSymbol's are the "same" if they have "same" containing symbol, the same
                <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>, the same <see cref="P:Microsoft.CodeAnalysis.INamedTypeSymbol.Arity"/> and the "same"
                <see cref="P:Microsoft.CodeAnalysis.INamedTypeSymbol.TypeArguments"/>.</item>
              <item>Two INamespaceSymbol's are the "same" if they have the "same" containing symbol and the
                same <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>.  If the INamespaceSymbol is the global namespace for a
                compilation (and thus does not have a containing symbol) then it will only match another
                global namespace of another compilation.</item>
              <item>Two IParameterSymbol's are the "same" if they have the "same" containing symbol and the <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>.</item>
              <item>Two IPointerTypeSymbol's are the "same" if they have the "same" <see cref="P:Microsoft.CodeAnalysis.IPointerTypeSymbol.PointedAtType"/>.</item>
              <item>Two IPropertySymbol's are the "same" if they have the "same" containing type, the same
                <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>,  and have same parameter types and <see cref="P:Microsoft.CodeAnalysis.IParameterSymbol.RefKind"/>.</item>
              <item>Two ITypeParameterSymbol's are the "same" if they have the "same" containing symbol and the <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>.</item>
              <item>Two IFieldSymbol's are the "same" if they have the "same" containing symbol and the <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>.</item>
            </list>    
            A SymbolID for an IAliasSymbol will <see cref="M:Microsoft.CodeAnalysis.SymbolKey.Resolve(Microsoft.CodeAnalysis.Compilation,System.Boolean,System.Threading.CancellationToken)"/> back to the ISymbol for
            the <see cref="P:Microsoft.CodeAnalysis.IAliasSymbol.Target"/>.
            </para>
            <para>
            Due to issues arising from errors and ambiguity, it's possible for a SymbolKey to resolve to
            multiple symbols. For example, in the following type:
             <code>
            class C
            {
               int Foo();
               bool Foo();
            }
            </code>
            The SymbolKey for both Foo methods will be the same.  The SymbolId will then resolve to both methods.
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolKey.Create(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken)">
            <summary>
            <para>
            This entry point should only be called from the actual Symbol classes. It should not be
            used internally inside this type.  Instead, any time we need to get the <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/> for a
            related symbol (i.e. the containing namespace of a namespace) we should call
            <see cref="M:Microsoft.CodeAnalysis.SymbolKey.GetOrCreate(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SymbolKey.Visitor)"/>.  The benefit of this is twofold.  First of all, it keeps the size of the
            <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/> small by allowing up to reuse parts we've already created.  For example, if we
            have the <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/> for <c>Foo(int, int)</c>, then we will reuse the <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/>s for both <c>int</c>s.
            Second, this allows us to deal with the recursive nature of MethodSymbols and
            TypeParameterSymbols.  Specifically, a MethodSymbol is defined by its signature.  However,
            it's signature may refer to type parameters of that method.  Unfortunately, the type
            parameters depend on their containing method.
            </para>
            <para>
            For example, if there is <c><![CDATA[Foo<T>(T t)]]></c>, then we must avoid the situation where we:
            <list type="number">
            <item>try to get the symbol ID for the type parameter <c>T</c>, which in turn</item>
            <item>tries to get the symbol ID for the method <c>T</c>, which in turn</item>
            <item>tries to get the symbol IDs for the parameter types, which in turn</item>
            <item>tries to get the symbol ID for the type parameter <c>T</c>, which leads back to 1 and infinitely loops.</item>
            </list>
            </para>
            <para>
            In order to break this circularity we do not create the SymbolIDs for a method's type
            parameters directly in the visitor.  Instead, we create the SymbolID for the method
            itself.  When the MethodSymbolId is created it will directly instantiate the SymbolIDs
            for the type parameters, and directly assign the type parameter's method ID to itself.
            It will also then directly store the mapping from the type parameter to its SymbolID in
            the visitor cache.  Then when we try to create the symbol IDs for the parameter types,
            any reference to the type parameters can be found in the cache.
            </para>
            <para>
            It is for this reason that it is essential that all calls to get related symbol IDs goes
            through GetOrCreate and not Create.
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolKey.Equals(Microsoft.CodeAnalysis.SymbolKey,Microsoft.CodeAnalysis.SymbolKey.ComparisonOptions)">
            <summary>
            <para>
            When comparing symbols we need to handle recursion between method type parameters and
            methods.  For example, if we have two methods with the signature <c><![CDATA[Foo<T>(T t)]]></c> and we
            try to test for equality we must avoid the situation where we:
            <list type="number">
              <item>First test if the methods are the same, which will in turn</item>
              <item>test if the method's parameter types are the same, which will in turn</item>
              <item>test if the type parameters are the same, which will in turn</item>
              <item>test if the methods are the same, which causes infinite recursion.</item>
            </list>
            To avoid this we distinguish the cases where we're testing if two type parameters
            actually refer to the same thing, versus type parameters being referenced by parameters.
            For example, if we have:
            <code><![CDATA[ 
            Foo<T>(T t) 
            Bar<T>(T t) 
            ]]></code>
            then clearly the type parameter <c>T</c> in <c><![CDATA[Foo<T>]]></c> is different from the type parameter <c>T</c>
            in <c><![CDATA[Bar<T>]]></c>. When testing these type parameters for equality we *will* test to see
            if they have the same parent. This will end up returning false, and so we will consider
            them different.
            </para>
            <para>
            However, when we are testing if two signatures are the same, if we hit a method type
            parameter then we only need to compare by metadataName.  That's because we know we'll
            already have checked if the method and it's parents are the same, so we don't need to
            recurse through them again.
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineProject.CreateProjectInfo(Microsoft.CodeAnalysis.Workspace,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Create a ProjectInfo structure initialized from a compilers command line arguments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineProject.CreateProjectInfo(Microsoft.CodeAnalysis.Workspace,System.String,System.String,System.String,System.String)">
            <summary>
            Create a ProjectInfo structure initialized with data from a compiler command line.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CustomWorkspace">
            <summary>
            A workspace that allows manual addition of projects and documents.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CustomWorkspace.ClearSolution">
            <summary>
            Clears all projects and documents from the workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CustomWorkspace.AddSolution(Microsoft.CodeAnalysis.SolutionInfo)">
            <summary>
            Adds an entire solution to the workspace, replacing any existing solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CustomWorkspace.AddProject(System.String,System.String)">
            <summary>
            Adds a project to the workspace. All previous projects remain intact.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CustomWorkspace.AddProject(Microsoft.CodeAnalysis.ProjectInfo)">
            <summary>
            Adds a project to the workspace. All previous projects remain intact.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CustomWorkspace.AddProjects(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectInfo})">
            <summary>
            Adds multiple projects to the workspace at once. All existing projects remain intact.
            </summary>
            <param name="projectInfos"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CustomWorkspace.AddDocument(Microsoft.CodeAnalysis.ProjectId,System.String,System.String)">
            <summary>
            Adds a document to the workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CustomWorkspace.AddDocument(Microsoft.CodeAnalysis.DocumentInfo)">
            <summary>
            Adds a document to the workspace.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DocumentationCommentId">
            <summary>
            APIs for constructing documentation comment id's, and finding symbols that match ids.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentationCommentId.CreateDeclarationId(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Creates an id string used by external documenation comment files to identify declarations
            of types, namespaces, methods, properties, etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentationCommentId.CreateReferenceId(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Creates an id string used to reference type symbols (not strictly declarations, includes
            arrays, pointers, type parameters, etc.)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentationCommentId.GetSymbolsForDeclarationId(System.String,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Gets all declaration symbols that match the declaration id string
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentationCommentId.GetFirstSymbolForDeclarationId(System.String,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Gets the first declaration symbol that matches the declaration id string, order undefined.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentationCommentId.GetSymbolsForReferenceId(System.String,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Gets the symbols that match the reference id string.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentationCommentId.GetFirstSymbolForReferenceId(System.String,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Gets the first symbol that matches the reference id string, order undefined.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace">
            <summary>
            A workspace that can be populated by opening MSBuild solution and project files.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.Create">
            <summary>
            Create a new instance of a workspace that can be populated by opening solution and project files.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.Create(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Create a new instance of a workspace that can be populated by opening solution and project files.
            </summary>
            <param name="properties">An optional set of MSBuild properties used when interpretting project files.
            These are the same properties that are passed to msbuild via the /property:&lt;n&gt;=&lt;v&gt; command line argument.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.Create(System.Collections.Generic.IDictionary{System.String,System.String},Microsoft.CodeAnalysis.Host.HostServices)">
            <summary>
            Create a new instance of a workspace that can be populated by opening solution and project files.
            </summary>
            <param name="properties">The MSBuild properties used when interpretting project files.
            These are the same properties that are passed to msbuild via the /property:&lt;n&gt;=&lt;v&gt; command line argument.</param>
            <param name="hostServices">The feature pack used to configure this workspace.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.Properties">
            <summary>
            The MSBuild properties used when interpretting project files.
            These are the same properties that are passed to msbuild via the /property:&lt;n&gt;=&lt;v&gt; command line argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.LoadMetadataForReferencedProjects">
            <summary>
            Determines if metadata from existing output assemblies is loaded instead of opening referenced projects.
            If the referenced project is already opened, the metadata will not be loaded.
            If the metadata assembly cannot be found the referenced project will be opened instead.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.AssociateLanguageWithExtension(System.String,System.String)">
            <summary>
            Associates a language name with a project file extension.
            Projects with the specified file extension will be opened using the specified language.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.CloseSolution">
            <summary>
            Close the open solution, and reset the workspace to a new empty solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.OpenSolutionAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Open a solution file and all referenced projects.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.OpenProjectAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Open a project file and all referenced projects.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.GetProjectMetadata(System.String,System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Generic.IDictionary{System.String,System.String},System.Threading.CancellationToken)">
            <summary>
            Gets a MetadataReference to a project's output assembly.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MSBuild.BuildTargets">
            <summary>
            Defines a list of build targets and operations to modify that list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.BuildTargets.Remove(System.String)">
            <summary>
            Remove the specified target from the build targets. 
            
            If the target is nested (a dependent target) of one of the build targets, 
            promote the siblings of the target to the formal list (in execution order.)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.BuildTargets.RemoveAfter(System.String,System.Boolean)">
            <summary>
            Remove all targets after the specified target (and possibly also removing the specified target.)
            
            If the a removed target is nested (a dependent target) of one of the build targets, 
            promote the siblings of the removed target to the formal list (in execution order.)
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MSBuild.DocumentFileInfo">
            <summary>
            Represents a source file that is part of a project file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.DocumentFileInfo.FilePath">
            <summary>
            The absolute path to the document file on disk.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.DocumentFileInfo.LogicalPath">
            <summary>
            A fictional path to the document, relative to the project.
            The document may not actually exist at this location, and is used
            to represent linked documents. This includes the file name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.DocumentFileInfo.IsLinked">
            <summary>
            True if the document has a logical path that differs from its 
            absolute file path.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.DocumentFileInfo.IsGenerated">
            <summary>
            True if the file was generated during build.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MSBuild.IProjectFile">
            <summary>
            Represents a project file loaded from disk.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.IProjectFile.FilePath">
            <summary>
            The path to the project file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.IProjectFile.Guid">
            <summary>
            The unique Guid associated with the project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.GetProjectFileInfoAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the project file info asynchronously.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.GetSourceCodeKind(System.String)">
            <summary>
            Get the kind of source found in the specified file. 
            This is usually determined by the file name extension.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.GetDocumentExtension(Microsoft.CodeAnalysis.SourceCodeKind)">
            <summary>
            Gets the corresponding extension for a source file of a given kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.GetPropertyValue(System.String)">
            <summary>
            Gets a specific project file property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.AddDocument(System.String,System.String)">
            <summary>
            Add a source document to a project file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.RemoveDocument(System.String)">
            <summary>
            Remove a source document from a project file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.Save">
            <summary>
            Save the current state of the project file to disk.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.ProjectFile.GetAbsolutePath(System.String)">
            <summary>
            Resolves the given path that is possibly relative to the project directory.
            </summary>
            <remarks>
            The resulting path is absolute but might not be normalized.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo">
            <summary>
            Represents a project file loaded from disk.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.Guid">
            <summary>
            The project's individual GUID
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.OutputFilePath">
            <summary>
            The path to the output file this project generates.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.AssemblyName">
            <summary>
            The assembly name of the output.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.CompilationOptions">
            <summary>
            The compilation options for this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.ParseOptions">
            <summary>
            The parse options for this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.Documents">
            <summary>
            The source documents.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.ProjectReferences">
            <summary>
            References to other projects.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.MetadataReferences">
            <summary>
            References to other metadata files; libraries and executables.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.AnalyzerReferences">
            <summary>
            References to analyzer assembly files; contains diagnostic analyzers.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.AppConfigPath">
            <summary>
            The path to an App.config configuration file, or null if none is provided.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MSBuild.ProjectFileReference">
            <summary>
            Represents a reference to another project file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileReference.Guid">
            <summary>
            The unique GUID of the referenced project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileReference.Path">
            <summary>
            The path on disk to the other project file. 
            This path may be relative to the referencing project's file or an absolute path.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileReference.Aliases">
            <summary>
            The aliases assigned to this reference, if any.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MSBuild.SectionBlock">
            <summary>
            Represents a SectionBlock in a .sln file. Section blocks are of the form:
            
            Type(ParenthesizedName) = Value
                Key = Value
                [more keys/values]
            EndType
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.BranchId">
            <summary>
            solution branch Id
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Document">
            <summary>
            Represents a source code document that is part of a project.
            It provides access to the source text, parsed syntax tree and the corresponding semantic model.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Document.Project">
            <summary>
            The project this document belongs to.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Document.Id">
            <summary>
            The document's identifier. Many document instances may share the same ID, but only one
            document in a solution may have that ID.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Document.FilePath">
            <summary>
            The path to the document file or null if there is no document file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Document.Name">
            <summary>
            The name of the document.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Document.Folders">
            <summary>
            The sequence of logical folders the document is contained in.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Document.SourceCodeKind">
            <summary>
            The kind of source code this document contains.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.TryGetText(Microsoft.CodeAnalysis.Text.SourceText@)">
            <summary>
            Get the current text for the document if it is already loaded and available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.TryGetTextVersion(Microsoft.CodeAnalysis.VersionStamp@)">
            <summary>
            Gets the version of the document's text if it is already loaded and available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.TryGetSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree@)">
            <summary>
            Get the current syntax tree for the document if the text is already loaded and the tree is already parsed.
            Returns true if the syntax tree is already available, or false if getting the syntax tree would have incurred additional work.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.TryGetSyntaxVersion(Microsoft.CodeAnalysis.VersionStamp@)">
            <summary>
            Get the current syntax tree version for the document if the text is already loaded and the tree is already parsed.
            Returns true if the syntax tree is already available, or false if getting the syntax tree would have incurred additional work.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.TryGetTopLevelChangeTextVersion(Microsoft.CodeAnalysis.VersionStamp@)">
            <summary>
            Gets the version of the document's top level signature if it is already loaded and available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.GetTextAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the current text for the document asynchronously.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.GetTextVersionAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the version of the document's text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.GetSyntaxVersionAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the version of the syntax tree. This is generally the newer of the text version and the project's version.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.GetTopLevelChangeTextVersionAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the version of the document's top level signature.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Document.SupportsSyntaxTree">
            <summary>
            <code>true</code> if this Document supports providing data through the
            <see cref="M:Microsoft.CodeAnalysis.Document.GetSyntaxTreeAsync(System.Threading.CancellationToken)"/> and <see cref="M:Microsoft.CodeAnalysis.Document.GetSyntaxRootAsync(System.Threading.CancellationToken)"/> methods.
            
            If <code>false</code> then these methods will return <code>null</code> instead.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Document.SupportsSemanticModel">
            <summary>
            <code>true</code> if this Document supports providing data through the
            <see cref="M:Microsoft.CodeAnalysis.Document.GetSemanticModelAsync(System.Threading.CancellationToken)"/> method.
            
            If <code>false</code> then this method will return <code>null</code> instead.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.GetSyntaxTreeAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the SyntaxTree for this document asynchronously.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.TryGetSyntaxRoot(Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            Gets the root node of the current syntax tree if it is available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.GetSyntaxRootAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the root node of the syntax tree asynchronously.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.TryGetSemanticModel(Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Gets the current semantic model for this document if the model is already computed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.GetSemanticModelAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the semantic model for this document asynchronously.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.WithSourceCodeKind(Microsoft.CodeAnalysis.SourceCodeKind)">
            <summary>
            Creates a new instance of this document updated to have the source code kind specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.WithText(Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Creates a new instance of this document updated to have the text specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.WithSyntaxRoot(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a new instance of this document updated to have a syntax tree rooted by the specified syntax node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.GetTextChangesAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Get the text changes between this document and a prior version of the same document.
            The changes, when applied to the text of the old document, will produce the text of the current document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.WithFrozenPartialSemanticsAsync(System.Threading.CancellationToken)">
            <summary>
            Creates a branched version of this document that has its semantic model frozen in whatever state it is available at the time,
            assuming a background process is constructing the semantics asynchronously. Repeated calls to this method may return
            documents with increasingly more complete semantics.
            
            Use this method to gain access to potentially incomplete semantics quickly.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DocumentId">
            <summary>
            An identifier that can be used to retrieve the same Document across versions of the
            workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentId.CreateNewId(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Creates a new DocumentId instance.
            </summary>
            <param name="projectId">The project id this document id is relative to.</param>
            <param name="debugName">An optional name to make this id easier to recognize while debugging.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DocumentInfo">
            <summary>
            A class that represents all the arguments necessary to create a new document instance.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.Id">
            <summary>
            The Id of the document.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.Name">
            <summary>
            The name of the document.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.Folders">
            <summary>
            The names of the logical nested folders the document is contained in.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.SourceCodeKind">
            <summary>
            The kind of the source code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.FilePath">
            <summary>
            The file path of the document.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.TextAndVersion">
            <summary>
            The text of the document and its version.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.TextLoader">
            <summary>
            A loader that can retrieve the document text.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.IsGenerated">
            <summary>
            True if the document is a side effect of the build.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentInfo.#ctor(Microsoft.CodeAnalysis.DocumentId,System.String,System.Collections.Generic.IEnumerable{System.String},Microsoft.CodeAnalysis.SourceCodeKind,Microsoft.CodeAnalysis.TextLoader,System.String,System.Boolean)">
            <summary>
            Create a new instance of a DocumentInfo.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PreservationMode">
            <summary>
            The mode in which value is preserved.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PreservationMode.PreserveValue">
            <summary>
            The value is guaranteed to have the same contents across multiple accesses.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PreservationMode.PreserveIdentity">
            <summary>
            The value is guaranteed to the same instance across multiple accesses.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Project">
            <summary>
            Represents a project that is part of a solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.Solution">
            <summary>
            The solution this project is part of.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.Id">
            <summary>
            The ID of the project. Multiple IProject instances may share the same ID. However, only
            one project may have this ID in any given solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.FilePath">
            <summary>
            The path to the project file or null if there is no project file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.OutputFilePath">
            <summary>
            The path to the output file, or null if it is not known.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.SupportsCompilation">
            <summary>
            <code>true</code> if this Project supports providing data through the
            <see cref="M:Microsoft.CodeAnalysis.Project.GetCompilationAsync(System.Threading.CancellationToken)"/> method.
            
            If <code>false</code> then this method will return <code>null</code> instead.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.LanguageServices">
            <summary>
            The language services from the host environment associated with this project's language.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.Language">
            <summary>
            The language associated with the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.AssemblyName">
            <summary>
            The name of the assembly this project represents.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.Name">
            <summary>
            The name of the project. This may be different than the assembly name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.MetadataReferences">
            <summary>
            The list of all other metadata sources (assemblies) that this project references.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.ProjectReferences">
            <summary>
            The list of all other projects within the same solution that this project references.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.AllProjectReferences">
            <summary>
            The list of all other projects that this project references, including projects that 
            are not part of the solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.AnalyzerReferences">
            <summary>
            The list of all the diagnostic analyzer references for this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.CompilationOptions">
            <summary>
            The options used when building the compilation for this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.ParseOptions">
            <summary>
            The options used when parsing documents for this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.IsSubmission">
            <summary>
            Returns true if this is a submission project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.HasDocuments">
            <summary>
            True if the project has any documents.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.DocumentIds">
            <summary>
            All the document IDs associated with this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.Documents">
            <summary>
            All the documents associated with this project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.ContainsDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            True if the project contains a document with the specified ID.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetDocumentId(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Get the documentId in this project with the specified syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetDocument(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Get the document in this project with the specified syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Get the document in this project with the specified document Id.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.TryGetCompilation(Microsoft.CodeAnalysis.Compilation@)">
            <summary>
            Get the compilation for this project if it is available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetCompilationAsync(System.Threading.CancellationToken)">
            <summary>
            Get the compilation for this project asynchronously.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetChanges(Microsoft.CodeAnalysis.Project)">
            <summary>
            Gets an object that lists the added, changed and removed documents between this project and the specified project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.Version">
            <summary>
            The project version. This equates to the version of the project file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetLatestDocumentVersionAsync(System.Threading.CancellationToken)">
            <summary>
            The version of the most recently modified document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetDependentVersionAsync(System.Threading.CancellationToken)">
            <summary>
            The most recent version of the project, its documents and all dependent projects and documents.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetDependentSemanticVersionAsync(System.Threading.CancellationToken)">
            <summary>
            The semantic version of this project including the semantics of referenced projects.
            This version changes whenever the consumable declarations of this project and/or projects it depends on change.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetSemanticVersionAsync(System.Threading.CancellationToken)">
            <summary>
            The semantic version of this project not including the semantics of referenced projects.
            This version changes only when the consumable declarations of this project change.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.WithAssemblyName(System.String)">
            <summary>
            Creates a new instance of this project updated to have the new assembly name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.WithCompilationOptions(Microsoft.CodeAnalysis.CompilationOptions)">
            <summary>
            Creates a new instance of this project updated to have the specified compilation options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.WithParseOptions(Microsoft.CodeAnalysis.ParseOptions)">
            <summary>
            Creates a new instance of this project updated to have the specified parse options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddProjectReference(Microsoft.CodeAnalysis.ProjectReference)">
            <summary>
            Creates a new instance of this project updated to include the specified project reference
            in addition to already existing ones.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddProjectReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectReference})">
            <summary>
            Creates a new instance of this project updated to include the specified project references
            in addition to already existing ones.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.RemoveProjectReference(Microsoft.CodeAnalysis.ProjectReference)">
            <summary>
            Creates a new instance of this project updated to no longer include the specified project reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.WithProjectReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectReference})">
            <summary>
            Creates a new instance of this project updated to replace existing project references 
            with the specified ones.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddMetadataReference(Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Creates a new instance of this project updated to include the specified metadata reference
            in addition to already existing ones.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddMetadataReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Creates a new instance of this project updated to include the specified metadata references
            in addition to already existing ones.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.RemoveMetadataReference(Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Creates a new instance of this project updated to no longer include the specified metadata reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.WithMetadataReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Creates a new instance of this project updated to replace existing metadata reference
            with the specified ones.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddAnalyzerReference(Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Creates a new instance of this project updated to include the specified analyzer reference 
            in addition to already existing ones.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddAnalyzerReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference})">
            <summary>
            Creates a new instance of this project updated to include the specified analyzer references
            in addition to already existing ones.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.RemoveAnalyzerReference(Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Creates a new instance of this project updated to no longer include the specified analyzer reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.WithAnalyzerReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference})">
            <summary>
            Creates a new instance of this project updated to replace existing analyzer references 
            with the specified ones.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddDocument(System.String,Microsoft.CodeAnalysis.Text.SourceText,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new document in a new instance of this project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddDocument(System.String,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new document in a new instance of this project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.RemoveDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Creates a new instance of this project updated to no longer include the specified document.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ProjectDependencyGraph">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.ProjectDependencyGraph"/> models the dependencies between projects in a solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.GetProjectsThatThisProjectDirectlyDependsOn(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Gets the list of projects (topologically sorted) that this project directly depends on.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.GetProjectsThatDirectlyDependOnThisProject(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Gets the list of projects (topologically sorted) that directly depend on this project.
            </summary> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.GetProjectsThatThisProjectTransitivelyDependsOn(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Gets the list of projects that directly or transitively this project depends on
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.GetProjectsThatTransitivelyDependOnThisProject(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Gets the list of projects that directly or transitively depend on this project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.GetTopologicallySortedProjects(System.Threading.CancellationToken)">
            <summary>
            Returns all the projects for the solution in a topologically sorted order with respect
            to their dependencies. Projects that depend on other projects will always show up later in this sequence
            than the projects they depend on.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.GetDependencySets(System.Threading.CancellationToken)">
            <summary>
            Returns a sequence of sets, where each set contains items with shared interdependency,
            and there is no dependency between sets.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ProjectId">
            <summary>
            An identifier that can be used to refer to the same Project across versions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ProjectId.debugName">
            <summary>
            The SolutionId this project id is relative to.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectId.Id">
            <summary>
            The system generated unique id.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectId.CreateNewId(System.String)">
            <summary>
            Create a new ProjectId instance.
            </summary>
            <param name="debugName">An optional name to make this id easier to recognize while debugging.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ProjectInfo">
            <summary>
            A class that represents all the arguments necessary to create a new project instance.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.Id">
            <summary>
            The unique Id of the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.Version">
            <summary>
            The version of the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.Name">
            <summary>
            The name of the project. This may differ from the project's filename.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.AssemblyName">
            <summary>
            The name of the assembly that this project will create, without file extension.
            </summary>,
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.Language">
            <summary>
            The language of the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.FilePath">
            <summary>
            The path to the project file or null if there is no project file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.OutputFilePath">
            <summary>
            The path to the output file (module or assembly).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.CompilationOptions">
            <summary>
            The initial compilation options for the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ParseOptions">
            <summary>
            The initial parse options for the source code documents in this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.Documents">
            <summary>
            The list of source documents initially associated with the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectReferences">
            <summary>
            The project references initially defined for the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.MetadataReferences">
            <summary>
            The metadata references initially defined for the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.AnalyzerReferences">
            <summary>
            The analyzers initially associated with this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.IsSubmission">
            <summary>
            True if this is a submission project for interactive sessions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.HostObjectType">
            <summary>
            Type of the host object.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectInfo.Create(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.VersionStamp,System.String,System.String,System.String,System.String,System.String,Microsoft.CodeAnalysis.CompilationOptions,Microsoft.CodeAnalysis.ParseOptions,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.DocumentInfo},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectReference},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference},System.Boolean,System.Type)">
            <summary>
            Create a new instance of a ProjectInfo.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RecoverableTextAndVersion">
            <summary>
            A text retainer that will save text to temporary storage when it is evicted from the
            text cache and reload from that storage if and when it is needed again.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Solution">
            <summary>
            Represents a set of projects and their source code documents. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Solution.CompilationTracker">
            <summary>
            Tracks the changes made to a project and provides the facility to get a lazily built
            compilation for that project.  As the compilation is being built, the partial results are
            stored as well so that they can be used in the 'in progress' workspace snapshot.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Solution.CompilationTracker.stateDoNotAccessDirectly">
            <summary>
            Access via the <see cref="M:Microsoft.CodeAnalysis.Solution.CompilationTracker.ReadState"/> and <see cref="M:Microsoft.CodeAnalysis.Solution.CompilationTracker.WriteState(Microsoft.CodeAnalysis.Solution.CompilationTracker.State)"/> methods.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.CompilationTracker.#ctor(Microsoft.CodeAnalysis.ProjectState)">
            <summary>
            Creates a tracker for the provided project.  The tracker will be in the 'empty' state
            and will have no extra information beyond the project itself.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Solution.CompilationTracker.HasCompilation">
            <summary>
            Returns true if this tracker currently either points to a compilation, has an in-progress
            compilation being computed, or has a skeleton reference.  Note: this is simply a weak
            statement about the tracker at this exact moment in time.  Immediately after this returns
            the tracker might change and may no longer have a final compilation (for example, if the
            retainer let go of it) or might not have an in-progress compilation (for example, if the
            background compiler finished with it).
            
            Because of the above limitations, this should only be used by clients as a weak form of
            information about the tracker.  For example, a client may see that a tracker has no
            compilation and may choose to throw it away knowing that it could be reconstructed at a
            later point if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.CompilationTracker.Fork(Microsoft.CodeAnalysis.ProjectState,Microsoft.CodeAnalysis.Solution.CompilationTranslationAction,System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Creates a new instance of the compilation info, retaining any already built
            compilation state as the now 'old' state
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.CompilationTracker.Clone">
            <summary>
            Creates a fork with the same final project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.CompilationTracker.GetPartialCompilationState(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.ProjectState@,Microsoft.CodeAnalysis.Compilation@,System.Threading.CancellationToken)">
            <summary>
            Tries to get the latest snapshot of the compilation without waiting for it to be
            fully built. This method takes advantage of the progress side-effect produced during
            BuildCompilation. It will either return the already built compilation, any
            in-progress compilation or any known old compilation in that order of preference.
            The compilation state that is returned will have a compilation that is retained so
            that it cannot disappear.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.CompilationTracker.TryGetCompilation(Microsoft.CodeAnalysis.Compilation@)">
            <summary>
            Gets the final compilation if it is available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.CompilationTracker.BuildCompilationAsync(Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Builds the compilation matching the project state. In the process of building, also
            produce in progress snapshots that can be accessed from other threads.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.CompilationTracker.GetMetadataReferenceAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.ProjectState,Microsoft.CodeAnalysis.ProjectReference,System.Threading.CancellationToken)">
            <summary>
            Get a metadata reference to this compilation info's compilation with respect to
            another project. For cross language references produce a skeletal assembly. If the
            compilation is not available, it is built. If a skeletal assembly reference is
            needed and does not exist, it is also built.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.CompilationTracker.GetPartialMetadataReference(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.ProjectState,Microsoft.CodeAnalysis.ProjectReference,System.Threading.CancellationToken)">
            <summary>
            Attempts to get (without waiting) a metadata reference to a possibly in progress
            compilation. Actual compilation references are preferred over skeletal assembly
            references.  Could potentially return null if nothing can be provided.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.CompilationTracker.GetMetadataOnlyImageReferenceAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.ProjectReference,System.Threading.CancellationToken)">
            <summary>
            Gets a metadata reference to a the metadata-only-image corresponding to the compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.CompilationTracker.Retain(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Converts a compilation into a ValueSource employing an external compilation retention policy.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Solution.BranchId">
            <summary>
            branch id of this solution
            
            currently, it only supports one level of branching. there is a primary branch of a workspace and all other
            branches that are branched from the primary branch.
            
            one still can create multiple forked solutions from an already branched solution, but versions among those
            can't be reliably used and compared. 
            
            version only has a meaning between primary solution and branched one or between solutions from same branch.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Solution.Workspace">
            <summary>
            The Workspace this solution is associated with.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Solution.Id">
            <summary>
            The Id of the solution. Multiple solution instances may share the same Id.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Solution.FilePath">
            <summary>
            The path to the solution file or null if there is no solution file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Solution.Version">
            <summary>
            The solution version. This equates to the solution file's version.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Solution.ProjectIds">
            <summary>
            A list of all the ids for all the projects contained by the solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Solution.Projects">
            <summary>
            A list of all the projects contained by the solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetLatestProjectVersion">
            <summary>
            The version of the most recently modified project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.ContainsProject(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            True if the solution contains a project with the specified project ID.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetProject(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Gets the project in this solution with the specified project ID. 
            
            If the id is not an id of a project that is part of this solution the method returns null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetProject(Microsoft.CodeAnalysis.IAssemblySymbol,System.Threading.CancellationToken)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Project"/> associated with an assembly symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.ContainsDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            True if the solution contains the document in one of its projects
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetDocumentId(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Gets the documentId in this solution with the specified syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetDocumentId(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Gets the documentId in this solution with the specified syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Gets the document in this solution with the specified document ID.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetDocument(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Gets the document in this solution with the specified syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddProject(System.String,System.String,System.String)">
            <summary>
            Creates a new solution instance that includes a project with the specified language and names.
            Returns the new project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddProject(Microsoft.CodeAnalysis.ProjectId,System.String,System.String,System.String)">
            <summary>
            Creates a new solution instance that includes a project with the specified language and names.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddProject(Microsoft.CodeAnalysis.ProjectInfo)">
            <summary>
            Create a new solution instance that includes a project with the specified project information.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.RemoveProject(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Create a new solution instance without the project specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectAssemblyName(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Creates a new solution instance with the project specified updated to have the new
            assembly name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectOutputFilePath(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Creates a new solution instance with the project specified updated to have the output file path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectCompilationOptions(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.CompilationOptions)">
            <summary>
            Create a new solution instance with the project specified updated to have
            the specified compilation options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectParseOptions(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ParseOptions)">
            <summary>
            Create a new solution instance with the project specified updated to have
            the specified parse options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddProjectReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectReference)">
            <summary>
            Create a new solution instance with the project specified updated to include
            the specified project reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddProjectReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectReference})">
            <summary>
            Create a new solution instance with the project specified updated to include
            the specified project references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.RemoveProjectReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectReference)">
            <summary>
            Create a new solution instance with the project specified updated to no longer
            include the specified project reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectReference})">
            <summary>
            Create a new solution instance with the project specified updated to contain
            the specified list of project references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddMetadataReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Create a new solution instance with the project specified updated to include the 
            specified metadata reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddMetadataReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Create a new solution instance with the project specified updated to include the
            specified metadata references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.RemoveMetadataReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Create a new solution instance with the project specified updated to no longer include
            the specified metadata reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectMetadataReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Create a new solution instance with the project specified updated to include only the
            specified metadata references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddAnalyzerReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Create a new solution instance with the project specified updated to include the 
            specified analyzer reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddAnalyzerReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference})">
            <summary>
            Create a new solution instance with the project specified updated to include the
            specified analyzer references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.RemoveAnalyzerReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Create a new solution instance with the project specified updated to no longer include
            the specified analyzer reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectAnalyzerReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference})">
            <summary>
            Create a new solution instance with the project specified updated to include only the
            specified analyzer references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddDocument(Microsoft.CodeAnalysis.DocumentId,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Creates a new solution instance with the corresponding project updated to include a new
            document instance defined by its name and text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddDocument(Microsoft.CodeAnalysis.DocumentId,System.String,Microsoft.CodeAnalysis.Text.SourceText,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Creates a new solution instance with the corresponding project updated to include a new
            document instance defined by its name and text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddDocument(Microsoft.CodeAnalysis.DocumentId,System.String,Microsoft.CodeAnalysis.TextLoader,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Creates a new solution instance with the project updated to include a new document with
            the arguments specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddDocument(Microsoft.CodeAnalysis.DocumentInfo)">
            <summary>
            Create a new solution instance with the corresponding project updated to include a new 
            document instanced defined by the document info.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.RemoveDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Creates a new solution instance that no longer includes the specified document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithDocumentFolders(Microsoft.CodeAnalysis.DocumentId,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new solution instance with the document specified updated to be contained in
            the sequence of logical folders.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the document specified updated to have the text
            specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextAndVersion,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the document specified updated to have the text
            and version specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithDocumentSyntaxRoot(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the document specified updated to have a syntax tree
            rooted by the specified syntax node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithDocumentSourceCodeKind(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SourceCodeKind)">
            <summary>
            Creates a new solution instance with the document specified updated to have the source
            code kind specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithDocumentTextLoader(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextLoader,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the document specified updated to have the text
            supplied by the text loader.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.ForkProject(Microsoft.CodeAnalysis.ProjectState,Microsoft.CodeAnalysis.Solution.CompilationTranslationAction,System.Boolean,System.Boolean)">
            <summary>
            Creates a new snapshot with an updated project and an action that will produce a new
            compilation matching the new project out of an old compilation. All dependent projects
            are fixed-up if the change to the new project affects its public metadata, and old
            dependent compilations are forgotten.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetDocumentIdsWithFilePath(System.String)">
            <summary>
            Gets the set of documents in the current solution with the given file path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetIsolatedSolution">
            <summary>
            Gets a copy of the solution isolated from the original so that they do not share computed state.
            
            Use isolated solutions when doing operations that are likely to access a lot of text,
            syntax trees or compilations that are unlikely to be needed again after the operation is done. 
            When the isolated solution is reclaimed so will the computed state.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithFrozenPartialCompilationIncludingSpecificDocumentAsync(Microsoft.CodeAnalysis.DocumentId,System.Threading.CancellationToken)">
            <summary>
            Creates a branch of the solution that has its compilations frozen in whatever state they are in at the time, assuming a background compiler is
            busy building this compilations.
            
            A compilation for the project containing the specified document id will be guaranteed to exist with at least the syntax tree for the document.
            
            This not intended to be the public API, use Document.WithFrozenPartialSemantics() instead.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithDocumentText(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.DocumentId},Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with all the documents specified updated to have the same specified text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetMetadataReferenceAsync(Microsoft.CodeAnalysis.ProjectReference,Microsoft.CodeAnalysis.ProjectState,System.Threading.CancellationToken)">
            <summary>
            Get a metadata reference for the project's compilation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetPartialMetadataReference(Microsoft.CodeAnalysis.ProjectReference,Microsoft.CodeAnalysis.ProjectState,System.Threading.CancellationToken)">
            <summary>
            Attempt to get the best readily available compilation for the project. It may be a
            partially built compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetChanges(Microsoft.CodeAnalysis.Solution)">
            <summary>
            Gets an objects that lists the added, changed and removed projects between
            this solution and the specified solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetProjectDependencyGraph">
            <summary>
            Gets an ProjectDependencyGraph that details the dependencies between projects for this solution.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionId">
            <summary>
            An identifier that can be used to refer to the same Solution across versions. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionId.Id">
            <summary>
            The unique id of the solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionId.CreateNewId(System.String)">
            <summary>
            Create a new Solution Id
            </summary>
            <param name="debugName">An optional name to make this id easier to recognize while debugging.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionInfo">
            <summary>
            A class that represents all the arguments necessary to create a new solution instance.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionInfo.Id">
            <summary>
            The unique Id of the solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionInfo.Version">
            <summary>
            The version of the solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionInfo.FilePath">
            <summary>
            The path to the solution file, or null if there is no solution file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionInfo.Projects">
            <summary>
            A list of projects initially associated with the solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionInfo.Create(Microsoft.CodeAnalysis.SolutionId,Microsoft.CodeAnalysis.VersionStamp,System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectInfo})">
            <summary>
            Create a new instance of a SolutionInfo.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionServices">
            <summary>
            This class basically holds onto a set of services and gets reused across solution instances.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TextAndVersion">
            <summary>
            A class that represents both a source text and its version stamp.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TextAndVersion.Text">
            <summary>
            The source text.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TextAndVersion.Version">
            <summary>
            The version of the source text
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TextAndVersion.FilePath">
            <summary>
            An optional file path that identifies the origin of the source text
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextAndVersion.Create(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.VersionStamp,System.String)">
            <summary>
            Create a new TextAndVersion instance.
            </summary>
            <param name="text">The text</param>
            <param name="version">The version</param>
            <param name="filePath">An optional file path that identifies the original of the source text.</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TextLoader">
            <summary>
            A class that represents access to a source text and its version from a storage location.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextLoader.From(Microsoft.CodeAnalysis.TextAndVersion)">
            <summary>
            Creates a new TextLoader from an already existing source text and version.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextLoader.From(Microsoft.CodeAnalysis.Text.SourceTextContainer,Microsoft.CodeAnalysis.VersionStamp,System.String)">
            <summary>
            Creates a TextLoader from a SourceTextContainer and version. 
            
            The text obtained from the loader will be the current text of the container at the time
            the loader is accessed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TreeAndVersion">
            <summary>
            A class that represents both a tree and its top level signature version
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TreeAndVersion.Tree">
            <summary>
            The syntax tree
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TreeAndVersion.Version">
            <summary>
            The version of the top level signature of the tree
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.VersionStamp">
            <summary>
            VersionStamp should be only used to compare versions returned by same API.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.VersionStamp.globalVersion">
            <summary>
            global counter to avoid collision within same session. 
            it starts with a big initial number just for a clarity in debugging
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.VersionStamp.utcLastModified">
            <summary>
            time stamp
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.VersionStamp.localIncrement">
            <summary>
            indicate whether there was a collision on same item
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.VersionStamp.globalIncrement">
            <summary>
            unique version in same session
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.VersionStamp.Create">
            <summary>
            Creates a new instance of a VersionStamp.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.VersionStamp.Create(System.DateTime)">
            <summary>
            Creates a new instance of a version stamp based on the specified DateTime.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.VersionStamp.GetNewerVersion(Microsoft.CodeAnalysis.VersionStamp)">
            <summary>
            compare two different versions and return either one of the versions if there is no collision, otherwise, create a new version
            that can be used later to compare versions between different items
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.VersionStamp.GetNewerVersion">
            <summary>
            Gets a new VersionStamp that is guaranteed to be newer than its base one
            this should only be used for same item to move it to newer version
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.VersionStamp.ToString">
            <summary>
            Returns the serialized text form of the VersionStamp.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.VersionStamp.CanReusePersistedVersion(Microsoft.CodeAnalysis.VersionStamp,Microsoft.CodeAnalysis.VersionStamp)">
            <summary>
            check whether given persisted version is re-usable
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.VersionStamp.TestOnly_IsNewerThan(Microsoft.CodeAnalysis.VersionStamp)">
            <summary>
            True if this VersionStamp is newer than the specified one.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Workspace">
            <summary>
            A workspace provides access to a active set of source code projects and documents and their
            associated syntax trees, compilations and semantic models. A workspace has a current solution
            that is an immutable snapshot of the projects and documents. This property may change over time 
            as the workspace is updated either from live interactions in the environment or via call to the
            workspace's ApplyChanges method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.#ctor(Microsoft.CodeAnalysis.Host.HostServices,System.String)">
            <summary>
            Constructs a new workspace instance.
            </summary>
            <param name="host">The <see cref="T:Microsoft.CodeAnalysis.Host.HostServices"/> this workspace uses</param>
            <param name="workspaceKind">A string that can be used to identify the kind of workspace. Usually this matches the name of the class.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspace.Services">
            <summary>
            Services provider by the host for implementing workspace features.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspace.PrimaryBranchId">
            <summary>
            primary branch id that current solution has
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspace.PartialSemanticsEnabled">
            <summary>
            Override this property if the workspace supports partial semantics for documents.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspace.Kind">
            <summary>
            The kind of the workspace. 
            This is generally <see cref="F:Microsoft.CodeAnalysis.WorkspaceKind.Host"/> if originating from the host environment, but may be 
            any other name used for a specific kind of workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CreateSolution(Microsoft.CodeAnalysis.SolutionInfo)">
            <summary>
            Create a new empty solution instance associated with this workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CreateSolution(Microsoft.CodeAnalysis.SolutionId)">
            <summary>
            Create a new empty solution instance associated with this workspace.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspace.CurrentSolution">
            <summary>
            The current solution. 
            
            The solution is an immutable model of the current set of projects and source documents.
            It provides access to source text, syntax trees and semantics.
            
            This property may change as the workspace reacts to changes in the environment or 
            after ApplyChanges is called.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.SetCurrentSolution(Microsoft.CodeAnalysis.Solution)">
            <summary>
            Set's the current solution of this workspace. This method does not raise a workspace change event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.GetOptions">
            <summary>
            Get's the set of all global options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ScheduleTask(System.Action,System.String)">
            <summary>
            Executes an action as a background task, as part of a sequential queue of tasks.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ScheduleTask``1(System.Func{``0},System.String)">
            <summary>
            Execute a function as a background task, as part of a sequential queue of tasks.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentTextChanged(Microsoft.CodeAnalysis.Document)">
            <summary>
            Override this method to act immediately when the text of a document has changed, as opposed
            to waiting for the corresponding workspace changed event to fire asynchronously.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentClosing(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Override this method to act immediately when a document is closing, as opposed
            to waiting for the corresponding workspace changed event to fire asynchronously.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ClearSolution">
            <summary>
            Clears all solution data and empties the current solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ClearSolutionData">
            <summary>
            This method is called when a solution is cleared.
            
            Override this method if you want to do additional work when a solution is cleared. 
            Call the base method at the end of your method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ClearProjectData(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            This method is called when an individual project is removed.
            
            Override this method if you want to do additional work when a project is removed.
            Call the base method at the end of your method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ClearDocumentData(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            This method is called to clear an individual document is removed.
            
            Override this method if you want to do additional work when a document is removed.
            Call the base method at the end of your method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.Dispose">
            <summary>
            Disposes this workspace. The workspace can longer be used after it is disposed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.Dispose(System.Boolean)">
            <summary>
            Call this method when the workspace is disposed.
            
            Override this method to do addition work when the workspace is disposed.
            Call this method at the end of your method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnSolutionAdded(Microsoft.CodeAnalysis.SolutionInfo)">
            <summary>
            Call this method to respond to a solution being opened in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnSolutionReloaded(Microsoft.CodeAnalysis.SolutionInfo)">
            <summary>
            Call this method to respond to a solution being reloaded in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnSolutionRemoved">
            <summary>
            This method is called when the solution is removed from the workspace.
            
            Override this method if you want to do additional work when the solution is removed. 
            Call the base method at the end of your method.
            Call this method to respond to a solution being removed/cleared/closed in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnProjectAdded(Microsoft.CodeAnalysis.ProjectInfo)">
            <summary>
            Call this method to respond to a project being added/opened in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnProjectReloaded(Microsoft.CodeAnalysis.ProjectInfo)">
            <summary>
            Call this method to respond to a project being reloaded in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnProjectRemoved(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Call this method to respond to a project being removed from the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnAssemblyNameChanged(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Call this method when a project's assembly name is changed in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnOutputFilePathChanged(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Call this method when a project's output file path is changed in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnCompilationOptionsChanged(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.CompilationOptions)">
            <summary>
            Call this method when a project's compilation options are changed in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnParseOptionsChanged(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ParseOptions)">
            <summary>
            Call this method when a project's parse options are changed in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnProjectReferenceAdded(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectReference)">
            <summary>
            Call this method when a project reference is added to a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnProjectReferenceRemoved(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectReference)">
            <summary>
            Call this method when a project reference is removed from a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnMetadataReferenceAdded(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Call this method when a metadata reference is added to a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnMetadataReferenceRemoved(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Call this method when a metadata reference is removed from a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnAnalyzerReferenceAdded(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Call this method when an analyzer reference is added to a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnAnalyzerReferenceRemoved(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Call this method when an analyzer reference is removed from a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentAdded(Microsoft.CodeAnalysis.DocumentInfo)">
            <summary>
            Call this method when a document is added to a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentReloaded(Microsoft.CodeAnalysis.DocumentInfo)">
            <summary>
            Call this method when a document is reloaded in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentRemoved(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Call this method when a document is removed from a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentTextLoaderChanged(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextLoader)">
            <summary>
            Call this method when the text of a document is changed on disk.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentTextChanged(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Call this method when the text of a document is updated in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentSourceCodeKindChanged(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SourceCodeKind)">
            <summary>
            Call this method when the SourceCodeKind of a document changes in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CanApplyChange(Microsoft.CodeAnalysis.ApplyChangesKind)">
            <summary>
            Determines if the specific kind of change is supported by the ApplyChanges method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)">
            <summary>
            Apply changes made to a solution back to the workspace.
            
            The specified solution must be one that originated from this workspace. If it is not, or the workspace
            has been updated since the solution was obtained from the workspace, then this method returns false.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyProjectChanges(Microsoft.CodeAnalysis.ProjectChanges)">
            <summary>
            This method is called during ApplyChanges for each project that has been added, removed or changed.
            
            Override this method if you want to modify how project changes are applied.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.AddProjectReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectReference)">
            <summary>
            This method is called during ApplyChanges to add a project reference to a project.
            
            Override this method to implement the capability of adding project references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.RemoveProjectReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectReference)">
            <summary>
            This method is called during ApplyChanges to remove a project reference from a project.
            
            Override this method to implement the capability of removing project references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.AddMetadataReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            This method is called during ApplyChanges to add a metadata reference to a project.
            
            Override this method to implement the capability of adding metadata references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.RemoveMetadataReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            This method is called during ApplyChanges to remove a metadata reference from a project.
            
            Override this method to implement the capability of removing metadata references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.AddAnalyzerReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            This method is called during ApplyChanges to add an analyzer reference to a project.
            
            Override this method to implement the capability of adding analyzer references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.RemoveAnalyzerReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            This method is called during ApplyChanges to remove an analyzer reference from a project.
            
            Override this method to implement the capability of removing analyzer references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.AddDocument(Microsoft.CodeAnalysis.DocumentId,System.Collections.Generic.IEnumerable{System.String},System.String,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.SourceCodeKind)">
            <summary>
            This method is called during ApplyChanges to add a new document to a project.
            
            Override this method to implement the capability of adding documents.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.RemoveDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            This method is called during ApplyChanges to remove a document from a project.
            
            Override this method to implement the capability of removing documents.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ChangedDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            This method is called to change the text of a document.
            
            Override this method to implement the capability of changing document text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckSolutionIsEmpty">
            <summary>
            Throws an exception is the solution is not empty.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckProjectIsInCurrentSolution(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Throws an exception if the project is not part of the current solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckProjectIsNotInCurrentSolution(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Throws an exception is the project is part of the current solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckProjectHasProjectReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectReference)">
            <summary>
            Throws an exception if a project does not have a specific project reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckProjectDoesNotHaveProjectReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectReference)">
            <summary>
            Throws an exception if a project already has a specific project reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckProjectDoesNotHaveTransitiveProjectReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Throws an exception if project has a transitive reference to another project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckProjectHasMetadataReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Throws an exception if a project does not have a specific metadata reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckProjectDoesNotHaveMetadataReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Throws an exception if a project already has a specific metadata reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckProjectHasAnalyzerReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Throws an exception if a project does not have a specific analyzer reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckProjectDoesNotHaveAnalyzerReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Throws an exception if a project already has a specific analyzer reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckDocumentIsInCurrentSolution(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Throws an exception if a document is not part of the current solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckDocumentIsNotInCurrentSolution(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Throws an exception if a document is already part of the current solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.GetProjectName(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Gets the name to use for a project in an error message.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.GetDocumentName(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Gets the name to use for a document in an error message.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Workspace.TextTracker">
            <summary>
            A class that responds to text buffer changes
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspace.CanOpenDocuments">
            <summary>
            True if this workspace supports manually opening and closing documents.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspace.CanChangeActiveContextDocument">
            <summary>
            True if this workspace supports manually changing the ative context document of a text buffer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ClearOpenDocument_NoLock(Microsoft.CodeAnalysis.DocumentId)">
            <returns>The DocumentId of the current context document for the buffer that was 
            previously attached to the given documentId, if any</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OpenDocument(Microsoft.CodeAnalysis.DocumentId,System.Boolean)">
            <summary>
            Open the specified document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CloseDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Close the specified document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.IsDocumentOpen(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Determines if the document is currently open in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.GetOpenDocumentIds(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Gets a list of the currently opened documents.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.GetRelatedDocumentIds(Microsoft.CodeAnalysis.Text.SourceTextContainer)">
            <summary>
            Gets the ids for documents associated with a text container.
            Documents are normally associated with a text container when the documents are opened.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.GetDocumentIdInCurrentContext(Microsoft.CodeAnalysis.Text.SourceTextContainer)">
            <summary>
            Gets the id for the document associated with the given text container in its current context.
            Documents are normally associated with a text container when the documents are opened.
            </summary>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.SetDocumentContext(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentContextUpdated(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentContextUpdated(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceTextContainer)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.RemoveTextToDocumentIdMapping_NoLock(Microsoft.CodeAnalysis.Text.SourceTextContainer,Microsoft.CodeAnalysis.DocumentId)">
            <returns>The DocumentId of the current context document attached to the textContainer, if any.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.AdjustReloadedSolution(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Solution)">
            <summary>
             This method is called during OnSolutionReload.  Override this method if you want to manipulate
             the reloaded solution.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Workspace.WorkspaceChanged">
            <summary>
            An event raised whenever the current solution is changed.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Workspace.WorkspaceFailed">
            <summary>
            An event raised whenever the workspace or part of its solution model
            fails to access a file or other external resource.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Workspace.DocumentOpened">
            <summary>
            An event that is fired when a documents is opened in the editor.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Workspace.DocumentClosed">
            <summary>
            An event that is fired when a document is closed in the editor.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Workspace.DocumentActiveContextChanged">
            <summary>
            An event that is fired when the active context document associated with a buffer 
            changes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.TryGetWorkspace(Microsoft.CodeAnalysis.Text.SourceTextContainer,Microsoft.CodeAnalysis.Workspace@)">
            <summary>
            Gets the workspace associated with the specific text container.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.RegisterText(Microsoft.CodeAnalysis.Text.SourceTextContainer)">
            <summary>
            Register a correspondence between a text container and a workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.UnregisterText(Microsoft.CodeAnalysis.Text.SourceTextContainer)">
            <summary>
            Unregister a correspondence between a text container and a workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.GetWorkspaceRegistration(Microsoft.CodeAnalysis.Text.SourceTextContainer)">
            <summary>
            Returns a <see cref="T:Microsoft.CodeAnalysis.WorkspaceRegistration" /> for a given text container.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.SolutionChanged">
            <summary>
            The current solution changed for an unspecified reason.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.SolutionAdded">
            <summary>
            A solution was added to the workspace.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.SolutionRemoved">
            <summary>
            The current solution was removed from the workspace.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.SolutionCleared">
            <summary>
            The current solution was cleared of all projects and documents.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.SolutionReloaded">
            <summary>
            The current solution was reloaded.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.ProjectAdded">
            <summary>
            A project was added to the current solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.ProjectRemoved">
            <summary>
            A project was removed from the current solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.ProjectChanged">
            <summary>
            A project in the current solution was changed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.ProjectReloaded">
            <summary>
            A project in the current solution was reloaded.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.DocumentAdded">
            <summary>
            A document was added to the current solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.DocumentRemoved">
            <summary>
            A document was removed from the current solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.DocumentReloaded">
            <summary>
            A document in the current solution was reloaded.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.DocumentChanged">
            <summary>
            A document in the current solution was changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.WorkspaceDiagnostic.GetDebuggerDisplay">
            <remarks>Internal for testing purposes</remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.WorkspaceKind">
            <summary>
             Known workspace kinds
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.CodeAction">
            <summary>
            An action produced by a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.ICodeFixProvider"/> or a <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.ICodeRefactoringProvider"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.Description">
            <summary>
            The description of the action that may appear in a menu.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetOperationsAsync(System.Threading.CancellationToken)">
            <summary>
            The sequence of operations that define the code action.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.ComputeOperationsAsync(System.Threading.CancellationToken)">
            <summary>
            Override this method if you want to implement a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> subclass that includes custom <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation"/>'s.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetPreviewOperationsAsync(System.Threading.CancellationToken)">
            <summary>
            The sequence of operations used to construct a preview. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.ComputePreviewOperationsAsync(System.Threading.CancellationToken)">
            <summary>
            Override this method if you want to implement a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> that has a set of preview operations that are different
            than the operations produced by <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.ComputeOperationsAsync(System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetChangedSolutionAsync(System.Threading.CancellationToken)">
            <summary>
            Computes all changes for an entire solution.
            Override this method if you want to implement a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> subclass that changes more than one document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetChangedDocumentAsync(System.Threading.CancellationToken)">
            <summary>
            Computes changes for a single document.
            Override this method if you want to implement a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> subclass that changes a single document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.Create(System.String,System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{Microsoft.CodeAnalysis.Document}})">
            <summary>
            Creates a code action for a change to a single document. 
            Use this factory when the change is expensive to compute, and should be deferred until requested.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.Create(System.String,Microsoft.CodeAnalysis.Document)">
            <summary>
            Creates a code action for a change to a single document.
            Use this factory when the change is trivial to compute or is already computed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.Create(System.String,System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{Microsoft.CodeAnalysis.Solution}})">
            <summary>
            Creates a code action for a change to more than one document within a solution.
            Use this factory when the change is expensive to compute, and should be deferred until requested.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.Create(System.String,Microsoft.CodeAnalysis.Solution)">
            <summary>
            Creates a code action for a change to more than one document within a solution.
            Use this factory when the change is trivial to compute or is already computed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.PostProcessAsync(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CodeActions.CodeActionOperation},System.Threading.CancellationToken)">
            <summary>
            Apply post processing steps to any <see cref="T:Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation"/>'s.
            </summary>
            <param name="operations">A list of operations.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>A new list of operations with post processing steps applied to any <see cref="T:Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation"/>'s.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.PostProcessChangesAsync(Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
             Apply post processing steps to solution changes, like formatting and simplification.
            </summary>
            <param name="changedSolution">The solution changed by the <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>.</param>
            <param name="cancellationToken">A cancellation token</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.PostProcessChangesAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Apply post processing steps to a single document:
              Reducing nodes annotated with <see cref="F:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation"/>
              Formatting nodes annotated with <see cref="F:Microsoft.CodeAnalysis.Formatting.Formatter.Annotation"/>
            </summary>
            <param name="document">The document changed by the <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>A document with the post processing changes applied.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> that can vary with user specified options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions.GetOptions(System.Threading.CancellationToken)">
            <summary>
            Gets the options to use with this code action.
            This method is gauranteed to be called on the UI thread.
            </summary>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>An implementation specific object instance that holds options for applying the code action.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions.GetOperationsAsync(System.Object,System.Threading.CancellationToken)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation"/>'s for this <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> given the specified options.
            </summary>
            <param name="options">An object instance returned from a prior call to <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions.GetOptions(System.Threading.CancellationToken)"/>.</param>
            <param name="cancellationToken">A cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions.ComputeOperationsAsync(System.Object,System.Threading.CancellationToken)">
            <summary>
            Override this method to compute the operations that implement this <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>.
            </summary>
            <param name="options">An object instance returned from a call to <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions.GetOptions(System.Threading.CancellationToken)"/>.</param>
            <param name="cancellationToken">A cancellation token.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.ConflictAnnotation">
            <summary>
            Apply this annotation to a SyntaxNode to indicate a conflict may exist that requires user understanding and acknowledgement before taking action.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.RenameAnnotation">
            <summary>
            Apply this annotation to an appropriate SyntaxNode to request that it should be renamed by the user after the action.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.WarningAnnotation">
            <summary>
            Apply this annotation to a SyntaxNode to indicate that a warning message should be presented to the user.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation">
            <summary>
            Represents a single operation of a multi-operation code action.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation.Description">
            <summary>
            A description of the effect of the operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation.Apply(Microsoft.CodeAnalysis.Workspace,System.Threading.CancellationToken)">
            <summary>
            Called by the host environment to apply the effect of the operation.
            This method is gauranteed to be called on the UI thread.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation"/> for applying solution changes to a workspace.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.OpenDocumentOperation">
            <summary>
            A code action operation for requesting a document be opened in the host environment.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.ICodeFixProvider">
            <summary>
            Implement this interface to provide fixes for source code problems.
            Remember to use <see cref="T:Microsoft.CodeAnalysis.CodeFixes.ExportCodeFixProviderAttribute"/> so the host environment can offer your fixes in a UI.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.ICodeFixProvider.GetFixableDiagnosticIds">
            <summary>
            A list of diagnostic ID's that this provider can provider fixes for.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.ICodeFixProvider.GetFixesAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostic},System.Threading.CancellationToken)">
            <summary>
            Gets one or more fixes for the specified diagnostics represented as a list of <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>'s.
            </summary>
            <returns>A list of zero or more potential <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>'s. It is also safe to return null if there are none.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.ExportCodeFixProviderAttribute">
            <summary>
            Use this attribute to declare a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.ICodeFixProvider"/> implementation so that it can be discovered by the host.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.ExportCodeFixProviderAttribute.Name">
            <summary>
            The name of the <see cref="T:Microsoft.CodeAnalysis.CodeFixes.ICodeFixProvider"/>.  
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.ExportCodeFixProviderAttribute.Languages">
            <summary>
            The source languages this provider can provide fixes for.  See <see cref="T:Microsoft.CodeAnalysis.LanguageNames"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeRefactorings.ICodeRefactoringProvider">
            <summary>
            Implement this interface to provide source code refactorings.
            Remember to use <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.ExportCodeRefactoringProviderAttribute"/> so the host environment can offer your refactorings in a UI.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.ICodeRefactoringProvider.GetRefactoringsAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            Gets refactorings that are applicable within the span of the document representd as a list of <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>'s.
            </summary>
            <returns>A list of zero or more applicable <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>'s. It is also safe to return null if there are none.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeRefactorings.ExportCodeRefactoringProviderAttribute">
            <summary>
            Use this attribute to declare a <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.ICodeRefactoringProvider"/> implementation so that it can be discovered by the host.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.ExportCodeRefactoringProviderAttribute.Name">
            <summary>
            The name of the <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.ICodeRefactoringProvider"/>.  
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.ExportCodeRefactoringProviderAttribute.Language">
            <summary>
            The source language this provider can provide refactorings for.  See <see cref="T:Microsoft.CodeAnalysis.LanguageNames"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.WorkspacesResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.AddingProjectsNotSupported">
            <summary>
              Looks up a localized string similar to Adding projects not supported in ApplyChanges..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.AnalyzerIsAlreadyPresent">
            <summary>
              Looks up a localized string similar to {0} is already present..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.AnalyzerIsNotPresent">
            <summary>
              Looks up a localized string similar to {0} is not present..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.ArraysWithMoreThanOneDimensionCannotBeSerialized">
            <summary>
              Looks up a localized string similar to Arrays with more than one dimension cannot be serialized..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.CannotCodeGenUnsupportedOperator">
            <summary>
              Looks up a localized string similar to Cannot generate code for unsupported operator &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.CantResolveAnalyzerReference">
            <summary>
              Looks up a localized string similar to Can&apos;t resolve analyzer reference: &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.CantResolveMetadataReference">
            <summary>
              Looks up a localized string similar to Can&apos;t resolve metadata reference: &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.CastIsRedundant">
            <summary>
              Looks up a localized string similar to Cast is redundant..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.CausesCircularProjectReference">
            <summary>
              Looks up a localized string similar to Adding project reference from &apos;{0}&apos; to &apos;{1}&apos; will cause a circular reference..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.CouldNotFindLocationToGen">
            <summary>
              Looks up a localized string similar to Could not find location to generation symbol into..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.CycleDetectedInExtensions">
            <summary>
              Looks up a localized string similar to Cycle detected in extensions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.DestinationLocationFromDifferentTree">
            <summary>
              Looks up a localized string similar to Destination location was from a different tree..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.DocumentAlreadyInSolution">
            <summary>
              Looks up a localized string similar to The solution already contains the specified document..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.DocumentIsNotOpen">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is not open..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.DocumentIsOpen">
            <summary>
              Looks up a localized string similar to {0} is still open..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.DocumentNotInProject">
            <summary>
              Looks up a localized string similar to The project does not contain the specified document..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.DocumentNotInSolution">
            <summary>
              Looks up a localized string similar to The solution does not contain the specified document..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.DocumentVersionIsDifferent">
            <summary>
              Looks up a localized string similar to The specified document is not a version of this document..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.DuplicateKey">
            <summary>
              Looks up a localized string similar to An element with the same key but a different value already exists..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.DuplicateSourceFileInProject">
            <summary>
              Looks up a localized string similar to Duplicate source file &apos;{0}&apos; in project &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.ErrorWhileReadingSpecifiedConfigFile">
            <summary>
              Looks up a localized string similar to An error occured while reading the specified configuration file: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.FileWasExternallyModified">
            <summary>
              Looks up a localized string similar to File was externally modified: {0}..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.InvalidDestinationNode">
            <summary>
              Looks up a localized string similar to Destination type must be a {0}..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.InvalidDestinationNode2">
            <summary>
              Looks up a localized string similar to Destination type must be a {0} or a {1}..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.InvalidDestinationNode3">
            <summary>
              Looks up a localized string similar to Destination type must be a {0}, {1} or {2}..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.InvalidDocumentationCommentId">
            <summary>
              Looks up a localized string similar to Documentation comment id must start with E, F, M, N, P or T.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.InvalidLanguageNameOption">
            <summary>
              Looks up a localized string similar to A language name cannot be specified for this option..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.InvalidLanguageNameOption2">
            <summary>
              Looks up a localized string similar to A language name must be specified for this option..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.InvalidLocationForCodeGen">
            <summary>
              Looks up a localized string similar to No location provided to add statements to..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.InvalidNonSourceLocationForCodeGen">
            <summary>
              Looks up a localized string similar to Destination location was not in source..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.InvalidParameterCountForBinaryOperator">
            <summary>
              Looks up a localized string similar to Invalid number of parameters for binary operator..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.InvalidParameterCountForUnaryOperator">
            <summary>
              Looks up a localized string similar to Invalid number of parameters for unary operator..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.InvalidProjectBlockInSolutionFile">
            <summary>
              Looks up a localized string similar to Invalid project block, expected &quot;=&quot; after Project..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.InvalidProjectBlockInSolutionFile2">
            <summary>
              Looks up a localized string similar to Invalid project block, expected &quot;,&quot; after project name..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.InvalidProjectBlockInSolutionFile3">
            <summary>
              Looks up a localized string similar to Invalid project block, expected &quot;,&quot; after project path..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.InvalidProjectBlockInSolutionFile4">
            <summary>
              Looks up a localized string similar to Expected {0}..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.InvalidSubmissionReference">
            <summary>
              Looks up a localized string similar to This submission already references another submission project..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.LocationMustBeNullOrFromSource">
            <summary>
              Looks up a localized string similar to Location must be null or from source..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.MetadataIsAlreadyReferenced">
            <summary>
              Looks up a localized string similar to Metadata is already referenced..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.MetadataIsNotReferenced">
            <summary>
              Looks up a localized string similar to Metadata is not referenced..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.MissingEndOfFileInSolutionFile">
            <summary>
              Looks up a localized string similar to Expected end-of-file..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.MissingHeaderInSolutionFile">
            <summary>
              Looks up a localized string similar to Expected header: &quot;{0}&quot;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.MissingLineInSolutionFile">
            <summary>
              Looks up a localized string similar to Expected {0} line..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.NameCanBeSimplified">
            <summary>
              Looks up a localized string similar to Name can be simplified..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.NodeIsOfTheWrongType">
            <summary>
              Looks up a localized string similar to Node is of the wrong type..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.PathMustBeAbsolute">
            <summary>
              Looks up a localized string similar to Specified path must be absolute..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.ProjectAlreadyInSolution">
            <summary>
              Looks up a localized string similar to The solution already contains the specified project..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.ProjectAlreadyReferenced">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is already referenced..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.ProjectContainsOpenDocuments">
            <summary>
              Looks up a localized string similar to {0} still contains open documents..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.ProjectDirectlyReferencesTargetProject">
            <summary>
              Looks up a localized string similar to The project already references the target project..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.ProjectNotInSolution">
            <summary>
              Looks up a localized string similar to The solution does not contain the specified project..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.ProjectNotReferenced">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is not referenced..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.ProjectOrDocumentAlreadyInWorkspace">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is already part of the workspace..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.ProjectOrDocumentNotInWorkspace">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is not part of the workspace..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.ProjectTransitivelyReferencesTargetProject">
            <summary>
              Looks up a localized string similar to The project already transitively references the target project..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.RemoveUnnecessaryImportsOrUsings">
            <summary>
              Looks up a localized string similar to Remove Unnecessary Imports/Usings..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.RemovingProjectsNotSupported">
            <summary>
              Looks up a localized string similar to Removing projects not supported in ApplyChanges..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.RenameSymbolIsNotFromSource">
            <summary>
              Looks up a localized string similar to Symbol &quot;{0}&quot; is not from source..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.StringIsNullOrEmpty">
            <summary>
              Looks up a localized string similar to &quot;{0}&quot; must be a non-null and non-empty string..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.TemporaryStorageCannotBeWrittenMultipleTimes">
            <summary>
              Looks up a localized string similar to Temporary storage cannot be written more than once..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.UnknownIdentifier">
            <summary>
              Looks up a localized string similar to Unknown identifier..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.UnrecognizedLanguageName">
            <summary>
              Looks up a localized string similar to Unrecognized language name..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.UnrecognizedProjectType">
            <summary>
              Looks up a localized string similar to Unrecognized project type..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.UnsupportedLanguage">
            <summary>
              Looks up a localized string similar to The language &apos;{0}&apos; is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.ValueTooLargeToBeRepresented">
            <summary>
              Looks up a localized string similar to Value too large to be represented as a 30 bit unsigned integer..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.WorkspaceIsNotEmpty">
            <summary>
              Looks up a localized string similar to Workspace is not empty..
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ConcurrentSet`1">
            <summary>
            A concurrent, simplified HashSet.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ConcurrentSet`1.DefaultConcurrencyLevel">
            <summary>
            The default concurrency level is 2. That means the collection can cope with up to two
            threads making simultaneous modifications without blocking.
            Note ConcurrentDictionary's default concurrency level is dynamic, scaling according to
            the number of processors.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ConcurrentSet`1.DefaultCapacity">
            <summary>
            Taken from ConcurrentDictionary.DEFAULT_CAPACITY
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ConcurrentSet`1.dictionary">
            <summary>
            The backing dictionary. The values are never used; just the keys.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.#ctor">
            <summary>
            Construct a concurrent set with the default concurrency level.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Construct a concurrent set using the specified equality comparer.
            </summary>
            <param name="equalityComparer">The equality comparer for values in the set.</param>
        </member>
        <member name="P:Roslyn.Utilities.ConcurrentSet`1.Count">
            <summary>
            Obtain the number of elements in the set.
            </summary>
            <returns>The number of elements in the set.</returns>
        </member>
        <member name="P:Roslyn.Utilities.ConcurrentSet`1.IsEmpty">
            <summary>
            Determine whether the set is empty.</summary>
            <returns>true if the set is empty; otherwise, false.</returns>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.Contains(`0)">
            <summary>
            Determine whether the given value is in the set.
            </summary>
            <param name="value">The value to test.</param>
            <returns>true if the set contains the specified value; otherwise, false.</returns>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.Add(`0)">
            <summary>
            Attempts to add a value to the set.
            </summary>
            <param name="value">The value to add.</param>
            <returns>true if the value was added to the set. If the value already exists, this method returns false.</returns>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.Remove(`0)">
            <summary>
            Attempts to remove a value from the set.
            </summary>
            <param name="value">The value to remove.</param>
            <returns>true if the value was removed successfully; otherwise false.</returns>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.GetEnumerator">
            <summary>
            Obtain an enumerator that iterates through the elements in the set.
            </summary>
            <returns>An enumerator for the set.</returns>
        </member>
        <member name="T:Roslyn.Utilities.ConsList`1">
            <summary>
            a simple Lisp-like immutable list.  Good to use when lists are always accessed from the head.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.DocumentationCommentXmlNames">
            <summary>
            Names of well-known XML attributes and elements.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(``0[])">
            <remarks>
            This method is necessary to avoid an ambiguity between <see cref="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.IReadOnlyCollection{``0})"/> and <see cref="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.ICollection{``0})"/>.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.List{``0})">
            <remarks>
            This method is necessary to avoid an ambiguity between <see cref="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.IReadOnlyCollection{``0})"/> and <see cref="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.ICollection{``0})"/>.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.EnumUtilities.ConvertEnumUnderlyingTypeToUInt64(System.Object,Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Convert a boxed primitive (generally of the backing type of an enum) into a ulong.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.Hash.Combine(System.Int32,System.Int32)">
            <summary>
            This is how VB Anonymous Types combine hash values for fields.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Hash.Combine``1(``0,System.Int32)">
            <summary>
            This is how VB Anonymous Types combine hash values for fields.
            PERF: Do not use with enum types because that involves multiple
            unnecessary boxing operations.  Unfortunately, we can't constrain
            T to "non-enum", so we'll use a more restrictive constraint.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.Hash.FnvOffsetBias">
            <summary>
            The offset bias value used in the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.Hash.FnvPrime">
            <summary>
            The generative factor used in the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Byte[])">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.String,System.Int32,System.Int32)">
            <summary>
            Compute the hashcode of a sub-string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            Note: FNV-1a was developed and tuned for 8-bit sequences. We're using it here
            for 16-bit Unicode chars on the understanding that the majority of chars will
            fit into 8-bits and, therefore, the algorithm will retain its desirable traits
            for generating hash codes.
            </summary>
            <param name="text">The input string</param>
            <param name="start">The start index of the first character to hash</param>
            <param name="length">The number of characters, beginning with <paramref name="start"/> to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending after <paramref name="length"/> characters.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.String,System.Int32)">
            <summary>
            Compute the hashcode of a sub-string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <param name="start">The start index of the first character to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending at the end of the string.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.String)">
            <summary>
            Compute the hashcode of a string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <returns>The FNV-1a hash code of <paramref name="text"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Text.StringBuilder)">
            <summary>
            Compute the hashcode of a string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <returns>The FNV-1a hash code of <paramref name="text"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Char[],System.Int32,System.Int32)">
            <summary>
            Compute the hashcode of a sub string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string as a char array</param>
            <param name="start">The start index of the first character to hash</param>
            <param name="length">The number of characters, beginning with <paramref name="start"/> to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending after <paramref name="length"/> characters.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Char)">
            <summary>
            Compute the hashcode of a single character using the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            Note: In general, this isn't any more useful than "char.GetHashCode". However,
            it may be needed if you need to generate the same hash code as a string or
            substring with just a single character.
            </summary>
            <param name="ch">The character to hash</param>
            <returns>The FNV-1a hash code of the character.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.CombineFNVHash(System.Int32,System.String)">
            <summary>
            Combine a string with an existing FNV-1a hash code
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="hashCode">The accumulated hash code</param>
            <param name="text">The string to combine</param>
            <returns>The result of combining <paramref name="hashCode"/> with <paramref name="text"/> using the FNV-1a algorithm</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.CombineFNVHash(System.Int32,System.Char)">
            <summary>
            Combine a char with an existing FNV-1a hash code
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="hashCode">The accumulated hash code</param>
            <param name="ch">The new character to combine</param>
            <returns>The result of combining <paramref name="hashCode"/> with <paramref name="ch"/> using the FNV-1a algorithm</returns>
        </member>
        <member name="T:Roslyn.Utilities.ObjectPool`1">
            <summary>
            Generic implementation of object pooling pattern with predefined pool size limit. The main
            purpose is that limited number of frequently used objects can be kept in the pool for
            further recycling.
            
            Notes: 
            1) it is not the goal to keep all returned objects. Pool is not meant for storage. If there
               is no space in the pool, extra returned objects will be dropped.
            
            2) it is implied that if object was obtained from a pool, the caller will return it back in
               a relatively short time. Keeping checked out objects for long durations is ok, but 
               reduces usefulness of pooling. Just new up your own.
            
            Not returning objects to the pool in not detrimental to the pool's work, but is a bad practice. 
            Rationale: 
               If there is no intent for reusing the object, do not use pool - just use "new". 
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ObjectPool`1.Factory">
            <remarks>
            Not using <see cref="T:System.Func{T}"/> because this file is linked into the (debugger) Formatter,
            which does not have that type (since it compiles against .NET 2.0).
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.ObjectPool`1.Allocate">
            <summary>
            Produces an instance.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.ObjectPool`1.Free(`0)">
            <summary>
            Returns objects to the pool.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search in Allocate.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.ObjectPool`1.ForgetTrackedObject(`0,`0)">
            <summary>
            Removes an object from leak tracking.  
            
            This is called when an object is returned to the pool.  It may also be explicitly 
            called if an object allocated from the pool is intentionally not being returned
            to the pool.  This can be of use with pooled arrays if the consumer wants to 
            return a larger array to the pool than was originally allocated.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.Empty">
            <summary>
            Null or empty.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.Relative">
            <summary>
            "file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToCurrentDirectory">
            <summary>
            ".\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToCurrentParent">
            <summary>
            "..\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToCurrentRoot">
            <summary>
            "\dir\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToDriveDirectory">
            <summary>
            "C:dir\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.Absolute">
            <summary>
            "C:\file" or "\\machine" (UNC).
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.RemoveTrailingSpacesAndDots(System.String)">
            <summary>
            Trims all '.' and whitespaces from the end of the path
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IndexOfExtension(System.String)">
            <summary>
            Returns the offset in <paramref name="path"/> where the dot that starts an extension is, or -1 if the path doesn't have an extension.
            </summary>
            <remarks>
            Returns 0 for path ".foo".
            Returns -1 for path "foo.".
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetExtension(System.String)">
            <summary>
            Returns an extension of the specified path string.
            </summary>
            <remarks>
            The same functionality as <see cref="M:System.IO.Path.GetExtension(string)"/> but doesn't throw an exception
            if there are invalid characters in the path.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.RemoveExtension(System.String)">
            <summary>
            Removes extension from path.
            </summary>
            <remarks>
            Returns "foo" for path "foo.".
            Returns "foo.." for path "foo...".
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.ChangeExtension(System.String,System.String)">
            <summary>
            Returns path with the extenion changed to <paramref name="extension"/>.
            </summary>
            <returns>
            Equivalent of <see cref="M:System.IO.Path.ChangeExtension"/>
            
            If <paramref name="path"/> is null, returns null. 
            If path does not end with an extension, the new extension is appended to the path.
            If extension is null, equivalent to <see cref="M:Roslyn.Utilities.PathUtilities.RemoveExtension(System.String)"/>.
            </returns>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IndexOfFileName(System.String)">
            <summary>
            Returns the position in given path where the file name starts.
            </summary>
            <returns>-1 if path is null.</returns>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsFileName(System.String)">
            <summary>
            Returns true if the string represents an unqualified file name.
            </summary>
            <param name="path">Path.</param>
            <returns>True if <paramref name="path"/> is a simple file name, false if it is null or includes a directory specification.</returns>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetFileName(System.String)">
            <summary>
            Get file name from path.
            </summary>
            <remarks>Unlike <see cref="M:System.IO.Path.GetFileName"/> doesn't check for invalid path characters.</remarks>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetDirectoryName(System.String)">
            <summary>
            Get directory name from path.
            </summary>
            <remarks>
            Unlike <see cref="M:System.IO.Path.GetDirectoryName"/> it
                doesn't check for invalid path characters, 
                doesn't strip any trailing directory separators (TODO: tomat),
                doesn't recognize UNC structure \\computer-name\share\directory-name\file-name (TODO: tomat).
            </remarks>
            <returns>Prefix of path that represents a directory. </returns>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsDriveRootedAbsolutePath(System.String)">
            <summary>
            Returns true if given path is absolute and starts with a drive specification ("C:\").
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetPathRoot(System.String)">
            <summary>
            Get a prefix of given path which is the root of the path.
            </summary>
            <returns>
            Root of an absolute path or null if the path isn't absolute or has invalid format (e.g. "\\").
            It may or may not end with a directory separator (e.g. "C:\", "C:\foo", "\\machine\share", etc.) .
            </returns>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetUncPathRootLength(System.String)">
            <summary>
            Calculates the length of root of an UNC path.
            </summary>
            <remarks>
            "\\server\share" is root of UNC path "\\server\share\dir1\dir2\file".
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.CombineAbsoluteAndRelativePaths(System.String,System.String)">
            <summary>
            Combines an absolute path with a relative.
            </summary>
            <param name="root">Absolute root path.</param>
            <param name="relativePath">Relative path.</param>
            <returns>
            An absolute combined path, or null if <paramref name="relativePath"/> is 
            absolute (e.g. "C:\abc", "\\machine\share\abc"), 
            relative to the current root (e.g. "\abc"), 
            or relative to a drive directory (e.g. "C:abc\def").
            </returns>
            <seealso cref="M:Roslyn.Utilities.PathUtilities.CombinePossiblyRelativeAndRelativePaths(System.String,System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.CombinePossiblyRelativeAndRelativePaths(System.String,System.String)">
            <summary>
            Combine two paths, the first of which may be absolute.
            </summary>
            <param name="rootOpt">First path: absolute, relative, or null.</param>
            <param name="relativePath">Second path: relative and non-null.</param>
            <returns>null, if <paramref name="rootOpt"/> is null; a combined path, otherwise.</returns>
            <seealso cref="M:Roslyn.Utilities.PathUtilities.CombineAbsoluteAndRelativePaths(System.String,System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsFilePath(System.String)">
            <summary>
            Determines whether an assembly reference is considered an assembly file path or an assembly name.
            used, for example, on values of /r and #r.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ReferenceEqualityComparer">
            <summary>
            Compares objects based upon their reference identity.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.StringExtensions.NeedsLocalization(System.String)">
            <summary>
            Used to indicate places where we are hard-coding strings that will later need to be
            localized.  This way, we can use a "Find All References" to find and fix these.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.StringExtensions.IsValidClrNamespaceName(System.String)">
            <summary>
            Checks if the given name is a sequence of valid CLR names separated by a dot.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.FileKey.FullPath">
            <summary>
            Full case-insensitive path.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.FileKey.Timestamp">
            <summary>
            Last write time (Utc).
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.FileKey.#ctor(System.String,System.DateTime)">
            <summary>
            Constructor.
            </summary>
            <param name="fullPath">Full path.</param>
            <param name="timestamp">Last write time (Utc).</param>
        </member>
        <member name="M:Roslyn.Utilities.FileKey.Create(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.ResolveRelativePath(System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.Func{System.String,System.Boolean})">
            <summary>
            Resolves relative path and returns absolute path.
            The method depends only on values of its parameters and their implementation (for fileExists).
            It doesn't itself depend on the state of the current process (namely on the current drive directories) or 
            the state of file system.
            </summary>
            <param name="path">
            Path to resolve.
            </param>
            <param name="basePath">
            Base file path to resolve CWD-relative paths against. Null if not available.
            </param>
            <param name="baseDirectory">
            Base directory to resolve CWD-relative paths against if <paramref name="basePath"/> isn't specified. 
            Must be absolute path.
            Null if not available.
            </param>
            <param name="searchPaths">
            Sequence of paths used to search for unqualified relative paths.
            </param>
            <param name="fileExists">
            Method that tests existence of a file.
            </param>
            <returns>
            The resolved path or null if the path can't be resolved.
            </returns>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.NormalizeAbsolutePath(System.String)">
            <summary>
            Normalizes an absolute path.
            </summary>
            <param name="path">Path to normalize.</param>
            <exception cref="T:System.IO.IOException"/>
            <returns>Normalized path.</returns>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.DeleteFileOnClose(System.String)">
            <summary>
            Marks given file for automatic deletion when all its handles are closed.
            Note that after doing this the file can't be opened again, not even by the same process.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.GetFileTimeStamp(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Roslyn.Utilities.FixedObjectBinder">
            <summary>
            A binder that used a predetermine list of types and reader functions.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ObjectReader">
            <summary>
            A class that reads both primitive values and non-cyclical object graphs from a stream that was constructed using 
            the ObjectWriter class.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadBoolean">
            <summary>
            Read a Boolean value from the stream. This value must have been written using <see cref="M:Roslyn.Utilities.ObjectWriter.WriteBoolean(System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadByte">
            <summary>
            Read a Byte value from the stream. This value must have been written using <see cref="M:Roslyn.Utilities.ObjectWriter.WriteByte(System.Byte)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadChar">
            <summary>
            Read a Char value from the stream. This value must have been written using <see cref="M:Roslyn.Utilities.ObjectWriter.WriteChar(System.Char)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadDecimal">
            <summary>
            Read a Decimal value from the stream. This value must have been written using <see cref="M:Roslyn.Utilities.ObjectWriter.WriteDecimal(System.Decimal)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadDouble">
            <summary>
            Read a Double value from the stream. This value must have been written using <see cref="M:Roslyn.Utilities.ObjectWriter.WriteDouble(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadSingle">
            <summary>
            Read a Single value from the stream. This value must have been written using <see cref="M:Roslyn.Utilities.ObjectWriter.WriteSingle(System.Single)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadInt32">
            <summary>
            Read a Int32 value from the stream. This value must have been written using <see cref="M:Roslyn.Utilities.ObjectWriter.WriteInt32(System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadInt64">
            <summary>
            Read a Int64 value from the stream. This value must have been written using <see cref="M:Roslyn.Utilities.ObjectWriter.WriteInt64(System.Int64)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadSByte">
            <summary>
            Read a SByte value from the stream. This value must have been written using <see cref="M:Roslyn.Utilities.ObjectWriter.WriteSByte(System.SByte)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadInt16">
            <summary>
            Read a Int16 value from the stream. This value must have been written using <see cref="M:Roslyn.Utilities.ObjectWriter.WriteInt16(System.Int16)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadUInt32">
            <summary>
            Read a UInt32 value from the stream. This value must have been written using <see cref="M:Roslyn.Utilities.ObjectWriter.WriteUInt32(System.UInt32)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadUInt64">
            <summary>
            Read a UInt64 value from the stream. This value must have been written using <see cref="M:Roslyn.Utilities.ObjectWriter.WriteUInt64(System.UInt64)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadUInt16">
            <summary>
            Read a UInt16 value from the stream. This value must have been written using <see cref="M:Roslyn.Utilities.ObjectWriter.WriteUInt16(System.UInt16)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadDateTime">
            <summary>
            Read a DateTime value from the stream. This value must have been written using the <see cref="M:Roslyn.Utilities.ObjectWriter.WriteDateTime(System.DateTime)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadCompressedUInt">
            <summary>
            Read a compressed 30-bit integer value from the stream. This value must have been written using <see cref="M:Roslyn.Utilities.ObjectWriter.WriteCompressedUInt(System.UInt32)"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadValue">
            <summary>
            Read a value from the stream. The value must have been written using ObjectWriter.WriteValue.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.ReadString">
            <summary>
            Read a String value from the stream. This value must have been written using ObjectWriter.WriteString.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ObjectWriter">
            <summary>
            A class that writes both primitive values and non-cyclical object graphs to a stream that may be
            later read back using the ObjectReader class.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteBoolean(System.Boolean)">
            <summary>
            Writes a Boolean value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteByte(System.Byte)">
            <summary>
            Writes a Byte value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteChar(System.Char)">
            <summary>
            Writes a Char value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteDecimal(System.Decimal)">
            <summary>
            Writes a Decimal value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteDouble(System.Double)">
            <summary>
            Writes a Double value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteSingle(System.Single)">
            <summary>
            Writes a Single value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteInt32(System.Int32)">
            <summary>
            Writes a Int32 value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteInt64(System.Int64)">
            <summary>
            Writes a Int64 value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteSByte(System.SByte)">
            <summary>
            Writes a SByte value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteInt16(System.Int16)">
            <summary>
            Writes a Int16 value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteUInt32(System.UInt32)">
            <summary>
            Writes a UInt32 value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteUInt64(System.UInt64)">
            <summary>
            Writes a UInt64 value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteUInt16(System.UInt16)">
            <summary>
            Writes a UInt16 value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteDateTime(System.DateTime)">
            <summary>
            Writes a DateTime value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteCompressedUInt(System.UInt32)">
            <summary>
            Writes a compressed 30 bit integer to the stream. (not 32 bit)
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteString(System.String)">
            <summary>
            Writes a String value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteValue(System.Object)">
            <summary>
            Writes any value (primitive or object graph) to the stream.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.RecordingObjectBinder">
            <summary>
            A binder that gathers type/reader mappings during object writing
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.PooledObject`1">
            <summary>
            this is RAII object to automatically release pooled object when its owning pool
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.AnnotationTable`1">
            <summary>
            An AnnotationTable helps you attach your own annotation types/instances to syntax.  
            
            It maintains a map between your instances and actual SyntaxAnnotation's used to annotate the nodes
            and offers an API that matches the true annotation API on SyntaxNode.
            
            The table controls the lifetime of when you can find and retrieve your annotations. You won't be able to 
            find your annotations via HasAnnotations/GetAnnotations unless you use the same annotation table for these operations
            that you used for the WithAdditionalAnnotations operation.  
            
            Your custom annotations are not serialized with the syntax tree, so they won't move across boundaries unless the 
            same AnnotationTable is available on both ends.
            
            also, note that this table is not thread safe.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.AsyncLazy`1">
            <summary>
            Represents a value that can be retrieved synchronously or asynchronously by many clients.
            The value will be computed on-demand the moment the first client asks for it. While being
            computed, more clients can request the value. As long as there are outstanding clients the
            underlying computation will proceed.  If all outstanding clients cancel their request then
            the underlying value computation will be cancelled as well.
            
            Creators of an <see cref="T:Roslyn.Utilities.AsyncLazy`1" /> can specify whether the result of the computation is
            cached for future requests or not. Choosing to not cache means the computation functions are kept
            alive, whereas caching means the value (but not functions) are kept alive once complete.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1.asynchronousComputeFunction">
            <summary>
            The underlying function that starts an asynchronous computation of the resulting value.
            Null'ed out once we've computed the result and we've been asked to cache it.  Otherwise,
            it is kept around in case the value needs to be computed again.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1.synchronousComputeFunction">
            <summary>
            The underlying function that starts an synchronous computation of the resulting value.
            Null'ed out once we've computed the result and we've been asked to cache it, or if we
            didn't get any synchronous function given to us in the first place.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1.cacheResult">
            <summary>
            Whether or not we should keep the value around once we've computed it.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1.cachedResult">
            <summary>
            The Task that holds the cached result.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1.gate">
            <summary>
            Mutex used to protect reading and writing to all mutable objects and fields.  Traces
            indicate that there's negligible contention on this lock, hence we can save some memory
            by using a single lock for all AsyncLazy instances.  Only trivial and non-reentrant work
            should be done while holding the lock.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1.requests">
            <summary>
            The hash set of all currently outstanding asynchronous requests. Null if there are no requests,
            and will never be empty.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1.asynchronousComputationCancellationSource">
            <summary>
            If an asynchronous request is active, the CancellationTokenSource that allows for
            cancelling the underlying computation.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1.computationActive">
            <summary>
            Whether a computation is active or queued on any thread, whether synchronous or
            asynchronous.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.AsyncLazy`1.#ctor(`0)">
            <summary>
            Creates an AsyncLazy that always returns the value, analogous to <see cref="M:System.Threading.Tasks.Task.FromResult``1(``0)" />.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.AsyncLazy`1.#ctor(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{`0}},System.Boolean)">
            <summary>
            Important: callers of this constructor should ensure that the compute function returns
            a task in a non-blocking fashion.  i.e. the function should *not* synchronously compute
            a value and then return it using Task.FromResult.  Instead, it should return an actual
            task that operates asynchronously.  If this function synchronously computes a value
            then that will cause locks to be held in this type for excessive periods of time.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.AsyncLazy`1.#ctor(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{`0}},System.Func{System.Threading.CancellationToken,`0},System.Boolean)">
            <summary>
            Creates an AsyncLazy that supports both asynchronous computation and inline synchronous
            computation.
            </summary>
            <param name="asynchronousComputeFunction">A function called to start the asynchronous
            computation. This function should be cheap and non-blocking.</param>
            <param name="synchronousComputeFunction">A function to do the work synchronously, which
            is allowed to block. This function should not be implemented by a simple Wait on the
            asynchronous value. If that's all you are doing, just don't pass a synchronous function
            in the first place.</param>
            <param name="cacheResult">Whether the result should be cached once the computation is
            complete.</param>
        </member>
        <member name="M:Roslyn.Utilities.AsyncLazy`1.TakeLock(System.Threading.CancellationToken)">
            <summary>
            Takes the lock for this object and if acquired validates the invariants of this class.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.AsyncSemaphore">
            <summary>
            A semaphore that supports a WaitAsync() operation. Unlike SemaphoreSlim, WaitAsync
            does not have bugs where the semaphore can be acquired but WaitAsync returns cancelled.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncSemaphore.Factory">
            <summary>
            Factory object that may be used for lazy initialization. Creates AsyncSemaphore instances with an initial count of 1.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ImmutableHashMapExtensions.GetOrAdd``3(Roslyn.Collections.Immutable.ImmutableHashMap{``0,``1}@,``0,System.Func{``0,``2,``1},``2)">
            <summary>
            Obtains the value for the specified key from a dictionary, or adds a new value to the dictionary where the key did not previously exist.
            </summary>
            <typeparam name="TKey">The type of key stored by the dictionary.</typeparam>
            <typeparam name="TValue">The type of value stored by the dictionary.</typeparam>
            <typeparam name="TArg">The type of argument supplied to the value factory.</typeparam>
            <param name="location">The variable or field to atomically update if the specified <paramref name="key" /> is not in the dictionary.</param>
            <param name="key">The key for the value to retrieve or add.</param>
            <param name="valueFactory">The function to execute to obtain the value to insert into the dictionary if the key is not found.</param>
            <param name="factoryArgument">The argument to pass to the value factory.</param>
            <returns>The value obtained from the dictionary or <paramref name="valueFactory" /> if it was not present.</returns>
        </member>
        <member name="T:Roslyn.Utilities.LinkedHashQueue`1">
            <summary>
            A queue that will only allow one instance of an object inside of it at a time.  When an
            object is enqueued that is already in the list, it is removed from its location and placed
            at the end of the queue.  These aspects make the queue useful for LRU caches.
            
            This class is not threadsafe.  If you need it to be, wrap it within your own lock.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.LinkedHashQueue`1.Enqueue(`0)">
            <summary>
            Adds this item (or moves it if it's already in the queue) to the end.  If the item is not
            in the list, 'true' is returned, otherwise 'false'.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.NonReentrantLock">
            <summary>
            A lightweight mutual exclusion object which supports waiting with cancellation and prevents
            recursion (i.e. you may not call Wait if you already hold the lock)
            </summary>
            <remarks>
            <para>
            The <see cref="T:Roslyn.Utilities.NonReentrantLock"/> provides a lightweight mutual exclusion class that doesn't
            use Windows kernel synchronization primitives.
            </para>
            <para>
            The implementation is distilled from the workings of <see cref="T:System.Threading.SemaphoreSlim"/>
            The basic idea is that we use a regular sync object (Monitor.Enter/Exit) to guard the setting
            of an 'owning thread' field. If, during the Wait, we find the lock is held by someone else
            then we register a cancellation callback and enter a "Monitor.Wait" loop. If the cancellation
            callback fires, then it "pulses" all the waiters to wake them up and check for cancellation.
            Waiters are also "pulsed" when leaving the lock.
            </para>
            <para>
            All public members of <see cref="T:Roslyn.Utilities.NonReentrantLock"/> are thread-safe and may be used concurrently
            from multiple threads.
            </para>
            </remarks>
        </member>
        <member name="F:Roslyn.Utilities.NonReentrantLock.syncLock">
            <summary>
            A synchronization object to protect access to the <see cref="F:owningThread"/> field and to be pulsed
            when <see cref="M:Release"/> is called and during cancellation.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.NonReentrantLock.owningThread">
            <summary>
            Indicates which thread currently holds the lock. If null, then the lock is available.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.#ctor(System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="useThisInstanceForSynchronization">If false (the default), then the class
            allocates an internal object to be used as a sync lock.
            If true, then the sync lock object will be the NonReentrantLock instance itself. This
            saves an allocation but a client may not safely further use this instance in a call to
            Monitor.Enter/Exit or in a "lock" statement.
            </param>
        </member>
        <member name="F:Roslyn.Utilities.NonReentrantLock.Factory">
            <summary>
            Shared factory for use in lazy initialization.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.Wait(System.Threading.CancellationToken)">
            <summary>
            Blocks the current thread until it can enter the <see cref="T:Roslyn.Utilities.NonReentrantLock"/>, while observing a
            <see cref="T:System.Threading.CancellationToken"/>.
            </summary>
            <remarks>
            Recursive locking is not supported. i.e. A thread may not call Wait successfully twice without an
            intervening <see cref="M:Roslyn.Utilities.NonReentrantLock.Release"/>.
            </remarks>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> token to
            observe.</param>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was
            canceled.</exception>
            <exception cref="T:System.LockRecursionException">The caller already holds the lock</exception>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.Release">
            <summary>
            Exit the mutual exclusion.
            </summary>
            <remarks>
            The calling thread must currently hold the lock.
            </remarks>
            <exception cref="T:Roslyn.Utilities.ContractFailureException">The lock is not currently held by the calling thread.</exception>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.LockHeldByMe">
            <summary>
            Determine if the lock is currently held by the calling thread.
            </summary>
            <returns>True if the lock is currently held by the calling thread.</returns>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.AssertHasLock">
            <summary>
            Throw an exception if the lock is not held by the calling thread.
            </summary>
            <exception cref="T:Roslyn.Utilities.ContractFailureException">The lock is not currently held by the calling thread.</exception>
        </member>
        <member name="P:Roslyn.Utilities.NonReentrantLock.IsLocked">
            <summary>
            Checks if the lock is currently held.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.NonReentrantLock.IsOwnedByMe">
            <summary>
            Checks if the lock is currently held by the calling thread.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.TakeOwnership">
            <summary>
            Take ownership of the lock (by the calling thread). The lock may not already
            be held by any other code.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.ReleaseOwnership">
            <summary>
            Release ownership of the lock. The lock must already be held by the calling thread.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.NonReentrantLock.cancellationTokenCanceledEventHandler">
            <summary>
            Action object passed to a cancellation token registration.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.CancellationTokenCanceledEventHandler(System.Object)">
            <summary>
            Callback executed when a cancellation token is canceled during a Wait.
            </summary>
            <param name="obj">The syncLock that protects a <see cref="T:Roslyn.Utilities.NonReentrantLock"/> instance.</param>
        </member>
        <member name="M:Roslyn.Utilities.Contract.Requires(System.Boolean,System.String)">
             <summary>
             Equivalent to Debug.Assert.  
            
             DevDiv 867813 covers removing this completely at a future date
             </summary>
        </member>
        <member name="M:Roslyn.Utilities.Contract.Assert(System.Boolean,System.String)">
             <summary>
             Equivalent to Debug.Assert.  
            
             DevDiv 867813 covers removing this completely at a future date
             </summary>
        </member>
        <member name="M:Roslyn.Utilities.Contract.Assume(System.Boolean,System.String)">
             <summary>
             Equivalent to Debug.Assert.  
            
             DevDiv 867813 covers removing this completely at a future date
             </summary>
        </member>
        <member name="M:Roslyn.Utilities.Contract.ThrowIfNull``1(``0,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is null.  This method executes in
            all builds
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Contract.ThrowIfFalse(System.Boolean,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is false.  This method executes
            in all builds
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Contract.ThrowIfTrue(System.Boolean,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is true. This method executes in
            all builds.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.LazyInitialization.EnsureInitialized``1(``0@,System.Func{``0})">
            <summary>
            Ensure that the given target value is initialized (not null) in a thread-safe manner.
            </summary>
            <typeparam name="T">The type of the target value. Must be a reference type.</typeparam>
            <param name="target">The target to initialize.</param>
            <param name="valueFactory">A factory delegate to create a new instance of the target value. Note that this delegate may be called
            more than once by multiple threads, but only one of those values will successfully be written to the target.</param>
            <returns>The target value.</returns>
        </member>
        <member name="M:Roslyn.Utilities.LazyInitialization.EnsureInitialized``2(``0@,System.Func{``1,``0},``1)">
            <summary>
            Ensure that the given target value is initialized (not null) in a thread-safe manner.
            </summary>
            <typeparam name="T">The type of the target value. Must be a reference type.</typeparam>
            <param name="target">The target to initialize.</param>
            <typeparam name="U">The type of the <paramref name="state"/> argument passed to the value factory.</typeparam>
            <param name="valueFactory">A factory delegate to create a new instance of the target value. Note that this delegate may be called
            more than once by multiple threads, but only one of those values will successfully be written to the target.</param>
            <param name="state">An argument passed to the value factory.</param>
            <returns>The target value.</returns>
        </member>
        <member name="T:Roslyn.Utilities.SharedPools">
            <summary>
            Shared object pool for roslyn
            
            Use this shared pool if only concern is reducing object allocations.
            if perf of an object pool itself is also a concern, use ObjectPool directly.
            
            For example, if you want to create a million of small objects within a second, 
            use the ObjectPool directly. it should have much less overhead than using this.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.SharedPools.BigDefault``1">
            <summary>
            pool that uses default constructor with 100 elements pooled
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.SharedPools.Default``1">
            <summary>
            pool that uses default constructor with 20 elements pooled
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.SharedPools.StringIgnoreCaseDictionary``1">
            <summary>
            pool that uses string as key with StringComparer.OrdinalIgnoreCase as key comparer
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.SharedPools.StringIgnoreCaseHashSet">
            <summary>
            pool that uses string as element with StringComparer.OrdinalIgnoreCase as element comparer
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.SharedPools.StringHashSet">
            <summary>
            pool that uses string as element with StringComparer.Ordinal as element comparer
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.SharedPools.CharArray">
            <summary>
            Used to reduce the # of temporary char[]s created to satisfy serialization and
            other I/O requests
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.SharedPools.ByteArray">
            <summary>
            Used to reduce the # of temporary byte[]s created to satisfy serialization and
            other I/O requests
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.SharedPools.ByteBufferSize">
            pooled memory : 4K * 512 = 4MB
        </member>
        <member name="T:Roslyn.Utilities.SerializableBytes">
            <summary>
            Helpers to create temporary streams backed by pooled memory
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.SimpleTaskQueue">
            <summary>
            schedules task to run in sequence.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.SimpleTaskQueue.gate">
            <summary>
            An object to synchronize reads/writes of all mutable fields of this class.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.SyntaxPath">
            <summary>
            Stores the "path" from the root of a tree to a node, allowing the node to be recovered in a
            later snapshot of the tree, under certain circumstances.
            
            The implementation stores the child indices to represent the path, so any edit which affects
            the child indices could render this object unable to recover its node.  NOTE: One thing C#
            IDE has done in the past to do a better job of this is to store the fully qualified name of
            the member to at least be able to descend into the same member.  We could apply the same sort
            of logic here.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.SyntaxPath.TryResolve(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNodeOrToken@)">
            <summary>
            Attempts to recover the node at this path in the provided tree.  If the node is found
            then 'true' is returned, otherwise the result is 'false' and 'node' will be null.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.TaskExtensions.WaitAndGetResult_Hack``1(System.Threading.Tasks.Task{``0},System.Threading.CancellationToken)">
            <summary>
            You should not call this method.. Use WaitAndGetResult instead.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.TraceLog">
            <summary>
            Fixed size rolling tracing log. 
            </summary>
            <remarks>
            Recent entries are captured in a memory dump. 
            All entries are printed out to <see cref="T:System.Diagnostics.Trace"/> output or <see cref="T:System.Diagnostics.Debug"/> output.
            </remarks>
        </member>
        <member name="T:Roslyn.Utilities.ConstantValueSource`1">
            <summary>
            This value source keeps a strong reference to a value.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ValueSource`1">
            <summary>
            A class that abstracts the accessing of a value 
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.WeakConstantValueSource`1">
            <summary>
            A <see cref="T:ValueSource"/> that keeps a weak reference to a value.
            </summary>
        </member>
        <member name="T:Roslyn.Collections.Immutable.ImmutableHashMap`2">
            <summary>
            An immutable unordered hash map implementation.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
        </member>
        <member name="F:Roslyn.Collections.Immutable.ImmutableHashMap`2.root">
            <summary>
            The root node of the tree that stores this map.
            </summary>
        </member>
        <member name="F:Roslyn.Collections.Immutable.ImmutableHashMap`2.keyComparer">
            <summary>
            The comparer used to sort keys in this map.
            </summary>
        </member>
        <member name="F:Roslyn.Collections.Immutable.ImmutableHashMap`2.valueComparer">
            <summary>
            The comparer used to detect equivalent values in this map.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.#ctor(Roslyn.Collections.Immutable.ImmutableHashMap{`0,`1}.Bucket,System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2"/> class.
            </summary>
            <param name="root">The root.</param>
            <param name="comparer">The comparer.</param>
            <param name="valueComparer">The value comparer.</param>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2"/> class.
            </summary>
            <param name="comparer">The comparer.</param>
            <param name="valueComparer">The value comparer.</param>
        </member>
        <member name="P:Roslyn.Collections.Immutable.ImmutableHashMap`2.Empty">
            <summary>
            Gets an empty map with default equality comparers.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.Clear">
            <summary>
            See the <see cref="T:System.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.Add(`0,`1)">
            <summary>
            See the <see cref="T:System.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            See the <see cref="T:System.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.SetItem(`0,`1)">
            <summary>
            See the <see cref="T:System.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.SetItems(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Applies a given set of key=value pairs to an immutable dictionary, replacing any conflicting keys in the resulting dictionary.
            </summary>
            <param name="items">The key=value pairs to set on the map.  Any keys that conflict with existing keys will overwrite the previous values.</param>
            <returns>An immutable dictionary.</returns>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.Remove(`0)">
            <summary>
            See the <see cref="T:System.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.RemoveRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            See the <see cref="T:System.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.WithComparers(System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Returns a hash map that uses the specified key and value comparers and has the same contents as this map.
            </summary>
            <param name="keyComparer">The key comparer.  A value of <c>null</c> results in using the default equality comparer for the type.</param>
            <param name="valueComparer">The value comparer.  A value of <c>null</c> results in using the default equality comparer for the type.</param>
            <returns>The hash map with the new comparers.</returns>
            <remarks>
            In the event that a change in the key equality comparer results in a key collision, an exception is thrown.
            </remarks>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.WithComparers(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Returns a hash map that uses the specified key comparer and current value comparer and has the same contents as this map.
            </summary>
            <param name="keyComparer">The key comparer.  A value of <c>null</c> results in using the default equality comparer for the type.</param>
            <returns>The hash map with the new comparers.</returns>
            <remarks>
            In the event that a change in the key equality comparer results in a key collision, an exception is thrown.
            </remarks>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.ContainsValue(`1)">
            <summary>
            Determines whether the ImmutableSortedMap&lt;TKey,TValue&gt;
            contains an element with the specified value.
            </summary>
            <param name="value">
            The value to locate in the ImmutableSortedMap&lt;TKey,TValue&gt;.
            The value can be null for reference types.
            </param>
            <returns>
            true if the ImmutableSortedMap&lt;TKey,TValue&gt; contains
            an element with the specified value; otherwise, false.
            </returns>
        </member>
        <member name="P:Roslyn.Collections.Immutable.ImmutableHashMap`2.Count">
            <summary>
            Gets the number of elements in this collection.
            </summary>
        </member>
        <member name="P:Roslyn.Collections.Immutable.ImmutableHashMap`2.IsEmpty">
            <summary>
            Gets a value indicating whether this instance is empty.
            </summary>
            <value>
              <c>true</c> if this instance is empty; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Roslyn.Collections.Immutable.ImmutableHashMap`2.Keys">
            <summary>
            Gets the keys in the map.
            </summary>
        </member>
        <member name="P:Roslyn.Collections.Immutable.ImmutableHashMap`2.Values">
            <summary>
            Gets the values in the map.
            </summary>
        </member>
        <member name="P:Roslyn.Collections.Immutable.ImmutableHashMap`2.Item(`0)">
            <summary>
            Gets the <typeparamref name="TValue"/> with the specified key.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.ContainsKey(`0)">
            <summary>
            Determines whether the specified key contains key.
            </summary>
            <param name="key">The key.</param>
            <returns>
              <c>true</c> if the specified key contains key; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Determines whether this map contains the specified key-value pair.
            </summary>
            <param name="keyValuePair">The key value pair.</param>
            <returns>
              <c>true</c> if this map contains the key-value pair; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.TryGetValue(`0,`1@)">
            <summary>
            See the <see cref="T:System.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.TryGetKey(`0,`0@)">
            <summary>
            See the <see cref="T:System.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.TryExchangeKey(`0,`0@)">
            <summary>
            Exchanges a key for the actual key instance found in this map.
            </summary>
            <param name="key">The key to search for.</param>
            <param name="existingKey">Receives the equal key found in the map.</param>
            <returns>A value indicating whether an equal and existing key was found in the map.</returns>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.TryCastToImmutableMap(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},Roslyn.Collections.Immutable.ImmutableHashMap{`0,`1}@)">
            <summary>
            Attempts to discover an <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2"/> instance beneath some enumerable sequence
            if one exists.
            </summary>
            <param name="sequence">The sequence that may have come from an immutable map.</param>
            <param name="other">Receives the concrete <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2"/> typed value if one can be found.</param>
            <returns><c>true</c> if the cast was successful; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Boolean,System.Boolean)">
            <summary>
            Bulk adds entries to the map.
            </summary>
            <param name="pairs">The entries to add.</param>
            <param name="overwriteOnCollision"><c>true</c> to allow the <paramref name="pairs"/> sequence to include duplicate keys and let the last one win; <c>false</c> to throw on collisions.</param>
            <param name="avoidToHashMap"><c>true</c> when being called from ToHashMap to avoid StackOverflow.</param>
        </member>
        <member name="F:Roslyn.Collections.Immutable.ImmutableHashMap`2.ValueOrListBucket.Hash">
            <summary>
            The hash for this bucket.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.ValueOrListBucket.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2.ValueOrListBucket"/> class.
            </summary>
            <param name="hash">The hash.</param>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.ValueBucket.#ctor(`0,`1,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2.ValueBucket"/> class.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <param name="hashcode">The hashcode.</param>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.ListBucket.#ctor(Roslyn.Collections.Immutable.ImmutableHashMap{`0,`1}.ValueBucket[])">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2.ListBucket"/> class.
            </summary>
            <param name="buckets">The buckets.</param>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.HashBucket.#ctor(System.Int32,System.UInt32,Roslyn.Collections.Immutable.ImmutableHashMap{`0,`1}.Bucket[],System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2.HashBucket"/> class.
            </summary>
            <param name="hashRoll">The hash roll.</param>
            <param name="used">The used.</param>
            <param name="buckets">The buckets.</param>
            <param name="count">The count.</param>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.HashBucket.#ctor(System.Int32,Roslyn.Collections.Immutable.ImmutableHashMap{`0,`1}.ValueOrListBucket,Roslyn.Collections.Immutable.ImmutableHashMap{`0,`1}.ValueOrListBucket)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2.HashBucket"/> class.
            </summary>
            <param name="suggestedHashRoll">The suggested hash roll.</param>
            <param name="bucket1">The bucket1.</param>
            <param name="bucket2">The bucket2.</param>
        </member>
        <member name="T:Roslyn.Collections.Immutable.ImmutableHashMap`2.DebuggerProxy">
            <summary>
            A simple view of the immutable collection that the debugger can show to the developer.
            </summary>
        </member>
        <member name="F:Roslyn.Collections.Immutable.ImmutableHashMap`2.DebuggerProxy.map">
            <summary>
            The collection to be enumerated.
            </summary>
        </member>
        <member name="F:Roslyn.Collections.Immutable.ImmutableHashMap`2.DebuggerProxy.contents">
            <summary>
            The simple view of the collection.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.DebuggerProxy.#ctor(Roslyn.Collections.Immutable.ImmutableHashMap{`0,`1})">
            <summary>   
            Initializes a new instance of the <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2.DebuggerProxy"/> class.
            </summary>
            <param name="map">The collection to display in the debugger</param>
        </member>
        <member name="P:Roslyn.Collections.Immutable.ImmutableHashMap`2.DebuggerProxy.Contents">
            <summary>
            Gets a simple debugger-viewable collection.
            </summary>
        </member>
    </members>
</doc>
